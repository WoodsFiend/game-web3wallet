// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2UeK4":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "0a8ecb283d214d75";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"bB7Pu":[function(require,module,exports) {
var _ethereum = require("@web3modal/ethereum");
var _html = require("@web3modal/html");
var _core = require("@wagmi/core");
var _chains = require("@wagmi/core/chains");
var _viem = require("viem");
const chains = [
    (0, _chains.mainnet),
    (0, _chains.polygon)
];
const projectId = "8cb9d988c38d5dafd5fbe1f639fd6ff7";
const { publicClient } = (0, _core.configureChains)(chains, [
    (0, _ethereum.w3mProvider)({
        projectId
    })
]);
const wagmiConfig = (0, _core.createConfig)({
    autoConnect: true,
    connectors: (0, _ethereum.w3mConnectors)({
        projectId,
        chains
    }),
    publicClient
});
const ethereumClient = new (0, _ethereum.EthereumClient)(wagmiConfig, chains);
const web3modal = new (0, _html.Web3Modal)({
    projectId
}, ethereumClient);
document.addEventListener("DOMContentLoaded", loadApp());
async function loadApp() {
    const account = (0, _core.getAccount)();
    //web3modal.subscribeModal(() => processAction())
    web3modal.subscribeEvents((modalEvent)=>handleEvents(modalEvent));
    if (account.isConnected) processAction();
    else await web3modal.openModal();
}
async function handleEvents(modalEvent) {
    const CONNECTED = "ACCOUNT_CONNECTED";
    const DISCONNECTED = "ACCOUNT_DISCONNECTED";
    if (modalEvent.name == CONNECTED) processAction();
    else if (modalEvent.name == DISCONNECTED) {
        const responseText = document.getElementById("response-text");
        responseText.innerHTML = "";
        responseText.className = "";
        const responseButton = document.getElementById("response-button");
        responseButton.className = "";
        responseButton.innerHTML = "Copy";
    }
}
async function processAction() {
    const account = (0, _core.getAccount)();
    //Don't process if no account is connected
    if (!account.isConnected || account.isConnecting) return;
    const urlParams = new URLSearchParams(window.location.search);
    const action = urlParams.get("action");
    const message = urlParams.get("message");
    const chainId = urlParams.get("chainId") || 1;
    const to = urlParams.get("to");
    const value = urlParams.get("value");
    const data = urlParams.get("data") || "";
    const gasLimit = urlParams.get("gasLimit") || undefined;
    const gasPrice = urlParams.get("gasPrice") || undefined;
    if (action === "sign" && message) return signWagmiMessage(message);
    if (action === "send" && to && value) return sendWagmiTransaction(chainId, to, value, gasLimit, gasPrice, data);
    if (action === "auth" && message) {
        let account = (0, _core.getAccount)();
        //get the signing message using the message
        let response = await fetch(message + "/functions/requestMessage?address=" + account.address + "&chain=001", {
            method: "POST"
        });
        let jsonData = await response.json();
        console.log(jsonData.result.message);
        return authSignMessage(jsonData.result.message);
    }
    displayResponse("Invalid URL");
}
async function sendWagmiTransaction(chainId, to, value, gasLimit, gasPrice, data) {
    try {
        await new Promise((resolve)=>setTimeout(resolve, 1000));
        const network = await (0, _core.getNetwork)();
        if (network.chainId !== chainId) await (0, _core.switchNetwork)({
            chainId: `0x${parseInt(chainId, 10).toString(16)}`
        });
        const from = (0, _core.getAccount)();
        const tx = await (0, _core.sendTransaction)({
            account: from,
            to: to,
            value: (0, _viem.parseEther)(value)
        });
        console.log({
            tx
        });
        displayResponse("Transaction sent.<br><br>Copy to clipboard then continue to App", tx.hash);
    } catch (error) {
        copyToClipboard("error");
        displayResponse("Transaction Denied");
    }
}
async function authSignMessage(message) {
    try {
        await new Promise((resolve)=>setTimeout(resolve, 3000));
        const signature = await (0, _core.signMessage)({
            message: message
        });
        console.log({
            signature
        });
        const response = {
            signature,
            message
        };
        displayResponse("Signature complete.<br><br>Copy to clipboard then continue to App", JSON.stringify(response));
    } catch (error) {
        copyToClipboard("error");
        displayResponse("Signature Denied");
    }
}
async function signWagmiMessage(message) {
    try {
        await new Promise((resolve)=>setTimeout(resolve, 3000));
        const signature = await (0, _core.signMessage)({
            message: message
        });
        console.log({
            signature
        });
        displayResponse("Signature complete.<br><br>Copy to clipboard then continue to App", signature);
    } catch (error) {
        copyToClipboard("error");
        displayResponse("Signature Denied");
    }
}
async function copyToClipboard(response) {
    try {
        // focus from metamask back to browser
        window.focus(); // wait to finish focus
        await new Promise((resolve)=>setTimeout(resolve, 500)); // copy tx hash to clipboard
        await navigator.clipboard.writeText(response);
        document.getElementById("response-button").innerHTML = "Copied";
    } catch  {
        // for metamask mobile android
        const input = document.createElement("input");
        input.type = "text";
        input.value = response;
        document.body.appendChild(input);
        input.select();
        document.execCommand("Copy");
        input.style = "visibility: hidden";
        document.getElementById("response-button").innerHTML = "Copied";
    }
}
function displayResponse(text, response) {
    // display error or response
    const responseText = document.getElementById("response-text");
    responseText.innerHTML = text;
    responseText.className = "active";
    if (response) {
        // display button to copy tx.hash or signature
        const responseButton = document.getElementById("response-button");
        responseButton.className = "active";
        responseButton.onclick = ()=>copyToClipboard(response);
    }
}

},{"@web3modal/ethereum":"37UAX","@web3modal/html":"4Skid","@wagmi/core":"cDeGj","@wagmi/core/chains":"fjq96","viem":"eKtik"}],"37UAX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EthereumClient", ()=>j);
parcelHelpers.export(exports, "w3mConnectors", ()=>W);
parcelHelpers.export(exports, "w3mProvider", ()=>N);
var _core = require("@wagmi/core");
var _walletConnect = require("@wagmi/core/connectors/walletConnect");
var _jsonRpc = require("@wagmi/core/providers/jsonRpc");
const y = "wallet_addEthereumChain";
class j {
    constructor(t, e){
        this.wagmi = {}, this.chains = [], this.namespace = "eip155", this.disconnect = (0, _core.disconnect), this.getAccount = (0, _core.getAccount), this.watchAccount = (0, _core.watchAccount), this.fetchBalance = (0, _core.fetchBalance), this.getNetwork = (0, _core.getNetwork), this.watchNetwork = (0, _core.watchNetwork), this.switchNetwork = (0, _core.switchNetwork), this.fetchEnsName = (0, _core.fetchEnsName), this.fetchEnsAvatar = (0, _core.fetchEnsAvatar), this.wagmi = t, this.chains = e;
    }
    getWalletConnectConnector() {
        const t = this.wagmi.connectors.find((e)=>e.id === "walletConnect");
        if (!t) throw new Error("WalletConnectConnector is required");
        return t;
    }
    async connectWalletConnectProvider(t, e) {
        return await t.getProvider(), new Promise((n)=>{
            t.once("message", (o)=>{
                o.type === "display_uri" && (e(o.data), n());
            });
        });
    }
    getConnectorById(t) {
        const e = this.wagmi.connectors.find((n)=>n.id === t);
        if (!e) throw new Error(`Connector for id ${t} was not found`);
        return e;
    }
    getConnectors() {
        return this.wagmi.connectors.filter((t)=>!t.id.includes("walletConnect"));
    }
    async connectWalletConnect(t, e) {
        const n = this.getWalletConnectConnector(), o = {
            connector: n
        };
        return e && (o.chainId = e), Promise.all([
            (0, _core.connect)(o),
            this.connectWalletConnectProvider(n, t)
        ]);
    }
    async connectConnector(t, e) {
        const n = {
            connector: this.getConnectorById(t)
        };
        return e && (n.chainId = e), await (0, _core.connect)(n);
    }
    isInjectedProviderInstalled() {
        return typeof window.ethereum < "u";
    }
    safeCheckInjectedProvider(t) {
        var e;
        try {
            const n = String(t);
            return Boolean((e = window.ethereum) == null ? void 0 : e[n]);
        } catch (n) {
            return console.error(n), !1;
        }
    }
    async getConnectedChainIds() {
        var t, e, n;
        const o = (e = (t = (await this.getWalletConnectConnector().getProvider()).signer) == null ? void 0 : t.session) == null ? void 0 : e.namespaces, s = (n = o?.[this.namespace]) == null ? void 0 : n.methods;
        if (s != null && s.includes(y)) return "ALL";
        if (o) {
            const i = [];
            return Object.keys(o).forEach((r)=>{
                r.includes(this.namespace) && i.push(...o[r].accounts);
            }), i?.map((r)=>r.split(":")[1]);
        }
        return "ALL";
    }
}
const E = "eip155";
function N({ projectId: c }) {
    return (0, _jsonRpc.jsonRpcProvider)({
        rpc: (t)=>{
            var e;
            return [
                1,
                3,
                4,
                5,
                10,
                42,
                56,
                69,
                97,
                100,
                137,
                280,
                324,
                420,
                42161,
                42220,
                43114,
                80001,
                421611,
                421613,
                1313161554,
                1313161555
            ].includes(t.id) ? {
                http: `https://rpc.walletconnect.com/v1/?chainId=${E}:${t.id}&projectId=${c}`
            } : {
                http: t.rpcUrls.default.http[0],
                webSocket: (e = t.rpcUrls.default.webSocket) == null ? void 0 : e[0]
            };
        }
    });
}
function W({ chains: c, projectId: t }) {
    return [
        new (0, _walletConnect.WalletConnectConnector)({
            chains: c,
            options: {
                projectId: t,
                showQrModal: !1
            }
        }),
        new (0, _core.InjectedConnector)({
            chains: c,
            options: {
                shimDisconnect: !0
            }
        })
    ];
}

},{"@wagmi/core":"cDeGj","@wagmi/core/connectors/walletConnect":"lY5Qi","@wagmi/core/providers/jsonRpc":"kEHWO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDeGj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainMismatchError", ()=>(0, _chunkLAFZBYO7Js.ChainMismatchError));
parcelHelpers.export(exports, "ChainNotConfiguredError", ()=>(0, _chunkLAFZBYO7Js.ChainNotConfiguredError));
parcelHelpers.export(exports, "Config", ()=>(0, _chunkLAFZBYO7Js.Config));
parcelHelpers.export(exports, "ConfigChainsNotFound", ()=>(0, _chunkLAFZBYO7Js.ConfigChainsNotFound));
parcelHelpers.export(exports, "Connector", ()=>(0, _chunkBVC4KGLQJs.Connector));
parcelHelpers.export(exports, "ConnectorAlreadyConnectedError", ()=>(0, _chunkLAFZBYO7Js.ConnectorAlreadyConnectedError));
parcelHelpers.export(exports, "ConnectorNotFoundError", ()=>(0, _chunkLAFZBYO7Js.ConnectorNotFoundError));
parcelHelpers.export(exports, "InjectedConnector", ()=>(0, _chunkEQOEZP46Js.InjectedConnector));
parcelHelpers.export(exports, "SwitchChainNotSupportedError", ()=>(0, _chunkLAFZBYO7Js.SwitchChainNotSupportedError));
parcelHelpers.export(exports, "configureChains", ()=>(0, _chunkLAFZBYO7Js.configureChains));
parcelHelpers.export(exports, "connect", ()=>(0, _chunkLAFZBYO7Js.connect));
parcelHelpers.export(exports, "createConfig", ()=>(0, _chunkLAFZBYO7Js.createConfig));
parcelHelpers.export(exports, "createStorage", ()=>(0, _chunkLAFZBYO7Js.createStorage));
parcelHelpers.export(exports, "deepEqual", ()=>(0, _chunkLAFZBYO7Js.deepEqual));
parcelHelpers.export(exports, "deserialize", ()=>(0, _chunkLAFZBYO7Js.deserialize));
parcelHelpers.export(exports, "disconnect", ()=>(0, _chunkLAFZBYO7Js.disconnect));
parcelHelpers.export(exports, "erc20ABI", ()=>(0, _chunkLAFZBYO7Js.erc20ABI));
parcelHelpers.export(exports, "erc4626ABI", ()=>(0, _chunkLAFZBYO7Js.erc4626ABI));
parcelHelpers.export(exports, "erc721ABI", ()=>(0, _chunkLAFZBYO7Js.erc721ABI));
parcelHelpers.export(exports, "fetchBalance", ()=>(0, _chunkLAFZBYO7Js.fetchBalance));
parcelHelpers.export(exports, "fetchBlockNumber", ()=>(0, _chunkLAFZBYO7Js.fetchBlockNumber));
parcelHelpers.export(exports, "fetchEnsAddress", ()=>(0, _chunkLAFZBYO7Js.fetchEnsAddress));
parcelHelpers.export(exports, "fetchEnsAvatar", ()=>(0, _chunkLAFZBYO7Js.fetchEnsAvatar));
parcelHelpers.export(exports, "fetchEnsName", ()=>(0, _chunkLAFZBYO7Js.fetchEnsName));
parcelHelpers.export(exports, "fetchEnsResolver", ()=>(0, _chunkLAFZBYO7Js.fetchEnsResolver));
parcelHelpers.export(exports, "fetchFeeData", ()=>(0, _chunkLAFZBYO7Js.fetchFeeData));
parcelHelpers.export(exports, "fetchToken", ()=>(0, _chunkLAFZBYO7Js.fetchToken));
parcelHelpers.export(exports, "fetchTransaction", ()=>(0, _chunkLAFZBYO7Js.fetchTransaction));
parcelHelpers.export(exports, "getAccount", ()=>(0, _chunkLAFZBYO7Js.getAccount));
parcelHelpers.export(exports, "getConfig", ()=>(0, _chunkLAFZBYO7Js.getConfig));
parcelHelpers.export(exports, "getContract", ()=>(0, _chunkLAFZBYO7Js.getContract));
parcelHelpers.export(exports, "getNetwork", ()=>(0, _chunkLAFZBYO7Js.getNetwork));
parcelHelpers.export(exports, "getPublicClient", ()=>(0, _chunkLAFZBYO7Js.getPublicClient));
parcelHelpers.export(exports, "getUnit", ()=>(0, _chunkLAFZBYO7Js.getUnit));
parcelHelpers.export(exports, "getWalletClient", ()=>(0, _chunkLAFZBYO7Js.getWalletClient));
parcelHelpers.export(exports, "getWebSocketPublicClient", ()=>(0, _chunkLAFZBYO7Js.getWebSocketPublicClient));
parcelHelpers.export(exports, "mainnet", ()=>(0, _chunkD7TYCC3TJs.mainnet));
parcelHelpers.export(exports, "multicall", ()=>(0, _chunkLAFZBYO7Js.multicall));
parcelHelpers.export(exports, "noopStorage", ()=>(0, _chunkLAFZBYO7Js.noopStorage));
parcelHelpers.export(exports, "prepareSendTransaction", ()=>(0, _chunkLAFZBYO7Js.prepareSendTransaction));
parcelHelpers.export(exports, "prepareWriteContract", ()=>(0, _chunkLAFZBYO7Js.prepareWriteContract));
parcelHelpers.export(exports, "readContract", ()=>(0, _chunkLAFZBYO7Js.readContract));
parcelHelpers.export(exports, "readContracts", ()=>(0, _chunkLAFZBYO7Js.readContracts));
parcelHelpers.export(exports, "sendTransaction", ()=>(0, _chunkLAFZBYO7Js.sendTransaction));
parcelHelpers.export(exports, "sepolia", ()=>(0, _chunkD7TYCC3TJs.sepolia));
parcelHelpers.export(exports, "serialize", ()=>(0, _chunkLAFZBYO7Js.serialize));
parcelHelpers.export(exports, "signMessage", ()=>(0, _chunkLAFZBYO7Js.signMessage));
parcelHelpers.export(exports, "signTypedData", ()=>(0, _chunkLAFZBYO7Js.signTypedData));
parcelHelpers.export(exports, "switchNetwork", ()=>(0, _chunkLAFZBYO7Js.switchNetwork));
parcelHelpers.export(exports, "waitForTransaction", ()=>(0, _chunkLAFZBYO7Js.waitForTransaction));
parcelHelpers.export(exports, "watchAccount", ()=>(0, _chunkLAFZBYO7Js.watchAccount));
parcelHelpers.export(exports, "watchBlockNumber", ()=>(0, _chunkLAFZBYO7Js.watchBlockNumber));
parcelHelpers.export(exports, "watchContractEvent", ()=>(0, _chunkLAFZBYO7Js.watchContractEvent));
parcelHelpers.export(exports, "watchMulticall", ()=>(0, _chunkLAFZBYO7Js.watchMulticall));
parcelHelpers.export(exports, "watchNetwork", ()=>(0, _chunkLAFZBYO7Js.watchNetwork));
parcelHelpers.export(exports, "watchPendingTransactions", ()=>(0, _chunkLAFZBYO7Js.watchPendingTransactions));
parcelHelpers.export(exports, "watchPublicClient", ()=>(0, _chunkLAFZBYO7Js.watchPublicClient));
parcelHelpers.export(exports, "watchReadContract", ()=>(0, _chunkLAFZBYO7Js.watchReadContract));
parcelHelpers.export(exports, "watchReadContracts", ()=>(0, _chunkLAFZBYO7Js.watchReadContracts));
parcelHelpers.export(exports, "watchWalletClient", ()=>(0, _chunkLAFZBYO7Js.watchWalletClient));
parcelHelpers.export(exports, "watchWebSocketPublicClient", ()=>(0, _chunkLAFZBYO7Js.watchWebSocketPublicClient));
parcelHelpers.export(exports, "writeContract", ()=>(0, _chunkLAFZBYO7Js.writeContract));
var _chunkKX4UEHS5Js = require("./chunk-KX4UEHS5.js");
var _chunkLAFZBYO7Js = require("./chunk-LAFZBYO7.js");
var _chunkD7TYCC3TJs = require("./chunk-D7TYCC3T.js");
var _chunkBVC4KGLQJs = require("./chunk-BVC4KGLQ.js");
var _chunkEQOEZP46Js = require("./chunk-EQOEZP46.js");
var _chunkMQXBDTVKJs = require("./chunk-MQXBDTVK.js");

},{"./chunk-KX4UEHS5.js":"9Ixpv","./chunk-LAFZBYO7.js":"8T0ST","./chunk-D7TYCC3T.js":false,"./chunk-BVC4KGLQ.js":false,"./chunk-EQOEZP46.js":"7G1WP","./chunk-MQXBDTVK.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Ixpv":[function(require,module,exports) {

},{}],"8T0ST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "configureChains", ()=>configureChains);
parcelHelpers.export(exports, "ChainMismatchError", ()=>ChainMismatchError);
parcelHelpers.export(exports, "ChainNotConfiguredError", ()=>ChainNotConfiguredError);
parcelHelpers.export(exports, "ConnectorAlreadyConnectedError", ()=>ConnectorAlreadyConnectedError);
parcelHelpers.export(exports, "ConfigChainsNotFound", ()=>ConfigChainsNotFound);
parcelHelpers.export(exports, "SwitchChainNotSupportedError", ()=>SwitchChainNotSupportedError);
parcelHelpers.export(exports, "ConnectorNotFoundError", ()=>(0, _connectors.ConnectorNotFoundError));
parcelHelpers.export(exports, "deepEqual", ()=>deepEqual);
parcelHelpers.export(exports, "deserialize", ()=>deserialize);
parcelHelpers.export(exports, "getCallParameters", ()=>getCallParameters);
parcelHelpers.export(exports, "getSendTransactionParameters", ()=>getSendTransactionParameters);
parcelHelpers.export(exports, "getUnit", ()=>getUnit);
parcelHelpers.export(exports, "serialize", ()=>serialize);
parcelHelpers.export(exports, "noopStorage", ()=>noopStorage);
parcelHelpers.export(exports, "createStorage", ()=>createStorage);
parcelHelpers.export(exports, "Config", ()=>Config);
parcelHelpers.export(exports, "createConfig", ()=>createConfig);
parcelHelpers.export(exports, "getConfig", ()=>getConfig);
parcelHelpers.export(exports, "connect", ()=>connect);
parcelHelpers.export(exports, "disconnect", ()=>disconnect);
parcelHelpers.export(exports, "erc20ABI", ()=>erc20ABI);
parcelHelpers.export(exports, "erc721ABI", ()=>erc721ABI);
parcelHelpers.export(exports, "erc4626ABI", ()=>erc4626ABI);
parcelHelpers.export(exports, "fetchToken", ()=>fetchToken);
parcelHelpers.export(exports, "getPublicClient", ()=>getPublicClient);
parcelHelpers.export(exports, "getWalletClient", ()=>getWalletClient);
parcelHelpers.export(exports, "getWebSocketPublicClient", ()=>getWebSocketPublicClient);
parcelHelpers.export(exports, "watchPublicClient", ()=>watchPublicClient);
parcelHelpers.export(exports, "watchWalletClient", ()=>watchWalletClient);
parcelHelpers.export(exports, "watchWebSocketPublicClient", ()=>watchWebSocketPublicClient);
parcelHelpers.export(exports, "prepareWriteContract", ()=>prepareWriteContract);
parcelHelpers.export(exports, "getContract", ()=>getContract);
parcelHelpers.export(exports, "multicall", ()=>multicall);
parcelHelpers.export(exports, "readContract", ()=>readContract);
parcelHelpers.export(exports, "readContracts", ()=>readContracts);
parcelHelpers.export(exports, "watchContractEvent", ()=>watchContractEvent);
parcelHelpers.export(exports, "watchBlockNumber", ()=>watchBlockNumber);
parcelHelpers.export(exports, "watchMulticall", ()=>watchMulticall);
parcelHelpers.export(exports, "watchReadContract", ()=>watchReadContract);
parcelHelpers.export(exports, "watchReadContracts", ()=>watchReadContracts);
parcelHelpers.export(exports, "writeContract", ()=>writeContract);
parcelHelpers.export(exports, "fetchBalance", ()=>fetchBalance);
parcelHelpers.export(exports, "getAccount", ()=>getAccount);
parcelHelpers.export(exports, "getNetwork", ()=>getNetwork);
parcelHelpers.export(exports, "signMessage", ()=>signMessage);
parcelHelpers.export(exports, "signTypedData", ()=>signTypedData);
parcelHelpers.export(exports, "switchNetwork", ()=>switchNetwork);
parcelHelpers.export(exports, "watchAccount", ()=>watchAccount);
parcelHelpers.export(exports, "watchNetwork", ()=>watchNetwork);
parcelHelpers.export(exports, "fetchEnsAddress", ()=>fetchEnsAddress);
parcelHelpers.export(exports, "fetchEnsAvatar", ()=>fetchEnsAvatar);
parcelHelpers.export(exports, "fetchEnsName", ()=>fetchEnsName);
parcelHelpers.export(exports, "fetchEnsResolver", ()=>fetchEnsResolver);
parcelHelpers.export(exports, "fetchBlockNumber", ()=>fetchBlockNumber);
parcelHelpers.export(exports, "fetchFeeData", ()=>fetchFeeData);
parcelHelpers.export(exports, "fetchTransaction", ()=>fetchTransaction);
parcelHelpers.export(exports, "prepareSendTransaction", ()=>prepareSendTransaction);
parcelHelpers.export(exports, "sendTransaction", ()=>sendTransaction);
parcelHelpers.export(exports, "waitForTransaction", ()=>waitForTransaction);
parcelHelpers.export(exports, "watchPendingTransactions", ()=>watchPendingTransactions);
var _chunkBVC4KGLQJs = require("./chunk-BVC4KGLQ.js");
var _chunkMQXBDTVKJs = require("./chunk-MQXBDTVK.js");
// src/utils/configureChains.ts
var _viem = require("viem");
// src/errors.ts
var _connectors = require("@wagmi/connectors");
// src/config.ts
var _middleware = require("zustand/middleware");
var _vanilla = require("zustand/vanilla");
// src/actions/viem/watchWalletClient.ts
var _shallow = require("zustand/shallow");
var _ens = require("viem/ens");
function configureChains(defaultChains, providers, { batch = {
    multicall: {
        wait: 32
    }
}, pollingInterval = 4e3, rank, retryCount, retryDelay, stallTimeout } = {}) {
    if (!defaultChains.length) throw new Error("must have at least one chain");
    let chains = [];
    const httpUrls = {};
    const wsUrls = {};
    for (const chain of defaultChains){
        let configExists = false;
        for (const provider of providers){
            const apiConfig = provider(chain);
            if (!apiConfig) continue;
            configExists = true;
            if (!chains.some(({ id })=>id === chain.id)) chains = [
                ...chains,
                apiConfig.chain
            ];
            httpUrls[chain.id] = [
                ...httpUrls[chain.id] || [],
                ...apiConfig.rpcUrls.http
            ];
            if (apiConfig.rpcUrls.webSocket) wsUrls[chain.id] = [
                ...wsUrls[chain.id] || [],
                ...apiConfig.rpcUrls.webSocket
            ];
        }
        if (!configExists) throw new Error([
            `Could not find valid provider configuration for chain "${chain.name}".
`,
            "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
            "Read more: https://wagmi.sh/core/providers/jsonRpc"
        ].join("\n"));
    }
    return {
        chains,
        publicClient: ({ chainId })=>{
            const activeChain = chains.find((x)=>x.id === chainId) ?? defaultChains[0];
            const chainHttpUrls = httpUrls[activeChain.id];
            if (!chainHttpUrls || !chainHttpUrls[0]) throw new Error(`No providers configured for chain "${activeChain.id}"`);
            const publicClient = (0, _viem.createPublicClient)({
                batch,
                chain: activeChain,
                transport: (0, _viem.fallback)(chainHttpUrls.map((url)=>(0, _viem.http)(url, {
                        timeout: stallTimeout
                    })), {
                    rank,
                    retryCount,
                    retryDelay
                }),
                pollingInterval
            });
            return Object.assign(publicClient, {
                chains
            });
        },
        webSocketPublicClient: ({ chainId })=>{
            const activeChain = chains.find((x)=>x.id === chainId) ?? defaultChains[0];
            const chainWsUrls = wsUrls[activeChain.id];
            if (!chainWsUrls || !chainWsUrls[0]) return void 0;
            const publicClient = (0, _viem.createPublicClient)({
                batch,
                chain: activeChain,
                transport: (0, _viem.fallback)(chainWsUrls.map((url)=>(0, _viem.webSocket)(url, {
                        timeout: stallTimeout
                    })), {
                    rank,
                    retryCount,
                    retryDelay
                }),
                pollingInterval
            });
            return Object.assign(publicClient, {
                chains
            });
        }
    };
}
var ChainMismatchError = class extends Error {
    constructor({ activeChain, targetChain }){
        super(`Chain mismatch: Expected "${targetChain}", received "${activeChain}".`);
        this.name = "ChainMismatchError";
    }
};
var ChainNotConfiguredError = class extends Error {
    constructor({ chainId, connectorId }){
        super(`Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`);
        this.name = "ChainNotConfigured";
    }
};
var ConnectorAlreadyConnectedError = class extends Error {
    constructor(){
        super(...arguments);
        this.name = "ConnectorAlreadyConnectedError";
        this.message = "Connector already connected";
    }
};
var ConfigChainsNotFound = class extends Error {
    constructor(){
        super(...arguments);
        this.name = "ConfigChainsNotFound";
        this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
    }
};
var SwitchChainNotSupportedError = class extends Error {
    constructor({ connector }){
        super(`"${connector.name}" does not support programmatic chain switching.`);
        this.name = "SwitchChainNotSupportedError";
    }
};
// src/utils/deepEqual.ts
function deepEqual(a, b) {
    if (a === b) return true;
    if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor) return false;
        let length;
        let i;
        if (Array.isArray(a) && Array.isArray(b)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!deepEqual(a[i], b[i])) return false;
            return true;
        }
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        const keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            const key = keys[i];
            if (key && !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
// src/utils/deserialize.ts
var findAndReplace = (cacheRef, { find, replace })=>{
    if (cacheRef && find(cacheRef)) return replace(cacheRef);
    if (typeof cacheRef !== "object") return cacheRef;
    if (Array.isArray(cacheRef)) return cacheRef.map((item)=>findAndReplace(item, {
            find,
            replace
        }));
    if (cacheRef instanceof Object) return Object.entries(cacheRef).reduce((curr, [key, value])=>({
            ...curr,
            [key]: findAndReplace(value, {
                find,
                replace
            })
        }), {});
    return cacheRef;
};
function deserialize(cachedString) {
    const cache = JSON.parse(cachedString);
    const deserializedCacheWithBigInts = findAndReplace(cache, {
        find: (data)=>typeof data === "string" && data.startsWith("#bigint."),
        replace: (data)=>BigInt(data.replace("#bigint.", ""))
    });
    return deserializedCacheWithBigInts;
}
// src/utils/getParameters.ts
function getCallParameters(args) {
    return {
        accessList: args.accessList,
        account: args.account,
        blockNumber: args.blockNumber,
        blockTag: args.blockTag,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
    };
}
function getSendTransactionParameters(args) {
    return {
        accessList: args.accessList,
        account: args.account,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
    };
}
function getUnit(unit) {
    if (typeof unit === "number") return unit;
    if (unit === "wei") return 0;
    return Math.abs((0, _viem.weiUnits)[unit]);
}
// src/utils/serialize.ts
function getReferenceKey(keys, cutoff) {
    return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
    const { length } = array;
    for(let index = 0; index < length; ++index){
        if (array[index] === value) return index + 1;
    }
    return 0;
}
function createReplacer(replacer, circularReplacer) {
    const hasReplacer = typeof replacer === "function";
    const hasCircularReplacer = typeof circularReplacer === "function";
    const cache = [];
    const keys = [];
    return function replace(key, value) {
        if (typeof value === "object") {
            if (cache.length) {
                const thisCutoff = getCutoff(cache, this);
                if (thisCutoff === 0) cache[cache.length] = this;
                else {
                    cache.splice(thisCutoff);
                    keys.splice(thisCutoff);
                }
                keys[keys.length] = key;
                const valueCutoff = getCutoff(cache, value);
                if (valueCutoff !== 0) return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
            } else {
                cache[0] = value;
                keys[0] = key;
            }
        }
        return hasReplacer ? replacer.call(this, key, value) : value;
    };
}
function serialize(value, replacer, indent, circularReplacer) {
    return JSON.stringify(value, createReplacer((key, value_)=>{
        const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
        return replacer?.(key, value2) || value2;
    }, circularReplacer), indent ?? void 0);
}
// src/storage.ts
var noopStorage = {
    getItem: (_key)=>"",
    setItem: (_key, _value)=>null,
    removeItem: (_key)=>null
};
function createStorage({ deserialize: deserialize2 = deserialize, key: prefix = "wagmi", serialize: serialize2 = serialize, storage }) {
    return {
        ...storage,
        getItem: (key, defaultState = null)=>{
            const value = storage.getItem(`${prefix}.${key}`);
            try {
                return value ? deserialize2(value) : defaultState;
            } catch (error) {
                console.warn(error);
                return defaultState;
            }
        },
        setItem: (key, value)=>{
            if (value === null) storage.removeItem(`${prefix}.${key}`);
            else try {
                storage.setItem(`${prefix}.${key}`, serialize2(value));
            } catch (err) {
                console.error(err);
            }
        },
        removeItem: (key)=>storage.removeItem(`${prefix}.${key}`)
    };
}
// src/config.ts
var storeKey = "store";
var _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;
var Config = class {
    constructor({ autoConnect = false, connectors = [
        new (0, _chunkBVC4KGLQJs.InjectedConnector)()
    ], publicClient, storage = createStorage({
        storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }), logger = {
        warn: console.warn
    }, webSocketPublicClient }){
        (0, _chunkMQXBDTVKJs.__privateAdd)(this, _addEffects);
        this.publicClients = /* @__PURE__ */ new Map();
        this.webSocketPublicClients = /* @__PURE__ */ new Map();
        (0, _chunkMQXBDTVKJs.__privateAdd)(this, _isAutoConnecting, void 0);
        (0, _chunkMQXBDTVKJs.__privateAdd)(this, _lastUsedConnector, void 0);
        this.args = {
            autoConnect,
            connectors,
            logger,
            publicClient,
            storage,
            webSocketPublicClient
        };
        let status = "disconnected";
        let chainId;
        if (autoConnect) try {
            const rawState = storage.getItem(storeKey);
            const data = rawState?.state?.data;
            status = data?.account ? "reconnecting" : "connecting";
            chainId = data?.chain?.id;
        } catch (_error) {}
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector)=>connector.setStorage(storage));
        this.store = (0, _vanilla.createStore)((0, _middleware.subscribeWithSelector)((0, _middleware.persist)(()=>({
                connectors: connectors_,
                publicClient: this.getPublicClient({
                    chainId
                }),
                status,
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }), {
            name: storeKey,
            storage,
            partialize: (state)=>({
                    ...autoConnect && {
                        data: {
                            account: state?.data?.account,
                            chain: state?.data?.chain
                        }
                    },
                    chains: state?.chains
                }),
            version: 2
        })));
        this.storage = storage;
        (0, _chunkMQXBDTVKJs.__privateSet)(this, _lastUsedConnector, storage?.getItem("wallet"));
        (0, _chunkMQXBDTVKJs.__privateMethod)(this, _addEffects, addEffects_fn).call(this);
        if (autoConnect && typeof window !== "undefined") setTimeout(async ()=>await this.autoConnect(), 0);
    }
    get chains() {
        return this.store.getState().chains;
    }
    get connectors() {
        return this.store.getState().connectors;
    }
    get connector() {
        return this.store.getState().connector;
    }
    get data() {
        return this.store.getState().data;
    }
    get error() {
        return this.store.getState().error;
    }
    get lastUsedChainId() {
        return this.data?.chain?.id;
    }
    get publicClient() {
        return this.store.getState().publicClient;
    }
    get status() {
        return this.store.getState().status;
    }
    get subscribe() {
        return this.store.subscribe;
    }
    get webSocketPublicClient() {
        return this.store.getState().webSocketPublicClient;
    }
    setState(updater) {
        const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
        this.store.setState(newState, true);
    }
    clearState() {
        this.setState((x)=>({
                ...x,
                chains: void 0,
                connector: void 0,
                data: void 0,
                error: void 0,
                status: "disconnected"
            }));
    }
    async destroy() {
        if (this.connector) await this.connector.disconnect?.();
        (0, _chunkMQXBDTVKJs.__privateSet)(this, _isAutoConnecting, false);
        this.clearState();
        this.store.destroy();
    }
    async autoConnect() {
        if ((0, _chunkMQXBDTVKJs.__privateGet)(this, _isAutoConnecting)) return;
        (0, _chunkMQXBDTVKJs.__privateSet)(this, _isAutoConnecting, true);
        this.setState((x)=>({
                ...x,
                status: x.data?.account ? "reconnecting" : "connecting"
            }));
        const sorted = (0, _chunkMQXBDTVKJs.__privateGet)(this, _lastUsedConnector) ? [
            ...this.connectors
        ].sort((x)=>x.id === (0, _chunkMQXBDTVKJs.__privateGet)(this, _lastUsedConnector) ? -1 : 1) : this.connectors;
        let connected = false;
        for (const connector of sorted){
            if (!connector.ready || !connector.isAuthorized) continue;
            const isAuthorized = await connector.isAuthorized();
            if (!isAuthorized) continue;
            const data = await connector.connect();
            this.setState((x)=>({
                    ...x,
                    connector,
                    chains: connector?.chains,
                    data,
                    status: "connected"
                }));
            connected = true;
            break;
        }
        if (!connected) this.setState((x)=>({
                ...x,
                data: void 0,
                status: "disconnected"
            }));
        (0, _chunkMQXBDTVKJs.__privateSet)(this, _isAutoConnecting, false);
        return this.data;
    }
    setConnectors(connectors) {
        this.args = {
            ...this.args,
            connectors
        };
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector)=>connector.setStorage(this.args.storage));
        this.setState((x)=>({
                ...x,
                connectors: connectors_
            }));
    }
    getPublicClient({ chainId } = {}) {
        let publicClient_ = this.publicClients.get(-1);
        if (publicClient_ && publicClient_?.chain.id === chainId) return publicClient_;
        publicClient_ = this.publicClients.get(chainId ?? -1);
        if (publicClient_) return publicClient_;
        const { publicClient } = this.args;
        publicClient_ = typeof publicClient === "function" ? publicClient({
            chainId
        }) : publicClient;
        this.publicClients.set(chainId ?? -1, publicClient_);
        return publicClient_;
    }
    setPublicClient(publicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
            ...this.args,
            publicClient
        };
        this.publicClients.clear();
        this.setState((x)=>({
                ...x,
                publicClient: this.getPublicClient({
                    chainId
                })
            }));
    }
    getWebSocketPublicClient({ chainId } = {}) {
        let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
        if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId) return webSocketPublicClient_;
        webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);
        if (webSocketPublicClient_) return webSocketPublicClient_;
        const { webSocketPublicClient } = this.args;
        webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({
            chainId
        }) : webSocketPublicClient;
        if (webSocketPublicClient_) this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);
        return webSocketPublicClient_;
    }
    setWebSocketPublicClient(webSocketPublicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
            ...this.args,
            webSocketPublicClient
        };
        this.webSocketPublicClients.clear();
        this.setState((x)=>({
                ...x,
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }));
    }
    setLastUsedConnector(lastUsedConnector = null) {
        this.storage?.setItem("wallet", lastUsedConnector);
    }
};
_isAutoConnecting = new WeakMap();
_lastUsedConnector = new WeakMap();
_addEffects = new WeakSet();
addEffects_fn = function() {
    const onChange = (data)=>{
        this.setState((x)=>({
                ...x,
                data: {
                    ...x.data,
                    ...data
                }
            }));
    };
    const onDisconnect = ()=>{
        this.clearState();
    };
    const onError = (error)=>{
        this.setState((x)=>({
                ...x,
                error
            }));
    };
    this.store.subscribe(({ connector })=>connector, (connector, prevConnector)=>{
        prevConnector?.off?.("change", onChange);
        prevConnector?.off?.("disconnect", onDisconnect);
        prevConnector?.off?.("error", onError);
        if (!connector) return;
        connector.on?.("change", onChange);
        connector.on?.("disconnect", onDisconnect);
        connector.on?.("error", onError);
    });
    const { publicClient, webSocketPublicClient } = this.args;
    const subscribePublicClient = typeof publicClient === "function";
    const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
    if (subscribePublicClient || subscribeWebSocketPublicClient) this.store.subscribe(({ data })=>data?.chain?.id, (chainId)=>{
        this.setState((x)=>({
                ...x,
                publicClient: this.getPublicClient({
                    chainId
                }),
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }));
    });
};
var config;
function createConfig(args) {
    const config_ = new Config(args);
    config = config_;
    return config_;
}
function getConfig() {
    if (!config) throw new Error("No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config");
    return config;
}
// src/actions/accounts/connect.ts
async function connect({ chainId, connector }) {
    const config2 = getConfig();
    const activeConnector = config2.connector;
    if (activeConnector && connector.id === activeConnector.id) throw new ConnectorAlreadyConnectedError();
    try {
        config2.setState((x)=>({
                ...x,
                status: "connecting"
            }));
        const data = await connector.connect({
            chainId
        });
        config2.setLastUsedConnector(connector.id);
        config2.setState((x)=>({
                ...x,
                connector,
                chains: connector?.chains,
                data,
                status: "connected"
            }));
        config2.storage.setItem("connected", true);
        return {
            ...data,
            connector
        };
    } catch (err) {
        config2.setState((x)=>{
            return {
                ...x,
                status: x.connector ? "connected" : "disconnected"
            };
        });
        throw err;
    }
}
// src/actions/accounts/disconnect.ts
async function disconnect() {
    const config2 = getConfig();
    if (config2.connector) await config2.connector.disconnect();
    config2.clearState();
    config2.storage.removeItem("connected");
}
// src/constants/abis.ts
var erc20ABI = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    }
];
var erc20ABI_bytes32 = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ]
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    }
];
var erc721ABI = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: true,
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "ApprovalForAll",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "operator",
                type: "address"
            },
            {
                indexed: false,
                name: "approved",
                type: "bool"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "payable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "getApproved",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "address"
            }
        ]
    },
    {
        type: "function",
        name: "isApprovedForAll",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "operator",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "ownerOf",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "owner",
                type: "address"
            }
        ]
    },
    {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "payable",
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "id",
                type: "uint256"
            },
            {
                name: "data",
                type: "bytes"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "setApprovalForAll",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "operator",
                type: "address"
            },
            {
                name: "approved",
                type: "bool"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
            {
                name: "index",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "index",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "tokenURI",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "payable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "tokeId",
                type: "uint256"
            }
        ],
        outputs: []
    }
];
var erc4626ABI = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                name: "receiver",
                type: "address"
            },
            {
                indexed: false,
                name: "assets",
                type: "uint256"
            },
            {
                indexed: false,
                name: "shares",
                type: "uint256"
            }
        ],
        name: "Deposit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                name: "receiver",
                type: "address"
            },
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: false,
                name: "assets",
                type: "uint256"
            },
            {
                indexed: false,
                name: "shares",
                type: "uint256"
            }
        ],
        name: "Withdraw",
        type: "event"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "asset",
        outputs: [
            {
                name: "assetTokenAddress",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "convertToAssets",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "convertToShares",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            }
        ],
        name: "deposit",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "caller",
                type: "address"
            }
        ],
        name: "maxDeposit",
        outputs: [
            {
                name: "maxAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "caller",
                type: "address"
            }
        ],
        name: "maxMint",
        outputs: [
            {
                name: "maxShares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "maxRedeem",
        outputs: [
            {
                name: "maxShares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "maxWithdraw",
        outputs: [
            {
                name: "maxAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            }
        ],
        name: "mint",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "previewDeposit",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "previewMint",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "previewRedeem",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "previewWithdraw",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            },
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "redeem",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "totalAssets",
        outputs: [
            {
                name: "totalManagedAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "to",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            },
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "withdraw",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    }
];
async function fetchToken({ address, chainId, formatUnits: unit = 18 }) {
    async function fetchToken_({ abi }) {
        const erc20Config = {
            address,
            abi,
            chainId
        };
        const [decimals, name, symbol, totalSupply] = await readContracts({
            allowFailure: false,
            contracts: [
                {
                    ...erc20Config,
                    functionName: "decimals"
                },
                {
                    ...erc20Config,
                    functionName: "name"
                },
                {
                    ...erc20Config,
                    functionName: "symbol"
                },
                {
                    ...erc20Config,
                    functionName: "totalSupply"
                }
            ]
        });
        return {
            address,
            decimals,
            name,
            symbol,
            totalSupply: {
                formatted: (0, _viem.formatUnits)(totalSupply, getUnit(unit)),
                value: totalSupply
            }
        };
    }
    try {
        return await fetchToken_({
            abi: erc20ABI
        });
    } catch (err) {
        if (err instanceof (0, _viem.ContractFunctionExecutionError)) {
            const { name, symbol, ...rest } = await fetchToken_({
                abi: erc20ABI_bytes32
            });
            return {
                name: (0, _viem.hexToString)((0, _viem.trim)(name, {
                    dir: "right"
                })),
                symbol: (0, _viem.hexToString)((0, _viem.trim)(symbol, {
                    dir: "right"
                })),
                ...rest
            };
        }
        throw err;
    }
}
// src/actions/viem/getPublicClient.ts
function getPublicClient({ chainId } = {}) {
    const config2 = getConfig();
    if (chainId) return config2.getPublicClient({
        chainId
    }) || config2.publicClient;
    return config2.publicClient;
}
// src/actions/viem/getWalletClient.ts
async function getWalletClient({ chainId } = {}) {
    const config2 = getConfig();
    const walletClient = await config2.connector?.getWalletClient?.({
        chainId
    }) || null;
    return walletClient;
}
// src/actions/viem/getWebSocketPublicClient.ts
function getWebSocketPublicClient({ chainId } = {}) {
    const config2 = getConfig();
    if (chainId) return config2.getWebSocketPublicClient({
        chainId
    }) || config2.webSocketPublicClient;
    return config2.webSocketPublicClient;
}
// src/actions/viem/watchPublicClient.ts
function watchPublicClient(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(getPublicClient(args));
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return unsubscribe;
}
function watchWalletClient({ chainId }, callback) {
    const config2 = getConfig();
    const handleChange = async ({ chainId: chainId_ })=>{
        if (chainId && chainId_ && chainId !== chainId_) return;
        const walletClient = await getWalletClient({
            chainId
        });
        if (!getConfig().connector) return callback(null);
        return callback(walletClient);
    };
    const unsubscribe = config2.subscribe(({ data, connector })=>({
            account: data?.account,
            chainId: data?.chain?.id,
            connector
        }), handleChange, {
        equalityFn: (0, _shallow.shallow)
    });
    return unsubscribe;
}
// src/actions/viem/watchWebSocketPublicClient.ts
function watchWebSocketPublicClient(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(getWebSocketPublicClient(args));
    const unsubscribe = config2.subscribe(({ webSocketPublicClient })=>webSocketPublicClient, handleChange);
    return unsubscribe;
}
// src/actions/contracts/prepareWriteContract.ts
async function prepareWriteContract({ abi, address, args, chainId, functionName, walletClient: walletClient_, ...config2 }) {
    const publicClient = getPublicClient({
        chainId
    });
    const walletClient = walletClient_ ?? await getWalletClient({
        chainId
    });
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    if (chainId) assertActiveChain({
        chainId
    });
    const { account, accessList, blockNumber, blockTag, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, value } = getCallParameters(config2);
    const { result, request } = await publicClient.simulateContract({
        abi,
        address,
        functionName,
        args,
        account: account || walletClient.account,
        accessList,
        blockNumber,
        blockTag,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
    });
    const minimizedAbi = abi.filter((abiItem)=>"name" in abiItem && abiItem.name === functionName);
    return {
        mode: "prepared",
        request: {
            ...request,
            abi: minimizedAbi,
            chainId
        },
        result
    };
}
function getContract({ address, abi, chainId, walletClient }) {
    const publicClient = getPublicClient({
        chainId
    });
    return (0, _viem.getContract)({
        address,
        abi,
        publicClient,
        walletClient
    });
}
// src/actions/contracts/multicall.ts
async function multicall({ chainId, contracts, blockNumber, blockTag, ...args }) {
    const publicClient = getPublicClient({
        chainId
    });
    if (!publicClient.chains) throw new ConfigChainsNotFound();
    if (chainId && publicClient.chain.id !== chainId) throw new ChainNotConfiguredError({
        chainId
    });
    return publicClient.multicall({
        allowFailure: args.allowFailure ?? true,
        blockNumber,
        blockTag,
        contracts
    });
}
// src/actions/contracts/readContract.ts
async function readContract({ address, account, chainId, abi, args, functionName, blockNumber, blockTag }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.readContract({
        abi,
        address,
        account,
        functionName,
        args,
        blockNumber,
        blockTag
    });
}
async function readContracts({ contracts, blockNumber, blockTag, ...args }) {
    const { allowFailure = true } = args;
    try {
        const publicClient = getPublicClient();
        const contractsByChainId = contracts.reduce((contracts2, contract, index)=>{
            const chainId = contract.chainId ?? publicClient.chain.id;
            return {
                ...contracts2,
                [chainId]: [
                    ...contracts2[chainId] || [],
                    {
                        contract,
                        index
                    }
                ]
            };
        }, {});
        const promises = ()=>Object.entries(contractsByChainId).map(([chainId, contracts2])=>multicall({
                    allowFailure,
                    chainId: parseInt(chainId),
                    contracts: contracts2.map(({ contract })=>contract),
                    blockNumber,
                    blockTag
                }));
        const multicallResults = (await Promise.all(promises())).flat();
        const resultIndexes = Object.values(contractsByChainId).flatMap((contracts2)=>contracts2.map(({ index })=>index));
        return multicallResults.reduce((results, result, index)=>{
            if (results) results[resultIndexes[index]] = result;
            return results;
        }, []);
    } catch (err) {
        if (err instanceof (0, _viem.ContractFunctionExecutionError)) throw err;
        const promises = ()=>contracts.map((contract)=>readContract({
                    ...contract,
                    blockNumber,
                    blockTag
                }));
        if (allowFailure) return (await Promise.allSettled(promises())).map((result)=>{
            if (result.status === "fulfilled") return {
                result: result.value,
                status: "success"
            };
            return {
                error: result.reason,
                result: void 0,
                status: "failure"
            };
        });
        return await Promise.all(promises());
    }
}
function watchContractEvent({ address, abi, chainId, eventName }, callback) {
    let unwatch;
    const watchEvent = async ()=>{
        if (unwatch) unwatch();
        const publicClient = getWebSocketPublicClient({
            chainId
        }) || getPublicClient({
            chainId
        });
        unwatch = publicClient.watchContractEvent({
            address,
            abi,
            eventName,
            onLogs: callback
        });
    };
    watchEvent();
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), watchEvent, {
        equalityFn: (0, _shallow.shallow)
    });
    return ()=>{
        unwatch?.();
        unsubscribe();
    };
}
function watchBlockNumber(args, callback) {
    let unwatch;
    const createListener = (publicClient)=>{
        if (unwatch) unwatch();
        unwatch = publicClient.watchBlockNumber({
            onBlockNumber: callback,
            emitOnBegin: true,
            poll: true
        });
    };
    const publicClient_ = getWebSocketPublicClient({
        chainId: args.chainId
    }) ?? getPublicClient({
        chainId: args.chainId
    });
    if (args.listen) createListener(publicClient_);
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), async ({ publicClient, webSocketPublicClient })=>{
        const publicClient_2 = webSocketPublicClient ?? publicClient;
        if (args.listen && !args.chainId && publicClient_2) createListener(publicClient_2);
    }, {
        equalityFn: (0, _shallow.shallow)
    });
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchMulticall.ts
function watchMulticall(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await multicall(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchReadContract.ts
function watchReadContract(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await readContract(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchReadContracts.ts
function watchReadContracts(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await readContracts(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/writeContract.ts
async function writeContract(config2) {
    const walletClient = await getWalletClient({
        chainId: config2.chainId
    });
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    if (config2.chainId) assertActiveChain({
        chainId: config2.chainId
    });
    let request;
    if (config2.mode === "prepared") request = config2.request;
    else {
        const { chainId: _, mode: __, ...args } = config2;
        const res = await prepareWriteContract(args);
        request = res.request;
    }
    const hash = await walletClient.writeContract({
        ...request,
        chain: null
    });
    return {
        hash
    };
}
// src/actions/accounts/fetchBalance.ts
async function fetchBalance({ address, chainId, formatUnits: unit, token }) {
    const config2 = getConfig();
    const publicClient = getPublicClient({
        chainId
    });
    if (token) {
        const fetchContractBalance = async ({ abi })=>{
            const erc20Config = {
                abi,
                address: token,
                chainId
            };
            const [value2, decimals, symbol] = await readContracts({
                allowFailure: false,
                contracts: [
                    {
                        ...erc20Config,
                        functionName: "balanceOf",
                        args: [
                            address
                        ]
                    },
                    {
                        ...erc20Config,
                        functionName: "decimals"
                    },
                    {
                        ...erc20Config,
                        functionName: "symbol"
                    }
                ]
            });
            return {
                decimals,
                formatted: (0, _viem.formatUnits)(value2 ?? "0", getUnit(unit ?? decimals)),
                symbol,
                value: value2
            };
        };
        try {
            return await fetchContractBalance({
                abi: erc20ABI
            });
        } catch (err) {
            if (err instanceof (0, _viem.ContractFunctionExecutionError)) {
                const { symbol, ...rest } = await fetchContractBalance({
                    abi: erc20ABI_bytes32
                });
                return {
                    symbol: (0, _viem.hexToString)((0, _viem.trim)(symbol, {
                        dir: "right"
                    })),
                    ...rest
                };
            }
            throw err;
        }
    }
    const chains = [
        ...config2.publicClient.chains || [],
        ...config2.chains ?? []
    ];
    const value = await publicClient.getBalance({
        address
    });
    const chain = chains.find((x)=>x.id === publicClient.chain.id);
    return {
        decimals: chain?.nativeCurrency.decimals ?? 18,
        formatted: (0, _viem.formatUnits)(value ?? "0", getUnit(unit ?? 18)),
        symbol: chain?.nativeCurrency.symbol ?? "ETH",
        value
    };
}
// src/actions/accounts/getAccount.ts
function getAccount() {
    const { data, connector, status } = getConfig();
    switch(status){
        case "connected":
            return {
                address: data?.account,
                connector,
                isConnected: true,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case "reconnecting":
            return {
                address: data?.account,
                connector,
                isConnected: !!data?.account,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: true,
                status
            };
        case "connecting":
            return {
                address: data?.account,
                connector,
                isConnected: false,
                isConnecting: true,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case "disconnected":
            return {
                address: void 0,
                connector: void 0,
                isConnected: false,
                isConnecting: false,
                isDisconnected: true,
                isReconnecting: false,
                status
            };
    }
}
// src/actions/accounts/getNetwork.ts
function getNetwork() {
    const config2 = getConfig();
    const chainId = config2.data?.chain?.id;
    const activeChains = config2.chains ?? [];
    const activeChain = [
        ...config2.publicClient?.chains || [],
        ...activeChains
    ].find((x)=>x.id === chainId) ?? {
        id: chainId,
        name: `Chain ${chainId}`,
        network: `${chainId}`,
        nativeCurrency: {
            name: "Ether",
            decimals: 18,
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: [
                    ""
                ]
            },
            public: {
                http: [
                    ""
                ]
            }
        }
    };
    return {
        chain: chainId ? {
            ...activeChain,
            ...config2.data?.chain,
            id: chainId
        } : void 0,
        chains: activeChains
    };
}
// src/actions/accounts/signMessage.ts
async function signMessage(args) {
    const walletClient = await getWalletClient();
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    return await walletClient.signMessage({
        message: args.message
    });
}
// src/actions/accounts/signTypedData.ts
async function signTypedData({ domain, message, primaryType, types }) {
    const walletClient = await getWalletClient();
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    const { chainId } = domain;
    if (chainId) assertActiveChain({
        chainId
    });
    return walletClient.signTypedData({
        message,
        primaryType,
        types,
        domain
    });
}
// src/actions/accounts/switchNetwork.ts
async function switchNetwork({ chainId }) {
    const { connector } = getConfig();
    if (!connector) throw new (0, _connectors.ConnectorNotFoundError)();
    if (!connector.switchChain) throw new SwitchChainNotSupportedError({
        connector
    });
    return connector.switchChain(chainId);
}
function watchAccount(callback, { selector = (x)=>x } = {}) {
    const config2 = getConfig();
    const handleChange = ()=>callback(getAccount());
    const unsubscribe = config2.subscribe(({ data, connector, status })=>selector({
            address: data?.account,
            connector,
            status
        }), handleChange, {
        equalityFn: (0, _shallow.shallow)
    });
    return unsubscribe;
}
function watchNetwork(callback, { selector = (x)=>x } = {}) {
    const config2 = getConfig();
    const handleChange = ()=>callback(getNetwork());
    const unsubscribe = config2.subscribe(({ data, chains })=>selector({
            chainId: data?.chain?.id,
            chains
        }), handleChange, {
        equalityFn: (0, _shallow.shallow)
    });
    return unsubscribe;
}
async function fetchEnsAddress({ chainId, name }) {
    const publicClient = getPublicClient({
        chainId
    });
    const address = await publicClient.getEnsAddress({
        name: (0, _ens.normalize)(name)
    });
    try {
        if (address === "0x0000000000000000000000000000000000000000") return null;
        return address ? (0, _viem.getAddress)(address) : null;
    } catch (_error) {
        return null;
    }
}
async function fetchEnsAvatar({ name, chainId }) {
    const publicClient = getPublicClient({
        chainId
    });
    const avatar = await publicClient.getEnsAvatar({
        name: (0, _ens.normalize)(name)
    });
    return avatar;
}
async function fetchEnsName({ address, chainId }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.getEnsName({
        address: (0, _viem.getAddress)(address)
    });
}
async function fetchEnsResolver({ chainId, name }) {
    const publicClient = getPublicClient({
        chainId
    });
    const resolver = await publicClient.getEnsResolver({
        name: (0, _ens.normalize)(name)
    });
    return resolver;
}
// src/actions/network-status/fetchBlockNumber.ts
async function fetchBlockNumber({ chainId } = {}) {
    const publicClient = getPublicClient({
        chainId
    });
    const blockNumber = await publicClient.getBlockNumber();
    return blockNumber;
}
async function fetchFeeData({ chainId, formatUnits: units = "gwei" } = {}) {
    const publicClient = getPublicClient({
        chainId
    });
    const block = await publicClient.getBlock();
    let gasPrice = null;
    try {
        gasPrice = await publicClient.getGasPrice();
    } catch  {}
    let lastBaseFeePerGas = null;
    let maxFeePerGas = null;
    let maxPriorityFeePerGas = null;
    if (block?.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = (0, _viem.parseGwei)("1");
        maxFeePerGas = block.baseFeePerGas * 2n + maxPriorityFeePerGas;
    }
    const unit = getUnit(units);
    const formatted = {
        gasPrice: gasPrice ? (0, _viem.formatUnits)(gasPrice, unit) : null,
        maxFeePerGas: maxFeePerGas ? (0, _viem.formatUnits)(maxFeePerGas, unit) : null,
        maxPriorityFeePerGas: maxPriorityFeePerGas ? (0, _viem.formatUnits)(maxPriorityFeePerGas, unit) : null
    };
    return {
        lastBaseFeePerGas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        formatted
    };
}
// src/actions/transactions/fetchTransaction.ts
async function fetchTransaction({ chainId, hash }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.getTransaction({
        hash
    });
}
async function prepareSendTransaction({ accessList, account, chainId, data, gas: gas_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to_, value, walletClient: walletClient_ }) {
    const publicClient = getPublicClient({
        chainId
    });
    const walletClient = walletClient_ ?? await getWalletClient({
        chainId
    });
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    if (chainId) assertActiveChain({
        chainId
    });
    const to = (to_ && !(0, _viem.isAddress)(to_) ? await fetchEnsAddress({
        name: to_
    }) : to_) || void 0;
    if (to && !(0, _viem.isAddress)(to)) throw new Error("Invalid address");
    const gas = typeof gas_ === "undefined" ? await publicClient.estimateGas({
        accessList,
        account: walletClient.account,
        data,
        gas: gas_ ?? void 0,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
    }) : gas_ || void 0;
    return {
        accessList,
        account,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mode: "prepared",
        nonce,
        to,
        value,
        ...chainId ? {
            chainId
        } : {}
    };
}
// src/actions/transactions/sendTransaction.ts
async function sendTransaction({ accessList, account, chainId, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mode, nonce, to, value }) {
    const walletClient = await getWalletClient({
        chainId
    });
    if (!walletClient) throw new (0, _connectors.ConnectorNotFoundError)();
    if (chainId) assertActiveChain({
        chainId
    });
    let args;
    if (mode === "prepared") args = {
        account,
        accessList,
        chain: null,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
    };
    else args = await prepareSendTransaction({
        accessList,
        account,
        chainId,
        data,
        gas: gas || null,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
    });
    const hash = await walletClient.sendTransaction({
        ...args,
        chain: null
    });
    return {
        hash
    };
}
async function waitForTransaction({ chainId, confirmations = 1, hash, onReplaced, timeout = 0 }) {
    const publicClient = getPublicClient({
        chainId
    });
    const receipt = await publicClient.waitForTransactionReceipt({
        hash,
        confirmations,
        onReplaced,
        timeout
    });
    if (receipt.status === "reverted") {
        const txn = await publicClient.getTransaction({
            hash: receipt.transactionHash
        });
        const code = await publicClient.call({
            ...txn,
            gasPrice: txn.type !== "eip1559" ? txn.gasPrice : void 0,
            maxFeePerGas: txn.type === "eip1559" ? txn.maxFeePerGas : void 0,
            maxPriorityFeePerGas: txn.type === "eip1559" ? txn.maxPriorityFeePerGas : void 0
        });
        const reason = (0, _viem.hexToString)(`0x${code.substring(138)}`);
        throw new Error(reason);
    }
    return receipt;
}
function watchPendingTransactions(args, callback) {
    let unwatch;
    const createListener = (publicClient)=>{
        if (unwatch) unwatch();
        unwatch = publicClient.watchPendingTransactions({
            onTransactions: callback,
            poll: true
        });
    };
    const publicClient_ = getWebSocketPublicClient({
        chainId: args.chainId
    }) ?? getPublicClient({
        chainId: args.chainId
    });
    createListener(publicClient_);
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), async ({ publicClient, webSocketPublicClient })=>{
        const publicClient_2 = webSocketPublicClient ?? publicClient;
        if (!args.chainId && publicClient_2) createListener(publicClient_2);
    }, {
        equalityFn: (0, _shallow.shallow)
    });
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/utils/assertActiveChain.ts
function assertActiveChain({ chainId }) {
    const { chain: activeChain, chains } = getNetwork();
    const activeChainId = activeChain?.id;
    if (activeChainId && chainId !== activeChainId) throw new ChainMismatchError({
        activeChain: chains.find((x)=>x.id === activeChainId)?.name ?? `Chain ${activeChainId}`,
        targetChain: chains.find((x)=>x.id === chainId)?.name ?? `Chain ${chainId}`
    });
}

},{"./chunk-BVC4KGLQ.js":"4g25c","./chunk-MQXBDTVK.js":"D4WL4","viem":"eKtik","@wagmi/connectors":"cKFnB","zustand/middleware":"jFkBW","zustand/vanilla":"2SLIN","zustand/shallow":"4DTir","viem/ens":"fsqhn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4g25c":[function(require,module,exports) {
// src/connectors/index.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Connector", ()=>(0, _connectors.Connector));
parcelHelpers.export(exports, "InjectedConnector", ()=>(0, _injected.InjectedConnector));
var _connectors = require("@wagmi/connectors");
var _injected = require("@wagmi/connectors/injected");

},{"@wagmi/connectors":"cKFnB","@wagmi/connectors/injected":"54xJw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cKFnB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainNotConfiguredForConnectorError", ()=>(0, _chunkZCAPXGBXJs.ChainNotConfiguredForConnectorError));
parcelHelpers.export(exports, "Connector", ()=>(0, _chunkQYMCVNHTJs.Connector));
parcelHelpers.export(exports, "ConnectorNotFoundError", ()=>(0, _chunkZCAPXGBXJs.ConnectorNotFoundError));
parcelHelpers.export(exports, "normalizeChainId", ()=>(0, _chunkOQILYQDOJs.normalizeChainId));
var _chunkZCAPXGBXJs = require("./chunk-ZCAPXGBX.js");
var _chunkOQILYQDOJs = require("./chunk-OQILYQDO.js");
var _chunkQYMCVNHTJs = require("./chunk-QYMCVNHT.js");

},{"./chunk-ZCAPXGBX.js":"4vCxe","./chunk-OQILYQDO.js":false,"./chunk-QYMCVNHT.js":"h5K6b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vCxe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainNotConfiguredForConnectorError", ()=>ChainNotConfiguredForConnectorError);
parcelHelpers.export(exports, "ConnectorNotFoundError", ()=>ConnectorNotFoundError);
var _chunkQYMCVNHTJs = require("./chunk-QYMCVNHT.js");
// src/errors.ts
var ChainNotConfiguredForConnectorError = class extends Error {
    constructor({ chainId, connectorId }){
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "name", "ChainNotConfiguredForConnectorError");
    }
};
var ConnectorNotFoundError = class extends Error {
    constructor(){
        super(...arguments);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "name", "ConnectorNotFoundError");
        (0, _chunkQYMCVNHTJs.__publicField)(this, "message", "Connector not found");
    }
};

},{"./chunk-QYMCVNHT.js":"h5K6b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5K6b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__publicField", ()=>__publicField);
parcelHelpers.export(exports, "__privateGet", ()=>__privateGet);
parcelHelpers.export(exports, "__privateAdd", ()=>__privateAdd);
parcelHelpers.export(exports, "__privateSet", ()=>__privateSet);
parcelHelpers.export(exports, "__privateMethod", ()=>__privateMethod);
parcelHelpers.export(exports, "Connector", ()=>Connector);
// src/base.ts
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
var _chains = require("viem/chains");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
};
var __privateMethod = (obj, member, method)=>{
    __accessCheck(obj, member, "access private method");
    return method;
};
var Connector = class extends (0, _eventemitter3Default.default) {
    constructor({ chains = [
        (0, _chains.mainnet),
        (0, _chains.goerli)
    ], options }){
        super();
        __publicField(this, "chains");
        __publicField(this, "options");
        __publicField(this, "storage");
        this.chains = chains;
        this.options = options;
    }
    getBlockExplorerUrls(chain) {
        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
        if (blockExplorer) return [
            blockExplorer.url,
            ...Object.values(blockExplorers).map((x)=>x.url)
        ];
    }
    isChainUnsupported(chainId) {
        return !this.chains.some((x)=>x.id === chainId);
    }
    setStorage(storage) {
        this.storage = storage;
    }
};

},{"eventemitter3":"3fnfh","viem/chains":"99Yt9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fnfh":[function(require,module,exports) {
"use strict";
var has = Object.prototype.hasOwnProperty, prefix = "~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"99Yt9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>arbitrum);
parcelHelpers.export(exports, "arbitrumGoerli", ()=>arbitrumGoerli);
parcelHelpers.export(exports, "aurora", ()=>aurora);
parcelHelpers.export(exports, "auroraTestnet", ()=>auroraTestnet);
parcelHelpers.export(exports, "avalanche", ()=>avalanche);
parcelHelpers.export(exports, "avalancheFuji", ()=>avalancheFuji);
parcelHelpers.export(exports, "baseGoerli", ()=>baseGoerli);
parcelHelpers.export(exports, "boba", ()=>boba);
parcelHelpers.export(exports, "bronos", ()=>bronos);
parcelHelpers.export(exports, "bronosTestnet", ()=>bronosTestnet);
parcelHelpers.export(exports, "bsc", ()=>bsc);
parcelHelpers.export(exports, "bscTestnet", ()=>bscTestnet);
parcelHelpers.export(exports, "canto", ()=>canto);
parcelHelpers.export(exports, "celo", ()=>celo);
parcelHelpers.export(exports, "celoAlfajores", ()=>celoAlfajores);
parcelHelpers.export(exports, "celoCannoli", ()=>celoCannoli);
parcelHelpers.export(exports, "cronos", ()=>cronos);
parcelHelpers.export(exports, "crossbell", ()=>crossbell);
parcelHelpers.export(exports, "dfk", ()=>dfk);
parcelHelpers.export(exports, "dogechain", ()=>dogechain);
parcelHelpers.export(exports, "evmos", ()=>evmos);
parcelHelpers.export(exports, "evmosTestnet", ()=>evmosTestnet);
parcelHelpers.export(exports, "fantom", ()=>fantom);
parcelHelpers.export(exports, "fantomTestnet", ()=>fantomTestnet);
parcelHelpers.export(exports, "filecoin", ()=>filecoin);
parcelHelpers.export(exports, "filecoinCalibration", ()=>filecoinCalibration);
parcelHelpers.export(exports, "filecoinHyperspace", ()=>filecoinHyperspace);
parcelHelpers.export(exports, "flare", ()=>flare);
parcelHelpers.export(exports, "flareTestnet", ()=>flareTestnet);
parcelHelpers.export(exports, "foundry", ()=>foundry);
parcelHelpers.export(exports, "iotex", ()=>iotex);
parcelHelpers.export(exports, "iotexTestnet", ()=>iotexTestnet);
parcelHelpers.export(exports, "goerli", ()=>goerli);
parcelHelpers.export(exports, "gnosis", ()=>gnosis);
parcelHelpers.export(exports, "gnosisChiado", ()=>gnosisChiado);
parcelHelpers.export(exports, "haqqMainnet", ()=>haqqMainnet);
parcelHelpers.export(exports, "haqqTestedge2", ()=>haqqTestedge2);
parcelHelpers.export(exports, "hardhat", ()=>hardhat);
parcelHelpers.export(exports, "harmonyOne", ()=>harmonyOne);
parcelHelpers.export(exports, "klaytn", ()=>klaytn);
parcelHelpers.export(exports, "lineaTestnet", ()=>lineaTestnet);
parcelHelpers.export(exports, "localhost", ()=>localhost);
parcelHelpers.export(exports, "mainnet", ()=>mainnet);
parcelHelpers.export(exports, "metis", ()=>metis);
parcelHelpers.export(exports, "metisGoerli", ()=>metisGoerli);
parcelHelpers.export(exports, "moonbaseAlpha", ()=>moonbaseAlpha);
parcelHelpers.export(exports, "moonbeam", ()=>moonbeam);
parcelHelpers.export(exports, "moonriver", ()=>moonriver);
parcelHelpers.export(exports, "nexi", ()=>nexi);
parcelHelpers.export(exports, "okc", ()=>okc);
parcelHelpers.export(exports, "optimism", ()=>optimism);
parcelHelpers.export(exports, "optimismGoerli", ()=>optimismGoerli);
parcelHelpers.export(exports, "polygon", ()=>polygon);
parcelHelpers.export(exports, "polygonMumbai", ()=>polygonMumbai);
parcelHelpers.export(exports, "polygonZkEvm", ()=>polygonZkEvm);
parcelHelpers.export(exports, "polygonZkEvmTestnet", ()=>polygonZkEvmTestnet);
parcelHelpers.export(exports, "pulsechain", ()=>pulsechain);
parcelHelpers.export(exports, "pulsechainV4", ()=>pulsechainV4);
parcelHelpers.export(exports, "scrollTestnet", ()=>scrollTestnet);
parcelHelpers.export(exports, "sepolia", ()=>sepolia);
parcelHelpers.export(exports, "skaleBlockBrawlers", ()=>skaleBlockBrawlers);
parcelHelpers.export(exports, "skaleCalypso", ()=>skaleCalypso);
parcelHelpers.export(exports, "skaleCalypsoTestnet", ()=>skaleCalypsoTestnet);
parcelHelpers.export(exports, "skaleChaosTestnet", ()=>skaleChaosTestnet);
parcelHelpers.export(exports, "skaleCryptoBlades", ()=>skaleCryptoBlades);
parcelHelpers.export(exports, "skaleCryptoColosseum", ()=>skaleCryptoColosseum);
parcelHelpers.export(exports, "skaleEuropa", ()=>skaleEuropa);
parcelHelpers.export(exports, "skaleEuropaTestnet", ()=>skaleEuropaTestnet);
parcelHelpers.export(exports, "skaleExorde", ()=>skaleExorde);
parcelHelpers.export(exports, "skaleHumanProtocol", ()=>skaleHumanProtocol);
parcelHelpers.export(exports, "skaleNebula", ()=>skaleNebula);
parcelHelpers.export(exports, "skaleNebulaTestnet", ()=>skaleNebulaTestnet);
parcelHelpers.export(exports, "skaleRazor", ()=>skaleRazor);
parcelHelpers.export(exports, "skaleTitan", ()=>skaleTitan);
parcelHelpers.export(exports, "skaleTitanTestnet", ()=>skaleTitanTestnet);
parcelHelpers.export(exports, "songbird", ()=>songbird);
parcelHelpers.export(exports, "songbirdTestnet", ()=>songbirdTestnet);
parcelHelpers.export(exports, "shardeumSphinx", ()=>shardeumSphinx);
parcelHelpers.export(exports, "syscoin", ()=>syscoin);
parcelHelpers.export(exports, "taraxa", ()=>taraxa);
parcelHelpers.export(exports, "taraxaTestnet", ()=>taraxaTestnet);
parcelHelpers.export(exports, "telos", ()=>telos);
parcelHelpers.export(exports, "telosTestnet", ()=>telosTestnet);
parcelHelpers.export(exports, "thunderTestnet", ()=>thunderTestnet);
parcelHelpers.export(exports, "wanchain", ()=>wanchain);
parcelHelpers.export(exports, "wanchainTestnet", ()=>wanchainTestnet);
parcelHelpers.export(exports, "xdc", ()=>xdc);
parcelHelpers.export(exports, "xdcTestnet", ()=>xdcTestnet);
parcelHelpers.export(exports, "zhejiang", ()=>zhejiang);
parcelHelpers.export(exports, "zkSync", ()=>zkSync);
parcelHelpers.export(exports, "zkSyncTestnet", ()=>zkSyncTestnet);
parcelHelpers.export(exports, "zora", ()=>zora);
parcelHelpers.export(exports, "zoraTestnet", ()=>zoraTestnet);
var _chains = require("@wagmi/chains");
var _chainJs = require("../utils/chain.js");
var _celoJs = require("./formatters/celo.js");
var _optimismJs = require("./formatters/optimism.js");
const arbitrum = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.arbitrum);
const arbitrumGoerli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.arbitrumGoerli);
const aurora = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.aurora);
const auroraTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.auroraTestnet);
const avalanche = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.avalanche);
const avalancheFuji = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.avalancheFuji);
const baseGoerli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.baseGoerli);
const boba = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.boba);
const bronos = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.bronos);
const bronosTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.bronosTestnet);
const bsc = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.bsc);
const bscTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.bscTestnet);
const canto = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.canto);
const celo = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.celo, {
    formatters: (0, _celoJs.celoFormatters)
});
const celoAlfajores = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.celoAlfajores, {
    formatters: (0, _celoJs.celoFormatters)
});
const celoCannoli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.celoCannoli, {
    formatters: (0, _celoJs.celoFormatters)
});
const cronos = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.cronos);
const crossbell = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.crossbell);
const dfk = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.dfk);
const dogechain = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.dogechain);
const evmos = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.evmos);
const evmosTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.evmosTestnet);
const fantom = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.fantom);
const fantomTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.fantomTestnet);
const filecoin = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.filecoin);
const filecoinCalibration = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.filecoinCalibration);
const filecoinHyperspace = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.filecoinHyperspace);
const flare = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.flare);
const flareTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.flareTestnet);
const foundry = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.foundry);
const iotex = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.iotex);
const iotexTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.iotexTestnet);
const goerli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.goerli);
const gnosis = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.gnosis);
const gnosisChiado = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.gnosisChiado);
const haqqMainnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.haqqMainnet);
const haqqTestedge2 = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.haqqTestedge2);
const hardhat = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.hardhat);
const harmonyOne = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.harmonyOne);
const klaytn = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.klaytn);
const lineaTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.lineaTestnet);
const localhost = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.localhost);
const mainnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.mainnet);
const metis = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.metis);
const metisGoerli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.metisGoerli);
const moonbaseAlpha = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.moonbaseAlpha);
const moonbeam = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.moonbeam);
const moonriver = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.moonriver);
const nexi = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.nexi);
const okc = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.okc);
const optimism = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.optimism, {
    formatters: (0, _optimismJs.optimismFormatters)
});
const optimismGoerli = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.optimismGoerli, {
    formatters: (0, _optimismJs.optimismFormatters)
});
const polygon = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.polygon);
const polygonMumbai = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.polygonMumbai);
const polygonZkEvm = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.polygonZkEvm);
const polygonZkEvmTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.polygonZkEvmTestnet);
const pulsechain = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.pulsechain);
const pulsechainV4 = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.pulsechainV4);
const scrollTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.scrollTestnet);
const sepolia = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.sepolia);
const skaleBlockBrawlers = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleBlockBrawlers);
const skaleCalypso = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleCalypso);
const skaleCalypsoTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleCalypsoTestnet);
const skaleChaosTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleChaosTestnet);
const skaleCryptoBlades = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleCryptoBlades);
const skaleCryptoColosseum = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleCryptoColosseum);
const skaleEuropa = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleEuropa);
const skaleEuropaTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleEuropaTestnet);
const skaleExorde = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleExorde);
const skaleHumanProtocol = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleHumanProtocol);
const skaleNebula = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleNebula);
const skaleNebulaTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleNebulaTestnet);
const skaleRazor = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleRazor);
const skaleTitan = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleTitan);
const skaleTitanTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.skaleTitanTestnet);
const songbird = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.songbird);
const songbirdTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.songbirdTestnet);
const shardeumSphinx = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.shardeumSphinx);
const syscoin = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.syscoin);
const taraxa = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.taraxa);
const taraxaTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.taraxaTestnet);
const telos = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.telos);
const telosTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.telosTestnet);
const thunderTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.thunderTestnet);
const wanchain = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.wanchain);
const wanchainTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.wanchainTestnet);
const xdc = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.xdc);
const xdcTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.xdcTestnet);
const zhejiang = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.zhejiang);
const zkSync = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.zkSync);
const zkSyncTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.zkSyncTestnet);
const zora = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.zora);
const zoraTestnet = /*#__PURE__*/ (0, _chainJs.defineChain)(_chains.zoraTestnet);

},{"@wagmi/chains":"cegBf","../utils/chain.js":"cruNy","./formatters/celo.js":"9ZyMH","./formatters/optimism.js":"eTCdU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cegBf":[function(require,module,exports) {
// src/arbitrum.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>arbitrum);
parcelHelpers.export(exports, "arbitrumGoerli", ()=>arbitrumGoerli);
parcelHelpers.export(exports, "arbitrumNova", ()=>arbitrumNova);
parcelHelpers.export(exports, "aurora", ()=>aurora);
parcelHelpers.export(exports, "auroraTestnet", ()=>auroraTestnet);
parcelHelpers.export(exports, "avalanche", ()=>avalanche);
parcelHelpers.export(exports, "avalancheFuji", ()=>avalancheFuji);
parcelHelpers.export(exports, "baseGoerli", ()=>baseGoerli);
parcelHelpers.export(exports, "bearNetworkChainMainnet", ()=>bearNetworkChainMainnet);
parcelHelpers.export(exports, "bearNetworkChainTestnet", ()=>bearNetworkChainTestnet);
parcelHelpers.export(exports, "boba", ()=>boba);
parcelHelpers.export(exports, "bronos", ()=>bronos);
parcelHelpers.export(exports, "bronosTestnet", ()=>bronosTestnet);
parcelHelpers.export(exports, "bsc", ()=>bsc);
parcelHelpers.export(exports, "bscTestnet", ()=>bscTestnet);
parcelHelpers.export(exports, "canto", ()=>canto);
parcelHelpers.export(exports, "celo", ()=>celo);
parcelHelpers.export(exports, "celoAlfajores", ()=>celoAlfajores);
parcelHelpers.export(exports, "celoCannoli", ()=>celoCannoli);
parcelHelpers.export(exports, "confluxESpace", ()=>confluxESpace);
parcelHelpers.export(exports, "cronos", ()=>cronos);
parcelHelpers.export(exports, "cronosTestnet", ()=>cronosTestnet);
parcelHelpers.export(exports, "crossbell", ()=>crossbell);
parcelHelpers.export(exports, "dfk", ()=>dfk);
parcelHelpers.export(exports, "dogechain", ()=>dogechain);
parcelHelpers.export(exports, "edgeware", ()=>edgeware);
parcelHelpers.export(exports, "edgewareTestnet", ()=>edgewareTestnet);
parcelHelpers.export(exports, "ekta", ()=>ekta);
parcelHelpers.export(exports, "ektaTestnet", ()=>ektaTestnet);
parcelHelpers.export(exports, "evmos", ()=>evmos);
parcelHelpers.export(exports, "evmosTestnet", ()=>evmosTestnet);
parcelHelpers.export(exports, "fantom", ()=>fantom);
parcelHelpers.export(exports, "fantomTestnet", ()=>fantomTestnet);
parcelHelpers.export(exports, "fibo", ()=>fibo);
parcelHelpers.export(exports, "filecoin", ()=>filecoin);
parcelHelpers.export(exports, "filecoinCalibration", ()=>filecoinCalibration);
parcelHelpers.export(exports, "filecoinHyperspace", ()=>filecoinHyperspace);
parcelHelpers.export(exports, "flare", ()=>flare);
parcelHelpers.export(exports, "flareTestnet", ()=>flareTestnet);
parcelHelpers.export(exports, "foundry", ()=>foundry);
parcelHelpers.export(exports, "fuse", ()=>fuse);
parcelHelpers.export(exports, "gnosis", ()=>gnosis);
parcelHelpers.export(exports, "gnosisChiado", ()=>gnosisChiado);
parcelHelpers.export(exports, "goerli", ()=>goerli);
parcelHelpers.export(exports, "haqqMainnet", ()=>haqqMainnet);
parcelHelpers.export(exports, "haqqTestedge2", ()=>haqqTestedge2);
parcelHelpers.export(exports, "hardhat", ()=>hardhat);
parcelHelpers.export(exports, "harmonyOne", ()=>harmonyOne);
parcelHelpers.export(exports, "iotex", ()=>iotex);
parcelHelpers.export(exports, "iotexTestnet", ()=>iotexTestnet);
parcelHelpers.export(exports, "klaytn", ()=>klaytn);
parcelHelpers.export(exports, "lineaTestnet", ()=>lineaTestnet);
parcelHelpers.export(exports, "localhost", ()=>localhost);
parcelHelpers.export(exports, "mainnet", ()=>mainnet);
parcelHelpers.export(exports, "metis", ()=>metis);
parcelHelpers.export(exports, "metisGoerli", ()=>metisGoerli);
parcelHelpers.export(exports, "moonbaseAlpha", ()=>moonbaseAlpha);
parcelHelpers.export(exports, "moonbeam", ()=>moonbeam);
parcelHelpers.export(exports, "moonriver", ()=>moonriver);
parcelHelpers.export(exports, "neonDevnet", ()=>neonDevnet);
parcelHelpers.export(exports, "nexi", ()=>nexi);
parcelHelpers.export(exports, "oasys", ()=>oasys);
parcelHelpers.export(exports, "okc", ()=>okc);
parcelHelpers.export(exports, "optimism", ()=>optimism);
parcelHelpers.export(exports, "optimismGoerli", ()=>optimismGoerli);
parcelHelpers.export(exports, "polygon", ()=>polygon);
parcelHelpers.export(exports, "polygonMumbai", ()=>polygonMumbai);
parcelHelpers.export(exports, "polygonZkEvm", ()=>polygonZkEvm);
parcelHelpers.export(exports, "polygonZkEvmTestnet", ()=>polygonZkEvmTestnet);
parcelHelpers.export(exports, "pulsechain", ()=>pulsechain);
parcelHelpers.export(exports, "pulsechainV4", ()=>pulsechainV4);
parcelHelpers.export(exports, "scrollTestnet", ()=>scrollTestnet);
parcelHelpers.export(exports, "sepolia", ()=>sepolia);
parcelHelpers.export(exports, "shardeumSphinx", ()=>shardeumSphinx);
parcelHelpers.export(exports, "skaleBlockBrawlers", ()=>skaleBlockBrawlers);
parcelHelpers.export(exports, "skaleCalypso", ()=>skaleCalypso);
parcelHelpers.export(exports, "skaleCalypsoTestnet", ()=>skaleCalypsoTestnet);
parcelHelpers.export(exports, "skaleChaosTestnet", ()=>skaleChaosTestnet);
parcelHelpers.export(exports, "skaleCryptoBlades", ()=>skaleCryptoBlades);
parcelHelpers.export(exports, "skaleCryptoColosseum", ()=>skaleCryptoColosseum);
parcelHelpers.export(exports, "skaleEuropa", ()=>skaleEuropa);
parcelHelpers.export(exports, "skaleEuropaTestnet", ()=>skaleEuropaTestnet);
parcelHelpers.export(exports, "skaleExorde", ()=>skaleExorde);
parcelHelpers.export(exports, "skaleHumanProtocol", ()=>skaleHumanProtocol);
parcelHelpers.export(exports, "skaleNebula", ()=>skaleNebula);
parcelHelpers.export(exports, "skaleNebulaTestnet", ()=>skaleNebulaTestnet);
parcelHelpers.export(exports, "skaleRazor", ()=>skaleRazor);
parcelHelpers.export(exports, "skaleTitan", ()=>skaleTitan);
parcelHelpers.export(exports, "skaleTitanTestnet", ()=>skaleTitanTestnet);
parcelHelpers.export(exports, "songbird", ()=>songbird);
parcelHelpers.export(exports, "songbirdTestnet", ()=>songbirdTestnet);
parcelHelpers.export(exports, "syscoin", ()=>syscoin);
parcelHelpers.export(exports, "taraxa", ()=>taraxa);
parcelHelpers.export(exports, "taraxaTestnet", ()=>taraxaTestnet);
parcelHelpers.export(exports, "telos", ()=>telos);
parcelHelpers.export(exports, "telosTestnet", ()=>telosTestnet);
parcelHelpers.export(exports, "thunderTestnet", ()=>thunderTestnet);
parcelHelpers.export(exports, "wanchain", ()=>wanchain);
parcelHelpers.export(exports, "wanchainTestnet", ()=>wanchainTestnet);
parcelHelpers.export(exports, "xdc", ()=>xdc);
parcelHelpers.export(exports, "xdcTestnet", ()=>xdcTestnet);
parcelHelpers.export(exports, "zhejiang", ()=>zhejiang);
parcelHelpers.export(exports, "zkSync", ()=>zkSync);
parcelHelpers.export(exports, "zkSyncTestnet", ()=>zkSyncTestnet);
parcelHelpers.export(exports, "zora", ()=>zora);
parcelHelpers.export(exports, "zoraTestnet", ()=>zoraTestnet);
var arbitrum = {
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://arb-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://arb-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://arbitrum-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://arbitrum-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        },
        default: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7654707
        }
    }
};
// src/arbitrumGoerli.ts
var arbitrumGoerli = {
    id: 421613,
    name: "Arbitrum Goerli",
    network: "arbitrum-goerli",
    nativeCurrency: {
        name: "Arbitrum Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://arb-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://arb-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://arbitrum-goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://arbitrum-goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://goerli-rollup.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://goerli-rollup.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://goerli.arbiscan.io/"
        },
        default: {
            name: "Arbiscan",
            url: "https://goerli.arbiscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 88114
        }
    },
    testnet: true
};
// src/arbitrumNova.ts
var arbitrumNova = {
    id: 42170,
    name: "Arbitrum Nova",
    network: "arbitrum-nova",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        blast: {
            http: [
                "https://arbitrum-nova.public.blastapi.io"
            ],
            webSocket: [
                "wss://arbitrum-nova.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://nova.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://nova.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://nova.arbiscan.io"
        },
        blockScout: {
            name: "BlockScout",
            url: "https://nova-explorer.arbitrum.io/"
        },
        default: {
            name: "Arbiscan",
            url: "https://nova.arbiscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1746963
        }
    }
};
// src/aurora.ts
var aurora = {
    id: 1313161554,
    name: "Aurora",
    network: "aurora",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        infura: {
            http: [
                "https://aurora-mainnet.infura.io/v3"
            ]
        },
        default: {
            http: [
                "https://mainnet.aurora.dev"
            ]
        },
        public: {
            http: [
                "https://mainnet.aurora.dev"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Aurorascan",
            url: "https://aurorascan.dev"
        },
        default: {
            name: "Aurorascan",
            url: "https://aurorascan.dev"
        }
    }
};
// src/auroraTestnet.ts
var auroraTestnet = {
    id: 1313161555,
    name: "Aurora Testnet",
    network: "aurora-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        infura: {
            http: [
                "https://aurora-testnet.infura.io/v3"
            ]
        },
        default: {
            http: [
                "https://testnet.aurora.dev"
            ]
        },
        public: {
            http: [
                "https://testnet.aurora.dev"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Aurorascan",
            url: "https://testnet.aurorascan.dev"
        },
        default: {
            name: "Aurorascan",
            url: "https://testnet.aurorascan.dev"
        }
    },
    testnet: true
};
// src/avalanche.ts
var avalanche = {
    id: 43114,
    name: "Avalanche",
    network: "avalanche",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 11907934
        }
    }
};
// src/avalancheFuji.ts
var avalancheFuji = {
    id: 43113,
    name: "Avalanche Fuji",
    network: "avalanche-fuji",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7096959
        }
    },
    testnet: true
};
// src/baseGoerli.ts
var baseGoerli = {
    id: 84531,
    network: "base-goerli",
    name: "Base Goerli",
    nativeCurrency: {
        name: "Base Goerli",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://goerli.base.org"
            ]
        },
        public: {
            http: [
                "https://goerli.base.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Basescan",
            url: "https://goerli.basescan.org"
        },
        default: {
            name: "Basescan",
            url: "https://goerli.basescan.org"
        }
    },
    testnet: true
};
// src/bearNetworkChainMainnet.ts
var bearNetworkChainMainnet = {
    id: 641230,
    name: "Bear Network Chain Mainnet",
    network: "BearNetworkChainMainnet",
    nativeCurrency: {
        decimals: 18,
        name: "BearNetworkChain",
        symbol: "BRNKC"
    },
    rpcUrls: {
        public: {
            http: [
                "https://brnkc-mainnet.bearnetwork.net"
            ]
        },
        default: {
            http: [
                "https://brnkc-mainnet.bearnetwork.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BrnkScan",
            url: "https://brnkscan.bearnetwork.net"
        }
    }
};
// src/bearNetworkChainTestnet.ts
var bearNetworkChainTestnet = {
    id: 751230,
    name: "Bear Network Chain Testnet",
    network: "BearNetworkChainTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "tBRNKC",
        symbol: "tBRNKC"
    },
    rpcUrls: {
        public: {
            http: [
                "https://brnkc-test.bearnetwork.net"
            ]
        },
        default: {
            http: [
                "https://brnkc-test.bearnetwork.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BrnkTestScan",
            url: "https://brnktest-scan.bearnetwork.net"
        }
    },
    testnet: true
};
// src/boba.ts
var boba = {
    id: 288,
    name: "Boba Network",
    network: "boba",
    nativeCurrency: {
        decimals: 18,
        name: "Boba",
        symbol: "BOBA"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.boba.network"
            ]
        },
        public: {
            http: [
                "https://mainnet.boba.network"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BOBAScan",
            url: "https://bobascan.com"
        },
        default: {
            name: "BOBAScan",
            url: "https://bobascan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 446859
        }
    }
};
// src/bronos.ts
var bronos = {
    id: 1039,
    name: "Bronos",
    network: "bronos",
    nativeCurrency: {
        decimals: 18,
        name: "BRO",
        symbol: "BRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm.bronos.org"
            ]
        },
        public: {
            http: [
                "https://evm.bronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BronoScan",
            url: "https://broscan.bronos.org"
        }
    }
};
// src/bronosTestnet.ts
var bronosTestnet = {
    id: 1038,
    name: "Bronos Testnet",
    network: "bronos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Bronos Coin",
        symbol: "tBRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm-testnet.bronos.org"
            ]
        },
        public: {
            http: [
                "https://evm-testnet.bronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BronoScan",
            url: "https://tbroscan.bronos.org"
        }
    },
    testnet: true
};
// src/bsc.ts
var bsc = {
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.ankr.com/bsc"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/bsc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BscScan",
            url: "https://bscscan.com"
        },
        default: {
            name: "BscScan",
            url: "https://bscscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 15921452
        }
    }
};
// src/bscTestnet.ts
var bscTestnet = {
    id: 97,
    name: "Binance Smart Chain Testnet",
    network: "bsc-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "tBNB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://data-seed-prebsc-1-s1.binance.org:8545"
            ]
        },
        public: {
            http: [
                "https://data-seed-prebsc-1-s1.binance.org:8545"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BscScan",
            url: "https://testnet.bscscan.com"
        },
        default: {
            name: "BscScan",
            url: "https://testnet.bscscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 17422483
        }
    },
    testnet: true
};
// src/canto.ts
var canto = {
    id: 7700,
    name: "Canto",
    network: "canto",
    nativeCurrency: {
        decimals: 18,
        name: "Canto",
        symbol: "CANTO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://canto.slingshot.finance"
            ]
        },
        public: {
            http: [
                "https://canto.slingshot.finance"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Canto EVM Explorer (Blockscout)",
            url: "https://evm.explorer.canto.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 2905789
        }
    }
};
// src/celo.ts
var celo = {
    id: 42220,
    name: "Celo",
    network: "celo",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://forno.celo.org"
            ]
        },
        infura: {
            http: [
                "https://celo-mainnet.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://forno.celo.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/mainnet"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://celoscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 13112599
        }
    },
    testnet: false
};
// src/celoAlfajores.ts
var celoAlfajores = {
    id: 44787,
    name: "Alfajores",
    network: "celo-alfajores",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "A-CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        },
        infura: {
            http: [
                "https://celo-alfajores.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/alfajores"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://alfajores.celoscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 14569001
        }
    },
    testnet: true
};
// src/celoCannoli.ts
var celoCannoli = {
    id: 17323,
    name: "Cannoli",
    network: "celo-cannoli",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "C-CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://forno.cannoli.celo-testnet.org"
            ]
        },
        public: {
            http: [
                "https://forno.cannoli.celo-testnet.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/cannoli"
        }
    },
    contracts: {
        multicall3: {
            address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
            blockCreated: 87429
        }
    },
    testnet: true
};
// src/confluxESpace.ts
var confluxESpace = {
    id: 1030,
    name: "Conflux eSpace",
    network: "cfx-espace",
    nativeCurrency: {
        name: "Conflux",
        symbol: "CFX",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm.confluxrpc.org"
            ]
        },
        public: {
            http: [
                "https://evm.confluxrpc.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "ConfluxScan",
            url: "https://evm.confluxscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
            blockCreated: 68602935
        }
    }
};
// src/cronos.ts
var cronos = {
    id: 25,
    name: "Cronos",
    network: "cronos",
    nativeCurrency: {
        decimals: 18,
        name: "Cronos",
        symbol: "CRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://node.croswap.com/rpc"
            ]
        },
        public: {
            http: [
                "https://node.croswap.com/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "CronosScan",
            url: "https://cronoscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1963112
        }
    }
};
// src/cronosTestnet.ts
var cronosTestnet = {
    id: 338,
    name: "Cronos Testnet",
    network: "cronos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "CRO",
        symbol: "tCRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm-t3.cronos.org"
            ]
        },
        public: {
            http: [
                "https://evm-t3.cronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Cronos Explorer",
            url: "https://cronos.org/explorer/testnet3"
        }
    },
    testnet: true
};
// src/crossbell.ts
var crossbell = {
    id: 3737,
    network: "crossbell",
    name: "Crossbell",
    nativeCurrency: {
        decimals: 18,
        name: "CSB",
        symbol: "CSB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.crossbell.io"
            ]
        },
        public: {
            http: [
                "https://rpc.crossbell.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "CrossScan",
            url: "https://scan.crossbell.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
            blockCreated: 23499787
        }
    }
};
// src/dfk.ts
var dfk = {
    id: 53935,
    name: "DFK Chain",
    network: "dfk",
    nativeCurrency: {
        decimals: 18,
        name: "Jewel",
        symbol: "JEWEL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"
            ]
        },
        public: {
            http: [
                "https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "DFKSubnetScan",
            url: "https://subnets.avax.network/defi-kingdoms"
        },
        default: {
            name: "DFKSubnetScan",
            url: "https://subnets.avax.network/defi-kingdoms"
        }
    }
};
// src/dogechain.ts
var dogechain = {
    id: 2e3,
    name: "Dogechain",
    network: "dogechain",
    nativeCurrency: {
        decimals: 18,
        name: "Dogechain",
        symbol: "DC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.dogechain.dog"
            ]
        },
        public: {
            http: [
                "https://rpc.dogechain.dog"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "DogeChainExplorer",
            url: "https://explorer.dogechain.dog"
        },
        default: {
            name: "DogeChainExplorer",
            url: "https://explorer.dogechain.dog"
        }
    }
};
// src/edgeware.ts
var edgeware = {
    id: 2021,
    name: "Edgeware EdgeEVM Mainnet",
    network: "edgeware",
    nativeCurrency: {
        decimals: 18,
        name: "Edgeware",
        symbol: "EDG"
    },
    rpcUrls: {
        default: {
            http: [
                "https://edgeware-evm.jelliedowl.net"
            ]
        },
        public: {
            http: [
                "https://edgeware-evm.jelliedowl.net"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Edgscan by Bharathcoorg",
            url: "https://edgscan.live"
        },
        default: {
            name: "Edgscan by Bharathcoorg",
            url: "https://edgscan.live"
        }
    },
    contracts: {
        multicall3: {
            address: "0xDDF47eEB4e5FF4AA60e063E0Ec4f7C35B47Ed445",
            blockCreated: 17126780
        }
    }
};
// src/edgewareTestnet.ts
var edgewareTestnet = {
    id: 2022,
    name: "Beresheet BereEVM Testnet",
    network: "edgewareTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "Testnet EDG",
        symbol: "tEDG"
    },
    rpcUrls: {
        default: {
            http: [
                "https://beresheet-evm.jelliedowl.net"
            ]
        },
        public: {
            http: [
                "https://beresheet-evm.jelliedowl.net"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Edgscan by Bharathcoorg",
            url: "https://testnet.edgscan.live"
        },
        default: {
            name: "Edgscan by Bharathcoorg",
            url: "https://testnet.edgscan.live"
        }
    }
};
// src/evmos.ts
var evmos = {
    id: 9001,
    name: "Evmos",
    network: "evmos",
    nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://eth.bd.evmos.org:8545"
            ]
        },
        public: {
            http: [
                "https://eth.bd.evmos.org:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Evmos Block Explorer",
            url: "https://escan.live"
        }
    }
};
// src/evmosTestnet.ts
var evmosTestnet = {
    id: 9e3,
    name: "Evmos Testnet",
    network: "evmos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://eth.bd.evmos.dev:8545"
            ]
        },
        public: {
            http: [
                "https://eth.bd.evmos.dev:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Evmos Testnet Block Explorer",
            url: "https://evm.evmos.dev/"
        }
    }
};
// src/ekta.ts
var ekta = {
    id: 1994,
    name: "Ekta",
    network: "ekta",
    nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
    },
    rpcUrls: {
        public: {
            http: [
                "https://main.ekta.io"
            ]
        },
        default: {
            http: [
                "https://main.ekta.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Ektascan",
            url: "https://ektascan.io"
        }
    }
};
// src/ektaTestnet.ts
var ektaTestnet = {
    id: 1004,
    name: "Ekta Testnet",
    network: "ekta-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
    },
    rpcUrls: {
        public: {
            http: [
                "https://test.ekta.io:8545"
            ]
        },
        default: {
            http: [
                "https://test.ekta.io:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Test Ektascan",
            url: "https://test.ektascan.io"
        }
    },
    testnet: true
};
// src/fantom.ts
var fantom = {
    id: 250,
    name: "Fantom",
    network: "fantom",
    nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.ankr.com/fantom"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/fantom"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "FTMScan",
            url: "https://ftmscan.com"
        },
        default: {
            name: "FTMScan",
            url: "https://ftmscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 33001987
        }
    }
};
// src/fantomTestnet.ts
var fantomTestnet = {
    id: 4002,
    name: "Fantom Testnet",
    network: "fantom-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.testnet.fantom.network"
            ]
        },
        public: {
            http: [
                "https://rpc.testnet.fantom.network"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "FTMScan",
            url: "https://testnet.ftmscan.com"
        },
        default: {
            name: "FTMScan",
            url: "https://testnet.ftmscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 8328688
        }
    }
};
// src/fibo.ts
var fibo = {
    id: 12306,
    name: "Fibo Chain",
    network: "fibochain",
    nativeCurrency: {
        decimals: 18,
        name: "fibo",
        symbol: "FIBO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://network.hzroc.art"
            ]
        },
        public: {
            http: [
                "https://network.hzroc.art"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "FiboScan",
            url: "https://scan.fibochain.org"
        }
    }
};
// src/filecoin.ts
var filecoin = {
    id: 314,
    name: "Filecoin Mainnet",
    network: "filecoin-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filfox",
            url: "https://filfox.info/en"
        },
        filscan: {
            name: "Filscan",
            url: "https://filscan.io"
        },
        filscout: {
            name: "Filscout",
            url: "https://filscout.io/en"
        },
        glif: {
            name: "Glif",
            url: "https://explorer.glif.io"
        }
    }
};
// src/filecoinCalibration.ts
var filecoinCalibration = {
    id: 314159,
    name: "Filecoin Calibration",
    network: "filecoin-calibration",
    nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filscan",
            url: "https://calibration.filscan.io"
        }
    }
};
// src/filecoinHyperspace.ts
var filecoinHyperspace = {
    id: 3141,
    name: "Filecoin Hyperspace",
    network: "filecoin-hyperspace",
    nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.hyperspace.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.hyperspace.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filfox",
            url: "https://hyperspace.filfox.info/en"
        },
        filscan: {
            name: "Filscan",
            url: "https://hyperspace.filscan.io"
        }
    }
};
// src/flare.ts
var flare = {
    id: 14,
    name: "Flare Mainnet",
    network: "flare-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "flare",
        symbol: "FLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://flare-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://flare-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Flare Explorer",
            url: "https://flare-explorer.flare.network"
        }
    }
};
// src/flareTestnet.ts
var flareTestnet = {
    id: 114,
    name: "Coston2",
    network: "coston2",
    nativeCurrency: {
        decimals: 18,
        name: "coston2flare",
        symbol: "C2FLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://coston2-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://coston2-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Coston2 Explorer",
            url: "https://coston2-explorer.flare.network"
        }
    },
    testnet: true
};
// src/foundry.ts
var foundry = {
    id: 31337,
    name: "Foundry",
    network: "foundry",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ],
            webSocket: [
                "ws://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ],
            webSocket: [
                "ws://127.0.0.1:8545"
            ]
        }
    }
};
// src/fuse.ts
var fuse = {
    id: 122,
    name: "Fuse",
    network: "fuse",
    nativeCurrency: {
        name: "Fuse",
        symbol: "FUSE",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.fuse.io"
            ]
        },
        public: {
            http: [
                "https://fuse-mainnet.chainstacklabs.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Fuse Explorer",
            url: "https://explorer.fuse.io"
        }
    }
};
// src/iotex.ts
var iotex = {
    id: 4689,
    name: "IoTeX",
    network: "iotex",
    nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://babel-api.mainnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.mainnet.iotex.io"
            ]
        },
        public: {
            http: [
                "https://babel-api.mainnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.mainnet.iotex.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "IoTeXScan",
            url: "https://iotexscan.io"
        }
    }
};
// src/iotexTestnet.ts
var iotexTestnet = {
    id: 4690,
    name: "IoTeX Testnet",
    network: "iotex-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://babel-api.testnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.testnet.iotex.io"
            ]
        },
        public: {
            http: [
                "https://babel-api.testnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.testnet.iotex.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "IoTeXScan",
            url: "https://testnet.iotexscan.io"
        }
    }
};
// src/goerli.ts
var goerli = {
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: {
        name: "Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.ankr.com/eth_goerli"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/eth_goerli"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0x56522D00C410a43BFfDF00a9A569489297385790",
            blockCreated: 8765204
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
        }
    },
    testnet: true
};
// src/gnosis.ts
var gnosis = {
    id: 100,
    name: "Gnosis",
    network: "gnosis",
    nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.gnosischain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.gnosischain.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Gnosisscan",
            url: "https://gnosisscan.io/"
        },
        default: {
            name: "Gnosis Chain Explorer",
            url: "https://blockscout.com/xdai/mainnet/"
        }
    }
};
// src/gnosisChiado.ts
var gnosisChiado = {
    id: 10200,
    name: "Gnosis Chiado",
    network: "chiado",
    nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.chiadochain.net"
            ]
        },
        public: {
            http: [
                "https://rpc.chiadochain.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://blockscout.chiadochain.net"
        }
    }
};
// src/hardhat.ts
var hardhat = {
    id: 31337,
    name: "Hardhat",
    network: "hardhat",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ]
        }
    }
};
// src/harmonyOne.ts
var harmonyOne = {
    id: 16666e5,
    name: "Harmony One",
    network: "harmony",
    nativeCurrency: {
        name: "Harmony",
        symbol: "ONE",
        decimals: 18
    },
    rpcUrls: {
        public: {
            http: [
                "https://rpc.ankr.com/harmony"
            ]
        },
        default: {
            http: [
                "https://rpc.ankr.com/harmony"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Harmony Explorer",
            url: "https://explorer.harmony.one"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 24185753
        }
    }
};
// src/haqqMainnet.ts
var haqqMainnet = {
    id: 11235,
    name: "HAQQ Mainnet",
    network: "haqq-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.eth.haqq.network"
            ]
        },
        public: {
            http: [
                "https://rpc.eth.haqq.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "HAQQ Explorer",
            url: "https://explorer.haqq.network"
        }
    }
};
// src/haqqTestedge2.ts
var haqqTestedge2 = {
    id: 54211,
    name: "HAQQ Testedge 2",
    network: "haqq-testedge-2",
    nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLMT"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.eth.testedge2.haqq.network"
            ]
        },
        public: {
            http: [
                "https://rpc.eth.testedge2.haqq.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "HAQQ Explorer",
            url: "https://explorer.testedge2.haqq.network"
        }
    }
};
// src/klaytn.ts
var klaytn = {
    id: 8217,
    name: "Klaytn",
    network: "klaytn",
    nativeCurrency: {
        decimals: 18,
        name: "Klaytn",
        symbol: "KLAY"
    },
    rpcUrls: {
        default: {
            http: [
                "https://cypress.fautor.app/archive"
            ]
        },
        public: {
            http: [
                "https://cypress.fautor.app/archive"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "KlaytnScope",
            url: "https://scope.klaytn.com"
        },
        default: {
            name: "KlaytnScope",
            url: "https://scope.klaytn.com"
        }
    }
};
// src/lineaTestnet.ts
var lineaTestnet = {
    id: 59140,
    name: "Linea Goerli Testnet",
    network: "linea-testnet",
    nativeCurrency: {
        name: "Linea Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        infura: {
            http: [
                "https://consensys-zkevm-goerli-prealpha.infura.io/v3"
            ],
            webSocket: [
                "wss://consensys-zkevm-goerli-prealpha.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        },
        public: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BlockScout",
            url: "https://explorer.goerli.linea.build"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 498623
        }
    },
    testnet: true
};
// src/localhost.ts
var localhost = {
    id: 1337,
    name: "Localhost",
    network: "localhost",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ]
        }
    }
};
// src/mainnet.ts
var mainnet = {
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://cloudflare-eth.com"
            ]
        },
        public: {
            http: [
                "https://cloudflare-eth.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
            blockCreated: 16966585
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/metis.ts
var metis = {
    id: 1088,
    name: "Metis",
    network: "andromeda",
    nativeCurrency: {
        decimals: 18,
        name: "Metis",
        symbol: "METIS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://andromeda.metis.io/?owner=1088"
            ]
        },
        public: {
            http: [
                "https://andromeda.metis.io/?owner=1088"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Andromeda Explorer",
            url: "https://andromeda-explorer.metis.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 2338552
        }
    }
};
// src/metisGoerli.ts
var metisGoerli = {
    id: 599,
    name: "Metis Goerli",
    network: "metis-goerli",
    nativeCurrency: {
        decimals: 18,
        name: "Metis Goerli",
        symbol: "METIS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://goerli.gateway.metisdevops.link"
            ]
        },
        public: {
            http: [
                "https://goerli.gateway.metisdevops.link"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Metis Goerli Explorer",
            url: "https://goerli.explorer.metisdevops.link"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1006207
        }
    }
};
// src/moonbaseAlpha.ts
var moonbaseAlpha = {
    id: 1287,
    name: "Moonbase Alpha",
    network: "moonbase-alpha",
    nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.api.moonbase.moonbeam.network"
            ],
            webSocket: [
                "wss://wss.api.moonbase.moonbeam.network"
            ]
        },
        public: {
            http: [
                "https://rpc.api.moonbase.moonbeam.network"
            ],
            webSocket: [
                "wss://wss.api.moonbase.moonbeam.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonbase.moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonbase.moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1850686
        }
    },
    testnet: true
};
// src/moonbeam.ts
var moonbeam = {
    id: 1284,
    name: "Moonbeam",
    network: "moonbeam",
    nativeCurrency: {
        decimals: 18,
        name: "GLMR",
        symbol: "GLMR"
    },
    rpcUrls: {
        public: {
            http: [
                "https://moonbeam.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonbeam.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://moonbeam.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonbeam.public.blastapi.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 609002
        }
    },
    testnet: false
};
// src/moonriver.ts
var moonriver = {
    id: 1285,
    name: "Moonriver",
    network: "moonriver",
    nativeCurrency: {
        decimals: 18,
        name: "MOVR",
        symbol: "MOVR"
    },
    rpcUrls: {
        public: {
            http: [
                "https://moonriver.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonriver.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://moonriver.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonriver.public.blastapi.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonriver.moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonriver.moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1597904
        }
    },
    testnet: false
};
// src/neonDevnet.ts
var neonDevnet = {
    id: 245022926,
    network: "neonDevnet",
    name: "Neon EVM DevNet",
    nativeCurrency: {
        name: "NEON",
        symbol: "NEON",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://devnet.neonevm.org"
            ]
        },
        public: {
            http: [
                "https://devnet.neonevm.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Neonscan",
            url: "https://neonscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 205206112
        }
    },
    testnet: true
};
// src/nexi.ts
var nexi = {
    id: 4242,
    name: "Nexi",
    network: "nexi",
    nativeCurrency: {
        name: "Nexi",
        symbol: "NEXI",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.chain.nexi.technology"
            ]
        },
        public: {
            http: [
                "https://rpc.chain.nexi.technology"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "NexiScan",
            url: "https://www.nexiscan.com"
        },
        default: {
            name: "NexiScan",
            url: "https://www.nexiscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
            blockCreated: 25770160
        }
    }
};
// src/oasys.ts
var oasys = {
    id: 248,
    name: "Oasys",
    network: "oasys",
    nativeCurrency: {
        name: "Oasys",
        symbol: "OAS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.mainnet.oasys.games"
            ]
        },
        public: {
            http: [
                "https://rpc.mainnet.oasys.games"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "OasysScan",
            url: "https://scan.oasys.games"
        }
    }
};
// src/okc.ts
var okc = {
    id: 66,
    name: "OKC",
    network: "okc",
    nativeCurrency: {
        decimals: 18,
        name: "OKT",
        symbol: "OKT"
    },
    rpcUrls: {
        default: {
            http: [
                "https://exchainrpc.okex.org"
            ]
        },
        public: {
            http: [
                "https://exchainrpc.okex.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "oklink",
            url: "https://www.oklink.com/okc"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 10364792
        }
    }
};
// src/optimism.ts
var optimism = {
    id: 10,
    name: "Optimism",
    network: "optimism",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://opt-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://opt-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://optimism-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://optimism-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://mainnet.optimism.io"
            ]
        },
        public: {
            http: [
                "https://mainnet.optimism.io"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://optimistic.etherscan.io"
        },
        default: {
            name: "Optimism Explorer",
            url: "https://explorer.optimism.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 4286263
        }
    }
};
// src/optimismGoerli.ts
var optimismGoerli = {
    id: 420,
    name: "Optimism Goerli",
    network: "optimism-goerli",
    nativeCurrency: {
        name: "Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://opt-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://opt-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://optimism-goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://optimism-goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://goerli.optimism.io"
            ]
        },
        public: {
            http: [
                "https://goerli.optimism.io"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://goerli-optimism.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://goerli-optimism.etherscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 49461
        }
    },
    testnet: true
};
// src/polygon.ts
var polygon = {
    id: 137,
    name: "Polygon",
    network: "matic",
    nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://polygon-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://polygon-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://polygon-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://polygon-rpc.com"
            ]
        },
        public: {
            http: [
                "https://polygon-rpc.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        },
        default: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 25770160
        }
    }
};
// src/polygonMumbai.ts
var polygonMumbai = {
    id: 80001,
    name: "Polygon Mumbai",
    network: "maticmum",
    nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://polygon-mumbai.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://polygon-mumbai.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://polygon-mumbai.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-mumbai.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://matic-mumbai.chainstacklabs.com"
            ]
        },
        public: {
            http: [
                "https://matic-mumbai.chainstacklabs.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "PolygonScan",
            url: "https://mumbai.polygonscan.com"
        },
        default: {
            name: "PolygonScan",
            url: "https://mumbai.polygonscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 25770160
        }
    },
    testnet: true
};
// src/polygonZkEvmTestnet.ts
var polygonZkEvmTestnet = {
    id: 1442,
    name: "Polygon zkEVM Testnet",
    network: "polygon-zkevm-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.public.zkevm-test.net"
            ]
        },
        public: {
            http: [
                "https://rpc.public.zkevm-test.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://explorer.public.zkevm-test.net"
        }
    },
    testnet: true
};
// src/polygonZkEvm.ts
var polygonZkEvm = {
    id: 1101,
    name: "Polygon zkEVM",
    network: "polygon-zkevm",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://zkevm-rpc.com"
            ]
        },
        public: {
            http: [
                "https://zkevm-rpc.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "PolygonScan",
            url: "https://zkevm.polygonscan.com"
        }
    }
};
// src/pulsechain.ts
var pulsechain = {
    id: 369,
    network: "pulsechain",
    name: "Pulsechain",
    nativeCurrency: {
        name: "Pulse",
        symbol: "PLS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.pulsechain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.pulsechain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Etherscan",
            url: "https://scan.pulsechain.com"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/pulsechainV4.ts
var pulsechainV4 = {
    id: 943,
    network: "pulsechainV4",
    name: "Pulsechain V4",
    testnet: true,
    nativeCurrency: {
        name: "Pulse",
        symbol: "PLS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.v4.testnet.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.v4.testnet.pulsechain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.v4.testnet.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.v4.testnet.pulsechain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://scan.v4.testnet.pulsechain.com"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/scrollTestnet.ts
var scrollTestnet = {
    id: 534353,
    name: "Scroll Testnet",
    network: "scroll-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://alpha-rpc.scroll.io/l2"
            ],
            webSocket: [
                "wss://alpha-rpc.scroll.io/l2/ws"
            ]
        },
        public: {
            http: [
                "https://alpha-rpc.scroll.io/l2"
            ],
            webSocket: [
                "wss://alpha-rpc.scroll.io/l2/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://blockscout.scroll.io"
        }
    },
    testnet: true
};
// src/sepolia.ts
var sepolia = {
    id: 11155111,
    network: "sepolia",
    name: "Sepolia",
    nativeCurrency: {
        name: "Sepolia Ether",
        symbol: "SEP",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-sepolia.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-sepolia.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://sepolia.infura.io/v3"
            ],
            webSocket: [
                "wss://sepolia.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.sepolia.org"
            ]
        },
        public: {
            http: [
                "https://rpc.sepolia.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
        }
    },
    testnet: true
};
// src/skale/brawl.ts
var skaleBlockBrawlers = {
    id: 391845894,
    name: "SKALE | Block Brawlers",
    network: "skale-brawl",
    nativeCurrency: {
        name: "BRAWL",
        symbol: "BRAWL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/frayed-decent-antares"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/frayed-decent-antares"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/calypso.ts
var skaleCalypso = {
    id: 1564830818,
    name: "SKALE | Calypso NFT Hub",
    network: "skale-calypso",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/calypsoTestnet.ts
var skaleCalypsoTestnet = {
    id: 344106930,
    name: "SKALE | Calypso NFT Hub Testnet",
    network: "skale-calypso-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/chaosTestnet.ts
var skaleChaosTestnet = {
    id: 1351057110,
    name: "SKALE | Chaos Testnet",
    network: "skale-chaos-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/cryptoBlades.ts
var skaleCryptoBlades = {
    id: 1026062157,
    name: "SKALE | CryptoBlades",
    network: "skale-cryptoblades",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/cryptoColosseum.ts
var skaleCryptoColosseum = {
    id: 2046399126,
    name: "SKALE | Crypto Colosseum",
    network: "skale-crypto-coloseeum",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/europa.ts
var skaleEuropa = {
    id: 2046399126,
    name: "SKALE | Europa Liquidity Hub",
    network: "skale-europa",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/elated-tan-skat"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/elated-tan-skat"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/europaTestnet.ts
var skaleEuropaTestnet = {
    id: 476158412,
    name: "SKALE | Europa Liquidity Hub Testnet",
    network: "skale-europa-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/exorde.ts
var skaleExorde = {
    id: 2139927552,
    name: "SKALE | Exorde",
    network: "skale-exorde",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/light-vast-diphda"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/light-vast-diphda"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/humanProtocol.ts
var skaleHumanProtocol = {
    id: 1273227453,
    name: "SKALE | Human Protocol",
    network: "skale-human-protocol",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/wan-red-ain"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/wan-red-ain"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/nebula.ts
var skaleNebula = {
    id: 1482601649,
    name: "SKALE | Nebula Gaming Hub",
    network: "skale-nebula",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/green-giddy-denebola"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/green-giddy-denebola"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/nebulaTestnet.ts
var skaleNebulaTestnet = {
    id: 503129905,
    name: "SKALE | Nebula Gaming Hub Testnet",
    network: "skale-nebula-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/razor.ts
var skaleRazor = {
    id: 278611351,
    name: "SKALE | Razor Network",
    network: "skale-razor",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/titan.ts
var skaleTitan = {
    id: 1350216234,
    name: "SKALE | Titan Community Hub",
    network: "skale-titan",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/parallel-stormy-spica"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/parallel-stormy-spica"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/titanTestnet.ts
var skaleTitanTestnet = {
    id: 1517929550,
    name: "SKALE | Titan Community Hub Testnet",
    network: "skale-titan-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/songbird.ts
var songbird = {
    id: 19,
    name: "Songbird Mainnet",
    network: "songbird-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "songbird",
        symbol: "SGB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://songbird-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://songbird-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Songbird Explorer",
            url: "https://songbird-explorer.flare.network"
        }
    }
};
// src/songbirdTestnet.ts
var songbirdTestnet = {
    id: 16,
    name: "Coston",
    network: "coston",
    nativeCurrency: {
        decimals: 18,
        name: "costonflare",
        symbol: "CFLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://coston-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://coston-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Coston Explorer",
            url: "https://coston-explorer.flare.network"
        }
    },
    testnet: true
};
// src/shardeumSphinx.ts
var shardeumSphinx = {
    id: 8082,
    name: "Shardeum Sphinx",
    network: "shmSphinx",
    nativeCurrency: {
        name: "SHARDEUM",
        symbol: "SHM",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://sphinx.shardeum.org"
            ]
        },
        public: {
            http: [
                "https://sphinx.shardeum.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Shardeum Explorer",
            url: "https://explorer-sphinx.shardeum.org"
        }
    },
    testnet: true
};
// src/syscoin.ts
var syscoin = {
    id: 57,
    name: "Syscoin Mainnet",
    network: "syscoin",
    nativeCurrency: {
        decimals: 8,
        name: "Syscoin",
        symbol: "SYS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.syscoin.org"
            ]
        },
        public: {
            http: [
                "https://rpc.syscoin.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "SyscoinExplorer",
            url: "https://explorer.syscoin.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0x000562033783B1136159E10d976B519C929cdE8e",
            blockCreated: 80637
        }
    }
};
// src/taraxa.ts
var taraxa = {
    id: 841,
    name: "Taraxa Mainnet",
    network: "taraxa",
    nativeCurrency: {
        name: "Tara",
        symbol: "TARA",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.mainnet.taraxa.io"
            ]
        },
        public: {
            http: [
                "https://rpc.mainnet.taraxa.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Taraxa Explorer",
            url: "https://explorer.mainnet.taraxa.io"
        }
    }
};
// src/taraxaTestnet.ts
var taraxaTestnet = {
    id: 842,
    name: "Taraxa Testnet",
    network: "taraxa-testnet",
    nativeCurrency: {
        name: "Tara",
        symbol: "TARA",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.testnet.taraxa.io"
            ]
        },
        public: {
            http: [
                "https://rpc.testnet.taraxa.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Taraxa Explorer",
            url: "https://explorer.testnet.taraxa.io"
        }
    },
    testnet: true
};
// src/telos.ts
var telos = {
    id: 40,
    name: "Telos",
    network: "telos",
    nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.telos.net/evm"
            ]
        },
        public: {
            http: [
                "https://mainnet.telos.net/evm"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Teloscan",
            url: "https://www.teloscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 246530709
        }
    }
};
// src/telosTestnet.ts
var telosTestnet = {
    id: 41,
    name: "Telos",
    network: "telosTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.telos.net/evm"
            ]
        },
        public: {
            http: [
                "https://testnet.telos.net/evm"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Teloscan (testnet)",
            url: "https://testnet.teloscan.io/"
        }
    },
    testnet: true
};
// src/thunderTestnet.ts
var thunderTestnet = {
    id: 997,
    name: "5ireChain Thunder Testnet",
    network: "5ireChain",
    nativeCurrency: {
        name: "5ire Token",
        symbol: "5IRE",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc-testnet.5ire.network"
            ]
        },
        public: {
            http: [
                "https://rpc-testnet.5ire.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "5ireChain Explorer",
            url: "https://explorer.5ire.network"
        }
    },
    testnet: true
};
// src/wanchain.ts
var wanchain = {
    id: 888,
    name: "Wanchain",
    network: "wanchain",
    nativeCurrency: {
        name: "WANCHAIN",
        symbol: "WAN",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://gwan-ssl.wandevs.org:56891",
                "https://gwan2-ssl.wandevs.org"
            ]
        },
        public: {
            http: [
                "https://gwan-ssl.wandevs.org:56891",
                "https://gwan2-ssl.wandevs.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "WanScan",
            url: "https://wanscan.org"
        },
        default: {
            name: "WanScan",
            url: "https://wanscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
            blockCreated: 25312390
        }
    }
};
// src/wanchainTestnet.ts
var wanchainTestnet = {
    id: 999,
    name: "Wanchain Testnet",
    network: "wanchainTestnet",
    nativeCurrency: {
        name: "WANCHAIN",
        symbol: "WANt",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://gwan-ssl.wandevs.org:46891"
            ]
        },
        public: {
            http: [
                "https://gwan-ssl.wandevs.org:46891"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "WanScanTest",
            url: "https://wanscan.org"
        },
        default: {
            name: "WanScanTest",
            url: "https://wanscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
            blockCreated: 24743448
        }
    },
    testnet: true
};
// src/xdc.ts
var xdc = {
    id: 50,
    name: "XinFin Network",
    network: "xdc",
    nativeCurrency: {
        decimals: 18,
        name: "XDC",
        symbol: "XDC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.xinfin.network"
            ]
        },
        public: {
            http: [
                "https://rpc.xinfin.network"
            ]
        }
    },
    blockExplorers: {
        xinfin: {
            name: "XinFin",
            url: "https://explorer.xinfin.network"
        },
        default: {
            name: "Blocksscan",
            url: "https://xdc.blocksscan.io"
        }
    }
};
// src/xdcTestnet.ts
var xdcTestnet = {
    id: 51,
    name: "Apothem Network",
    network: "xdc-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "TXDC",
        symbol: "TXDC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://erpc.apothem.network"
            ]
        },
        public: {
            http: [
                "https://erpc.apothem.network"
            ]
        }
    },
    blockExplorers: {
        xinfin: {
            name: "XinFin",
            url: "https://explorer.apothem.network"
        },
        default: {
            name: "Blocksscan",
            url: "https://apothem.blocksscan.io"
        }
    }
};
// src/zhejiang.ts
var zhejiang = {
    id: 1337803,
    network: "zhejiang",
    name: "Zhejiang",
    nativeCurrency: {
        name: "Zhejiang Ether",
        symbol: "ZhejETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.zhejiang.ethpandaops.io"
            ]
        },
        public: {
            http: [
                "https://rpc.zhejiang.ethpandaops.io"
            ]
        }
    },
    blockExplorers: {
        beaconchain: {
            name: "Etherscan",
            url: "https://zhejiang.beaconcha.in"
        },
        blockscout: {
            name: "Blockscout",
            url: "https://blockscout.com/eth/zhejiang-testnet"
        },
        default: {
            name: "Beaconchain",
            url: "https://zhejiang.beaconcha.in"
        }
    },
    testnet: true
};
// src/zkSync.ts
var zkSync = {
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.era.zksync.io"
            ],
            webSocket: [
                "wss://mainnet.era.zksync.io/ws"
            ]
        },
        public: {
            http: [
                "https://mainnet.era.zksync.io"
            ],
            webSocket: [
                "wss://mainnet.era.zksync.io/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "zkExplorer",
            url: "https://explorer.zksync.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
    }
};
// src/zkSyncTestnet.ts
var zkSyncTestnet = {
    id: 280,
    name: "zkSync Era Testnet",
    network: "zksync-era-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.era.zksync.dev"
            ],
            webSocket: [
                "wss://testnet.era.zksync.dev/ws"
            ]
        },
        public: {
            http: [
                "https://testnet.era.zksync.dev"
            ],
            webSocket: [
                "wss://testnet.era.zksync.dev/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "zkExplorer",
            url: "https://goerli.explorer.zksync.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
    },
    testnet: true
};
// src/zora.ts
var zora = {
    id: 7777777,
    name: "ZORA",
    network: "zora",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.zora.co"
            ],
            webSocket: [
                "wss://rpc.zora.co"
            ]
        },
        public: {
            http: [
                "https://rpc.zora.co"
            ],
            webSocket: [
                "wss://rpc.zora.co"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "ZORA",
            url: "https://explorer.zora.co"
        },
        default: {
            name: "ZORA",
            url: "https://explorer.zora.co"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 5882
        }
    }
};
// src/zoraTestnet.ts
var zoraTestnet = {
    id: 999,
    name: "ZORA Goerli Testnet",
    network: "zora-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "ZORA Goerli",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.rpc.zora.co"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.co"
            ]
        },
        public: {
            http: [
                "https://testnet.rpc.zora.co"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.co"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "ZORA",
            url: "https://testnet.explorer.zora.co"
        },
        default: {
            name: "ZORA",
            url: "https://testnet.explorer.zora.co"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 189123
        }
    },
    testnet: true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"cruNy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertCurrentChain", ()=>assertCurrentChain);
parcelHelpers.export(exports, "defineChain", ()=>defineChain);
parcelHelpers.export(exports, "getChainContractAddress", ()=>getChainContractAddress);
var _chainJs = require("../errors/chain.js");
function assertCurrentChain({ chain, currentChainId }) {
    if (!chain) throw new (0, _chainJs.ChainNotFoundError)();
    if (currentChainId !== chain.id) throw new (0, _chainJs.ChainMismatchError)({
        chain,
        currentChainId
    });
}
function defineChain(chain, config) {
    return {
        ...chain,
        formatters: config?.formatters,
        serializers: config?.serializers
    };
}
function getChainContractAddress({ blockNumber, chain, contract: name }) {
    const contract = chain?.contracts?.[name];
    if (!contract) throw new (0, _chainJs.ChainDoesNotSupportContract)({
        chain,
        contract: {
            name
        }
    });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber) throw new (0, _chainJs.ChainDoesNotSupportContract)({
        blockNumber,
        chain,
        contract: {
            name,
            blockCreated: contract.blockCreated
        }
    });
    return contract.address;
}

},{"../errors/chain.js":"11dLm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"11dLm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>ChainDoesNotSupportContract);
parcelHelpers.export(exports, "ChainMismatchError", ()=>ChainMismatchError);
parcelHelpers.export(exports, "ChainNotFoundError", ()=>ChainNotFoundError);
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>ClientChainNotConfiguredError);
parcelHelpers.export(exports, "InvalidChainIdError", ()=>InvalidChainIdError);
var _baseJs = require("./base.js");
class ChainDoesNotSupportContract extends (0, _baseJs.BaseError) {
    constructor({ blockNumber, chain, contract }){
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
                "This could be due to any of the following:",
                ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                    `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
                ] : [
                    `- The chain does not have the contract "${contract.name}" configured.`
                ]
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDoesNotSupportContract"
        });
    }
}
class ChainMismatchError extends (0, _baseJs.BaseError) {
    constructor({ chain, currentChainId }){
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
            metaMessages: [
                `Current Chain ID:  ${currentChainId}`,
                `Expected Chain ID: ${chain.id} – ${chain.name}`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainMismatchError"
        });
    }
}
class ChainNotFoundError extends (0, _baseJs.BaseError) {
    constructor(){
        super([
            "No chain was provided to the request.",
            "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainNotFoundError"
        });
    }
}
class ClientChainNotConfiguredError extends (0, _baseJs.BaseError) {
    constructor(){
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ClientChainNotConfiguredError"
        });
    }
}
class InvalidChainIdError extends (0, _baseJs.BaseError) {
    constructor({ chainId }){
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidChainIdError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Osf13":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseError", ()=>BaseError);
var _utilsJs = require("./utils.js");
class BaseError extends Error {
    constructor(shortMessage, args = {}){
        super();
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ViemError"
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, _utilsJs.getVersion)()
        });
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [
                ...args.metaMessages,
                ""
            ] : [],
            ...docsPath ? [
                `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
            ] : [],
            ...details ? [
                `Details: ${details}`
            ] : [],
            `Version: ${this.version}`
        ].join("\n");
        if (args.cause) this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
function walk(err, fn) {
    if (fn?.(err)) return err;
    if (err.cause) return walk(err.cause, fn);
    return err;
}

},{"./utils.js":"58gbo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"58gbo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractAddress", ()=>getContractAddress);
parcelHelpers.export(exports, "getUrl", ()=>getUrl);
parcelHelpers.export(exports, "getVersion", ()=>getVersion);
var _versionJs = require("./version.js");
const getContractAddress = (address)=>address;
const getUrl = (url)=>url;
const getVersion = ()=>`viem@${0, _versionJs.version}`;

},{"./version.js":"1JJS5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1JJS5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "1.2.6";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ZyMH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "celoFormatters", ()=>celoFormatters);
var _formatterJs = require("../../types/formatter.js");
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _blockJs = require("../../utils/formatters/block.js");
var _transactionJs = require("../../utils/formatters/transaction.js");
var _transactionReceiptJs = require("../../utils/formatters/transactionReceipt.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
const celoFormatters = {
    block: /*#__PURE__*/ (0, _blockJs.defineBlock)({
        exclude: [
            "difficulty",
            "gasLimit",
            "mixHash",
            "nonce",
            "uncles"
        ],
        format (args) {
            const transactions = args.transactions?.map((transaction)=>{
                if (typeof transaction === "string") return transaction;
                return {
                    ...(0, _transactionJs.formatTransaction)(transaction),
                    feeCurrency: transaction.feeCurrency,
                    gatewayFee: transaction.gatewayFee ? (0, _fromHexJs.hexToBigInt)(transaction.gatewayFee) : null,
                    gatewayFeeRecipient: transaction.gatewayFeeRecipient
                };
            });
            return {
                randomness: args.randomness,
                transactions
            };
        }
    }),
    transaction: /*#__PURE__*/ (0, _transactionJs.defineTransaction)({
        format (args) {
            return {
                feeCurrency: args.feeCurrency,
                gatewayFee: args.gatewayFee ? (0, _fromHexJs.hexToBigInt)(args.gatewayFee) : null,
                gatewayFeeRecipient: args.gatewayFeeRecipient
            };
        }
    }),
    transactionReceipt: /*#__PURE__*/ (0, _transactionReceiptJs.defineTransactionReceipt)({
        format (args) {
            return {
                feeCurrency: args.feeCurrency,
                gatewayFee: args.gatewayFee ? (0, _fromHexJs.hexToBigInt)(args.gatewayFee) : null,
                gatewayFeeRecipient: args.gatewayFeeRecipient
            };
        }
    }),
    transactionRequest: /*#__PURE__*/ (0, _transactionRequestJs.defineTransactionRequest)({
        format (args) {
            return {
                feeCurrency: args.feeCurrency,
                gatewayFee: typeof args.gatewayFee !== "undefined" ? (0, _toHexJs.numberToHex)(args.gatewayFee) : undefined,
                gatewayFeeRecipient: args.gatewayFeeRecipient
            };
        }
    })
};

},{"../../types/formatter.js":"eSxxk","../../utils/encoding/fromHex.js":"6RbMz","../../utils/encoding/toHex.js":"67sRi","../../utils/formatters/block.js":"iBInX","../../utils/formatters/transaction.js":"cumRV","../../utils/formatters/transactionReceipt.js":"7zuER","../../utils/formatters/transactionRequest.js":"hmBeH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eSxxk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6RbMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertSize", ()=>assertSize);
/**
 * Decodes a hex string into a string, number, bigint, boolean, or byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex.html
 * - Example: https://viem.sh/docs/utilities/fromHex.html#usage
 *
 * @param hex Hex string to decode.
 * @param toOrOpts Type to convert to or options.
 * @returns Decoded value.
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x1a4', 'number')
 * // 420
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')
 * // 'Hello world'
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *   size: 32,
 *   to: 'string'
 * })
 * // 'Hello world'
 */ parcelHelpers.export(exports, "fromHex", ()=>fromHex);
/**
 * Decodes a hex value into a bigint.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns BigInt value.
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x1a4', { signed: true })
 * // 420n
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420n
 */ parcelHelpers.export(exports, "hexToBigInt", ()=>hexToBigInt);
/**
 * Decodes a hex value into a boolean.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Boolean value.
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x01')
 * // true
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })
 * // true
 */ parcelHelpers.export(exports, "hexToBool", ()=>hexToBool);
/**
 * Decodes a hex string into a number.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Number value.
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToNumber('0x1a4')
 * // 420
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420
 */ parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
/**
 * Decodes a hex value into a UTF-8 string.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns String value.
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c6421')
 * // 'Hello world!'
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *  size: 32,
 * })
 * // 'Hello world'
 */ parcelHelpers.export(exports, "hexToString", ()=>hexToString);
var _encodingJs = require("../../errors/encoding.js");
var _sizeJs = require("../data/size.js");
var _trimJs = require("../data/trim.js");
var _toBytesJs = require("./toBytes.js");
function assertSize(hexOrBytes, { size }) {
    if ((0, _sizeJs.size)(hexOrBytes) > size) throw new (0, _encodingJs.SizeOverflowError)({
        givenSize: (0, _sizeJs.size)(hexOrBytes),
        maxSize: size
    });
}
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? {
        to: toOrOpts
    } : toOrOpts;
    const to = opts.to;
    if (to === "number") return hexToNumber(hex, opts);
    if (to === "bigint") return hexToBigInt(hex, opts);
    if (to === "string") return hexToString(hex, opts);
    if (to === "boolean") return hexToBool(hex, opts);
    return (0, _toBytesJs.hexToBytes)(hex, opts);
}
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size) assertSize(hex, {
        size: opts.size
    });
    const value = BigInt(hex);
    if (!signed) return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << BigInt(size) * 8n - 1n) - 1n;
    if (value <= max) return value;
    return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, {
            size: opts.size
        });
        hex = (0, _trimJs.trim)(hex);
    }
    if ((0, _trimJs.trim)(hex) === "0x00") return false;
    if ((0, _trimJs.trim)(hex) === "0x01") return true;
    throw new (0, _encodingJs.InvalidHexBooleanError)(hex);
}
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
    let bytes = (0, _toBytesJs.hexToBytes)(hex);
    if (opts.size) {
        assertSize(bytes, {
            size: opts.size
        });
        bytes = (0, _trimJs.trim)(bytes, {
            dir: "right"
        });
    }
    return new TextDecoder().decode(bytes);
}

},{"../../errors/encoding.js":"l2Pc4","../data/size.js":"jRUcy","../data/trim.js":"khJVi","./toBytes.js":"jM9VU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l2Pc4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DataLengthTooLongError", ()=>DataLengthTooLongError);
parcelHelpers.export(exports, "DataLengthTooShortError", ()=>DataLengthTooShortError);
parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>IntegerOutOfRangeError);
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>InvalidBytesBooleanError);
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>InvalidHexBooleanError);
parcelHelpers.export(exports, "InvalidHexValueError", ()=>InvalidHexValueError);
parcelHelpers.export(exports, "OffsetOutOfBoundsError", ()=>OffsetOutOfBoundsError);
parcelHelpers.export(exports, "SizeOverflowError", ()=>SizeOverflowError);
var _baseJs = require("./base.js");
class DataLengthTooLongError extends (0, _baseJs.BaseError) {
    constructor({ consumed, length }){
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DataLengthTooLongError"
        });
    }
}
class DataLengthTooShortError extends (0, _baseJs.BaseError) {
    constructor({ length, dataLength }){
        super(`Data length (${dataLength - 1}) is shorter than prefix length (${length - 1}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DataLengthTooShortError"
        });
    }
}
class IntegerOutOfRangeError extends (0, _baseJs.BaseError) {
    constructor({ max, min, signed, size, value }){
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntegerOutOfRangeError"
        });
    }
}
class InvalidBytesBooleanError extends (0, _baseJs.BaseError) {
    constructor(bytes){
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidBytesBooleanError"
        });
    }
}
class InvalidHexBooleanError extends (0, _baseJs.BaseError) {
    constructor(hex){
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidHexBooleanError"
        });
    }
}
class InvalidHexValueError extends (0, _baseJs.BaseError) {
    constructor(value){
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidHexValueError"
        });
    }
}
class OffsetOutOfBoundsError extends (0, _baseJs.BaseError) {
    constructor({ nextOffset, offset }){
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffsetOutOfBoundsError"
        });
    }
}
class SizeOverflowError extends (0, _baseJs.BaseError) {
    constructor({ givenSize, maxSize }){
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeOverflowError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jRUcy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */ parcelHelpers.export(exports, "size", ()=>size);
var _isHexJs = require("./isHex.js");
function size(value) {
    if ((0, _isHexJs.isHex)(value, {
        strict: false
    })) return Math.ceil((value.length - 2) / 2);
    return value.length;
}

},{"./isHex.js":"gOtuZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOtuZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHex", ()=>isHex);
function isHex(value, { strict = true } = {}) {
    if (!value) return false;
    if (typeof value !== "string") return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"khJVi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trim", ()=>trim);
function trim(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") sliceLength++;
        else break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right") data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jM9VU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes.html
 * - Example: https://viem.sh/docs/utilities/toBytes.html#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes('Hello world')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Encodes a boolean into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes
 *
 * @param value Boolean value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true)
 * // Uint8Array([1])
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true, { size: 32 })
 * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
 */ parcelHelpers.export(exports, "boolToBytes", ()=>boolToBytes);
/**
 * Encodes a hex string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes
 *
 * @param hex Hex string to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
/**
 * Encodes a number into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes
 *
 * @param value Number to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */ parcelHelpers.export(exports, "numberToBytes", ()=>numberToBytes);
/**
 * Encodes a UTF-8 string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes
 *
 * @param value String to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */ parcelHelpers.export(exports, "stringToBytes", ()=>stringToBytes);
var _baseJs = require("../../errors/base.js");
var _isHexJs = require("../data/isHex.js");
var _padJs = require("../data/pad.js");
var _fromHexJs = require("./fromHex.js");
var _toHexJs = require("./toHex.js");
const encoder = /*#__PURE__*/ new TextEncoder();
function toBytes(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint") return numberToBytes(value, opts);
    if (typeof value === "boolean") return boolToBytes(value, opts);
    if ((0, _isHexJs.isHex)(value)) return hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === "number") {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        return (0, _padJs.pad)(bytes, {
            size: opts.size
        });
    }
    return bytes;
}
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        hex = (0, _padJs.pad)(hex, {
            dir: "right",
            size: opts.size
        });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) hexString = `0${hexString}`;
    const bytes = new Uint8Array(hexString.length / 2);
    for(let index = 0; index < bytes.length; index++){
        const start = index * 2;
        const hexByte = hexString.slice(start, start + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new (0, _baseJs.BaseError)(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
        bytes[index] = byte;
    }
    return bytes;
}
function numberToBytes(value, opts) {
    const hex = (0, _toHexJs.numberToHex)(value, opts);
    return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
    const bytes = encoder.encode(value);
    if (typeof opts.size === "number") {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        return (0, _padJs.pad)(bytes, {
            dir: "right",
            size: opts.size
        });
    }
    return bytes;
}

},{"../../errors/base.js":"Osf13","../data/isHex.js":"gOtuZ","../data/pad.js":"NSHzf","./fromHex.js":"6RbMz","./toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NSHzf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pad", ()=>pad);
parcelHelpers.export(exports, "padHex", ()=>padHex);
parcelHelpers.export(exports, "padBytes", ()=>padBytes);
var _dataJs = require("../../errors/data.js");
function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === "string") return padHex(hexOrBytes, {
        dir,
        size
    });
    return padBytes(hexOrBytes, {
        dir,
        size
    });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null) return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size * 2) throw new (0, _dataJs.SizeExceedsPaddingSizeError)({
        size: Math.ceil(hex.length / 2),
        targetSize: size,
        type: "hex"
    });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null) return bytes;
    if (bytes.length > size) throw new (0, _dataJs.SizeExceedsPaddingSizeError)({
        size: bytes.length,
        targetSize: size,
        type: "bytes"
    });
    const paddedBytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}

},{"../../errors/data.js":"71w8M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71w8M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>SliceOffsetOutOfBoundsError);
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>SizeExceedsPaddingSizeError);
var _baseJs = require("./base.js");
class SliceOffsetOutOfBoundsError extends (0, _baseJs.BaseError) {
    constructor({ offset, position, size }){
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SliceOffsetOutOfBoundsError"
        });
    }
}
class SizeExceedsPaddingSizeError extends (0, _baseJs.BaseError) {
    constructor({ size, targetSize, type }){
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeExceedsPaddingSizeError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"67sRi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encodes a string, number, bigint, or ByteArray into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex.html
 * - Example: https://viem.sh/docs/utilities/toHex.html#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world')
 * // '0x48656c6c6f20776f726c6421'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex(420)
 * // '0x1a4'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world', { size: 32 })
 * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "toHex", ()=>toHex);
/**
 * Encodes a boolean into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true)
 * // '0x1'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(false)
 * // '0x0'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true, { size: 32 })
 * // '0x0000000000000000000000000000000000000000000000000000000000000001'
 */ parcelHelpers.export(exports, "boolToHex", ()=>boolToHex);
/**
 * Encodes a bytes array into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */ parcelHelpers.export(exports, "numberToHex", ()=>numberToHex);
/**
 * Encodes a UTF-8 string into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "stringToHex", ()=>stringToHex);
var _encodingJs = require("../../errors/encoding.js");
var _padJs = require("../data/pad.js");
var _fromHexJs = require("./fromHex.js");
const hexes = /*#__PURE__*/ Array.from({
    length: 256
}, (_v, i)=>i.toString(16).padStart(2, "0"));
function toHex(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint") return numberToHex(value, opts);
    if (typeof value === "string") return stringToHex(value, opts);
    if (typeof value === "boolean") return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        return (0, _padJs.pad)(hex, {
            size: opts.size
        });
    }
    return hex;
}
function bytesToHex(value, opts = {}) {
    let hexString = "";
    for(let i = 0; i < value.length; i++)hexString += hexes[value[i]];
    const hex = `0x${hexString}`;
    if (typeof opts.size === "number") {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        return (0, _padJs.pad)(hex, {
            dir: "right",
            size: opts.size
        });
    }
    return hex;
}
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    } else if (typeof value_ === "number") maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new (0, _encodingJs.IntegerOutOfRangeError)({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size) return (0, _padJs.pad)(hex, {
        size
    });
    return hex;
}
const encoder = /*#__PURE__*/ new TextEncoder();
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}

},{"../../errors/encoding.js":"l2Pc4","../data/pad.js":"NSHzf","./fromHex.js":"6RbMz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iBInX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatBlock", ()=>formatBlock);
parcelHelpers.export(exports, "defineBlock", ()=>defineBlock);
var _formatterJs = require("./formatter.js");
var _transactionJs = require("./transaction.js");
function formatBlock(block) {
    const transactions = block.transactions?.map((transaction)=>{
        if (typeof transaction === "string") return transaction;
        return (0, _transactionJs.formatTransaction)(transaction);
    });
    return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : undefined,
        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
}
const defineBlock = /*#__PURE__*/ (0, _formatterJs.defineFormatter)("block", formatBlock);

},{"./formatter.js":"aUCVg","./transaction.js":"cumRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aUCVg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineFormatter", ()=>defineFormatter);
function defineFormatter(type, format) {
    return ({ exclude, format: overrides })=>{
        return {
            format: (args)=>{
                const formatted = format(args);
                if (exclude) for (const key of exclude)delete formatted[key];
                return {
                    ...formatted,
                    ...overrides(args)
                };
            },
            type
        };
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cumRV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transactionType", ()=>transactionType);
parcelHelpers.export(exports, "formatTransaction", ()=>formatTransaction);
parcelHelpers.export(exports, "defineTransaction", ()=>defineTransaction);
var _fromHexJs = require("../encoding/fromHex.js");
var _formatterJs = require("./formatter.js");
const transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559"
};
function formatTransaction(transaction) {
    const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, _fromHexJs.hexToNumber)(transaction.chainId) : undefined,
        gas: transaction.gas ? BigInt(transaction.gas) : undefined,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
        nonce: transaction.nonce ? (0, _fromHexJs.hexToNumber)(transaction.nonce) : undefined,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? transactionType[transaction.type] : undefined,
        typeHex: transaction.type ? transaction.type : undefined,
        value: transaction.value ? BigInt(transaction.value) : undefined,
        v: transaction.v ? BigInt(transaction.v) : undefined
    };
    if (transaction_.type === "legacy") {
        delete transaction_["accessList"];
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
    }
    if (transaction_.type === "eip2930") {
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
    }
    return transaction_;
}
const defineTransaction = /*#__PURE__*/ (0, _formatterJs.defineFormatter)("transaction", formatTransaction);

},{"../encoding/fromHex.js":"6RbMz","./formatter.js":"aUCVg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7zuER":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatTransactionReceipt", ()=>formatTransactionReceipt);
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>defineTransactionReceipt);
var _fromHexJs = require("../encoding/fromHex.js");
var _formatterJs = require("./formatter.js");
var _logJs = require("./log.js");
var _transactionJs = require("./transaction.js");
const statuses = {
    "0x0": "reverted",
    "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
    return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log)=>(0, _logJs.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, _fromHexJs.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? (0, _transactionJs.transactionType)[transactionReceipt.type] || transactionReceipt.type : null
    };
}
const defineTransactionReceipt = /*#__PURE__*/ (0, _formatterJs.defineFormatter)("transactionReceipt", formatTransactionReceipt);

},{"../encoding/fromHex.js":"6RbMz","./formatter.js":"aUCVg","./log.js":"7uIcs","./transaction.js":"cumRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7uIcs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatLog", ()=>formatLog);
function formatLog(log, { args, eventName } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? {
            args,
            eventName
        } : {}
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hmBeH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatTransactionRequest", ()=>formatTransactionRequest);
parcelHelpers.export(exports, "defineTransactionRequest", ()=>defineTransactionRequest);
var _toHexJs = require("../encoding/toHex.js");
var _formatterJs = require("./formatter.js");
function formatTransactionRequest(transactionRequest) {
    return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.gas) : undefined,
        gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.gasPrice) : undefined,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.maxFeePerGas) : undefined,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.maxPriorityFeePerGas) : undefined,
        nonce: typeof transactionRequest.nonce !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.nonce) : undefined,
        value: typeof transactionRequest.value !== "undefined" ? (0, _toHexJs.numberToHex)(transactionRequest.value) : undefined
    };
}
const defineTransactionRequest = /*#__PURE__*/ (0, _formatterJs.defineFormatter)("transactionRequest", formatTransactionRequest);

},{"../encoding/toHex.js":"67sRi","./formatter.js":"aUCVg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eTCdU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "optimismFormatters", ()=>optimismFormatters);
var _formatterJs = require("../../types/formatter.js");
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _blockJs = require("../../utils/formatters/block.js");
var _transactionJs = require("../../utils/formatters/transaction.js");
const optimismFormatters = {
    block: /*#__PURE__*/ (0, _blockJs.defineBlock)({
        format (args) {
            const transactions = args.transactions?.map((transaction)=>{
                if (typeof transaction === "string") return transaction;
                const formatted = (0, _transactionJs.formatTransaction)(transaction);
                if (formatted.typeHex === "0x7e") {
                    formatted.isSystemTx = transaction.isSystemTx;
                    formatted.mint = transaction.mint ? (0, _fromHexJs.hexToBigInt)(transaction.mint) : undefined;
                    formatted.sourceHash = transaction.sourceHash;
                    formatted.type = "deposit";
                }
                return formatted;
            });
            return {
                transactions
            };
        }
    }),
    transaction: /*#__PURE__*/ (0, _transactionJs.defineTransaction)({
        format (args) {
            const transaction = {};
            if (args.type === "0x7e") {
                transaction.isSystemTx = args.isSystemTx;
                transaction.mint = args.mint ? (0, _fromHexJs.hexToBigInt)(args.mint) : undefined;
                transaction.sourceHash = args.sourceHash;
                transaction.type = "deposit";
            }
            return transaction;
        }
    })
};

},{"../../types/formatter.js":"eSxxk","../../utils/encoding/fromHex.js":"6RbMz","../../utils/formatters/block.js":"iBInX","../../utils/formatters/transaction.js":"cumRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cKx9I":[function(require,module,exports) {
// src/utils/normalizeChainId.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalizeChainId", ()=>normalizeChainId);
function normalizeChainId(chainId) {
    if (typeof chainId === "string") return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    if (typeof chainId === "bigint") return Number(chainId);
    return chainId;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"54xJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InjectedConnector", ()=>(0, _chunkQRUHVNWKJs.InjectedConnector));
var _chunkQRUHVNWKJs = require("./chunk-QRUHVNWK.js");
var _chunkZCAPXGBXJs = require("./chunk-ZCAPXGBX.js");
var _chunkOQILYQDOJs = require("./chunk-OQILYQDO.js");
var _chunkQYMCVNHTJs = require("./chunk-QYMCVNHT.js");

},{"./chunk-QRUHVNWK.js":"7slN7","./chunk-ZCAPXGBX.js":false,"./chunk-OQILYQDO.js":false,"./chunk-QYMCVNHT.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7slN7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InjectedConnector", ()=>InjectedConnector);
var _chunkZCAPXGBXJs = require("./chunk-ZCAPXGBX.js");
var _chunkOQILYQDOJs = require("./chunk-OQILYQDO.js");
var _chunkQYMCVNHTJs = require("./chunk-QYMCVNHT.js");
// src/injected.ts
var _viem = require("viem");
// src/utils/getInjectedName.ts
function getInjectedName(ethereum) {
    if (!ethereum) return "Injected";
    const getName = (provider)=>{
        if (provider.isApexWallet) return "Apex Wallet";
        if (provider.isAvalanche) return "Core Wallet";
        if (provider.isBackpack) return "Backpack";
        if (provider.isBifrost) return "Bifrost Wallet";
        if (provider.isBitKeep) return "BitKeep";
        if (provider.isBitski) return "Bitski";
        if (provider.isBlockWallet) return "BlockWallet";
        if (provider.isBraveWallet) return "Brave Wallet";
        if (provider.isCoinbaseWallet) return "Coinbase Wallet";
        if (provider.isDawn) return "Dawn Wallet";
        if (provider.isDefiant) return "Defiant";
        if (provider.isEnkrypt) return "Enkrypt";
        if (provider.isExodus) return "Exodus";
        if (provider.isFrame) return "Frame";
        if (provider.isFrontier) return "Frontier Wallet";
        if (provider.isGamestop) return "GameStop Wallet";
        if (provider.isHaqqWallet) return "HAQQ Wallet";
        if (provider.isHyperPay) return "HyperPay Wallet";
        if (provider.isImToken) return "ImToken";
        if (provider.isHaloWallet) return "Halo Wallet";
        if (provider.isKuCoinWallet) return "KuCoin Wallet";
        if (provider.isMathWallet) return "MathWallet";
        if (provider.isNovaWallet) return "Nova Wallet";
        if (provider.isOkxWallet || provider.isOKExWallet) return "OKX Wallet";
        if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) return "1inch Wallet";
        if (provider.isOpera) return "Opera";
        if (provider.isPhantom) return "Phantom";
        if (provider.isPortal) return "Ripio Portal";
        if (provider.isRabby) return "Rabby Wallet";
        if (provider.isRainbow) return "Rainbow";
        if (provider.isStatus) return "Status";
        if (provider.isTalisman) return "Talisman";
        if (provider.isTally) return "Taho";
        if (provider.isTokenPocket) return "TokenPocket";
        if (provider.isTokenary) return "Tokenary";
        if (provider.isTrust || provider.isTrustWallet) return "Trust Wallet";
        if (provider.isTTWallet) return "TTWallet";
        if (provider.isXDEFI) return "XDEFI Wallet";
        if (provider.isZerion) return "Zerion";
        if (provider.isMetaMask) return "MetaMask";
    };
    if (ethereum.providers?.length) {
        const nameSet = /* @__PURE__ */ new Set();
        let unknownCount = 1;
        for (const provider of ethereum.providers){
            let name = getName(provider);
            if (!name) {
                name = `Unknown Wallet #${unknownCount}`;
                unknownCount += 1;
            }
            nameSet.add(name);
        }
        const names = [
            ...nameSet
        ];
        if (names.length) return names;
        return names[0] ?? "Injected";
    }
    return getName(ethereum) ?? "Injected";
}
// src/injected.ts
var _provider;
var InjectedConnector = class extends (0, _chunkQYMCVNHTJs.Connector) {
    constructor({ chains, options: options_ } = {}){
        const options = {
            shimDisconnect: true,
            getProvider () {
                if (typeof window === "undefined") return;
                const ethereum = window.ethereum;
                if (ethereum?.providers) return ethereum.providers[0];
                return ethereum;
            },
            ...options_
        };
        super({
            chains,
            options
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "id", "injected");
        (0, _chunkQYMCVNHTJs.__publicField)(this, "name");
        (0, _chunkQYMCVNHTJs.__publicField)(this, "ready");
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _provider, void 0);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "shimDisconnectKey", `${this.id}.shimDisconnect`);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onAccountsChanged", (accounts)=>{
            if (accounts.length === 0) this.emit("disconnect");
            else this.emit("change", {
                account: (0, _viem.getAddress)(accounts[0])
            });
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onChainChanged", (chainId)=>{
            const id = (0, _chunkOQILYQDOJs.normalizeChainId)(chainId);
            const unsupported = this.isChainUnsupported(id);
            this.emit("change", {
                chain: {
                    id,
                    unsupported
                }
            });
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onDisconnect", async (error)=>{
            if (error.code === 1013) {
                const provider = await this.getProvider();
                if (provider) {
                    const isAuthorized = await this.getAccount();
                    if (isAuthorized) return;
                }
            }
            this.emit("disconnect");
            if (this.options.shimDisconnect) this.storage?.removeItem(this.shimDisconnectKey);
        });
        const provider = options.getProvider();
        if (typeof options.name === "string") this.name = options.name;
        else if (provider) {
            const detectedName = getInjectedName(provider);
            if (options.name) this.name = options.name(detectedName);
            else if (typeof detectedName === "string") this.name = detectedName;
            else this.name = detectedName[0];
        } else this.name = "Injected";
        this.ready = !!provider;
    }
    async connect({ chainId } = {}) {
        try {
            const provider = await this.getProvider();
            if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
            if (provider.on) {
                provider.on("accountsChanged", this.onAccountsChanged);
                provider.on("chainChanged", this.onChainChanged);
                provider.on("disconnect", this.onDisconnect);
            }
            this.emit("message", {
                type: "connecting"
            });
            const accounts = await provider.request({
                method: "eth_requestAccounts"
            });
            const account = (0, _viem.getAddress)(accounts[0]);
            let id = await this.getChainId();
            let unsupported = this.isChainUnsupported(id);
            if (chainId && id !== chainId) {
                const chain = await this.switchChain(chainId);
                id = chain.id;
                unsupported = this.isChainUnsupported(id);
            }
            if (this.options.shimDisconnect) this.storage?.setItem(this.shimDisconnectKey, true);
            return {
                account,
                chain: {
                    id,
                    unsupported
                }
            };
        } catch (error) {
            if (this.isUserRejectedRequestError(error)) throw new (0, _viem.UserRejectedRequestError)(error);
            if (error.code === -32002) throw new (0, _viem.ResourceUnavailableRpcError)(error);
            throw error;
        }
    }
    async disconnect() {
        const provider = await this.getProvider();
        if (!provider?.removeListener) return;
        provider.removeListener("accountsChanged", this.onAccountsChanged);
        provider.removeListener("chainChanged", this.onChainChanged);
        provider.removeListener("disconnect", this.onDisconnect);
        if (this.options.shimDisconnect) this.storage?.removeItem(this.shimDisconnectKey);
    }
    async getAccount() {
        const provider = await this.getProvider();
        if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
        const accounts = await provider.request({
            method: "eth_accounts"
        });
        return (0, _viem.getAddress)(accounts[0]);
    }
    async getChainId() {
        const provider = await this.getProvider();
        if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
        return provider.request({
            method: "eth_chainId"
        }).then((0, _chunkOQILYQDOJs.normalizeChainId));
    }
    async getProvider() {
        const provider = this.options.getProvider();
        if (provider) (0, _chunkQYMCVNHTJs.__privateSet)(this, _provider, provider);
        return (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider);
    }
    async getWalletClient({ chainId } = {}) {
        const [provider, account] = await Promise.all([
            this.getProvider(),
            this.getAccount()
        ]);
        const chain = this.chains.find((x)=>x.id === chainId);
        if (!provider) throw new Error("provider is required.");
        return (0, _viem.createWalletClient)({
            account,
            chain,
            transport: (0, _viem.custom)(provider)
        });
    }
    async isAuthorized() {
        try {
            if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey)) return false;
            const provider = await this.getProvider();
            if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
            const account = await this.getAccount();
            return !!account;
        } catch  {
            return false;
        }
    }
    async switchChain(chainId) {
        const provider = await this.getProvider();
        if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
        const id = (0, _viem.numberToHex)(chainId);
        try {
            await Promise.all([
                provider.request({
                    method: "wallet_switchEthereumChain",
                    params: [
                        {
                            chainId: id
                        }
                    ]
                }),
                new Promise((res)=>this.on("change", ({ chain })=>{
                        if (chain?.id === chainId) res();
                    }))
            ]);
            return this.chains.find((x)=>x.id === chainId) ?? {
                id: chainId,
                name: `Chain ${id}`,
                network: `${id}`,
                nativeCurrency: {
                    name: "Ether",
                    decimals: 18,
                    symbol: "ETH"
                },
                rpcUrls: {
                    default: {
                        http: [
                            ""
                        ]
                    },
                    public: {
                        http: [
                            ""
                        ]
                    }
                }
            };
        } catch (error) {
            const chain = this.chains.find((x)=>x.id === chainId);
            if (!chain) throw new (0, _chunkZCAPXGBXJs.ChainNotConfiguredForConnectorError)({
                chainId,
                connectorId: this.id
            });
            if (error.code === 4902 || error?.data?.originalError?.code === 4902) try {
                await provider.request({
                    method: "wallet_addEthereumChain",
                    params: [
                        {
                            chainId: id,
                            chainName: chain.name,
                            nativeCurrency: chain.nativeCurrency,
                            rpcUrls: [
                                chain.rpcUrls.public?.http[0] ?? ""
                            ],
                            blockExplorerUrls: this.getBlockExplorerUrls(chain)
                        }
                    ]
                });
                const currentChainId = await this.getChainId();
                if (currentChainId !== chainId) throw new (0, _viem.UserRejectedRequestError)(new Error("User rejected switch after adding network."));
                return chain;
            } catch (error2) {
                throw new (0, _viem.UserRejectedRequestError)(error2);
            }
            if (this.isUserRejectedRequestError(error)) throw new (0, _viem.UserRejectedRequestError)(error);
            throw new (0, _viem.SwitchChainError)(error);
        }
    }
    async watchAsset({ address, decimals = 18, image, symbol }) {
        const provider = await this.getProvider();
        if (!provider) throw new (0, _chunkZCAPXGBXJs.ConnectorNotFoundError)();
        return provider.request({
            method: "wallet_watchAsset",
            params: {
                type: "ERC20",
                options: {
                    address,
                    decimals,
                    image,
                    symbol
                }
            }
        });
    }
    isUserRejectedRequestError(error) {
        return error.code === 4001;
    }
};
_provider = new WeakMap();

},{"./chunk-ZCAPXGBX.js":"4vCxe","./chunk-OQILYQDO.js":"cKx9I","./chunk-QYMCVNHT.js":"h5K6b","viem":"eKtik","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eKtik":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircularReferenceError", ()=>(0, _abitype.CircularReferenceError));
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>(0, _abitype.InvalidAbiParameterError));
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>(0, _abitype.InvalidAbiParametersError));
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>(0, _abitype.InvalidAbiItemError));
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>(0, _abitype.InvalidAbiTypeParameterError));
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>(0, _abitype.InvalidFunctionModifierError));
parcelHelpers.export(exports, "InvalidModifierError", ()=>(0, _abitype.InvalidModifierError));
parcelHelpers.export(exports, "InvalidParameterError", ()=>(0, _abitype.InvalidParameterError));
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>(0, _abitype.InvalidParenthesisError));
parcelHelpers.export(exports, "InvalidSignatureError", ()=>(0, _abitype.InvalidSignatureError));
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>(0, _abitype.InvalidStructSignatureError));
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>(0, _abitype.SolidityProtectedKeywordError));
parcelHelpers.export(exports, "UnknownTypeError", ()=>(0, _abitype.UnknownTypeError));
parcelHelpers.export(exports, "UnknownSignatureError", ()=>(0, _abitype.UnknownSignatureError));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "getContract", ()=>(0, _getContractJs.getContract));
parcelHelpers.export(exports, "createClient", ()=>(0, _createClientJs.createClient));
parcelHelpers.export(exports, "custom", ()=>(0, _customJs.custom));
parcelHelpers.export(exports, "fallback", ()=>(0, _fallbackJs.fallback));
parcelHelpers.export(exports, "http", ()=>(0, _httpJs.http));
parcelHelpers.export(exports, "createPublicClient", ()=>(0, _createPublicClientJs.createPublicClient));
parcelHelpers.export(exports, "createTestClient", ()=>(0, _createTestClientJs.createTestClient));
parcelHelpers.export(exports, "publicActions", ()=>(0, _publicJs.publicActions));
parcelHelpers.export(exports, "testActions", ()=>(0, _testJs.testActions));
parcelHelpers.export(exports, "walletActions", ()=>(0, _walletJs.walletActions));
parcelHelpers.export(exports, "createTransport", ()=>(0, _createTransportJs.createTransport));
parcelHelpers.export(exports, "createWalletClient", ()=>(0, _createWalletClientJs.createWalletClient));
parcelHelpers.export(exports, "webSocket", ()=>(0, _webSocketJs.webSocket));
parcelHelpers.export(exports, "multicall3Abi", ()=>(0, _abisJs.multicall3Abi));
parcelHelpers.export(exports, "etherUnits", ()=>(0, _unitJs.etherUnits));
parcelHelpers.export(exports, "gweiUnits", ()=>(0, _unitJs.gweiUnits));
parcelHelpers.export(exports, "weiUnits", ()=>(0, _unitJs.weiUnits));
parcelHelpers.export(exports, "zeroAddress", ()=>(0, _addressJs.zeroAddress));
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>(0, _abiJs.AbiConstructorNotFoundError));
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>(0, _abiJs.AbiConstructorParamsNotFoundError));
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>(0, _abiJs.AbiDecodingDataSizeInvalidError));
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>(0, _abiJs.AbiDecodingZeroDataError));
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>(0, _abiJs.AbiEncodingArrayLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>(0, _abiJs.AbiEncodingLengthMismatchError));
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>(0, _abiJs.AbiErrorInputsNotFoundError));
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>(0, _abiJs.AbiErrorNotFoundError));
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>(0, _abiJs.AbiErrorSignatureNotFoundError));
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>(0, _abiJs.AbiEventNotFoundError));
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>(0, _abiJs.AbiEventSignatureEmptyTopicsError));
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>(0, _abiJs.AbiEventSignatureNotFoundError));
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>(0, _abiJs.AbiFunctionNotFoundError));
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>(0, _abiJs.AbiFunctionOutputsNotFoundError));
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>(0, _abiJs.AbiFunctionSignatureNotFoundError));
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>(0, _abiJs.DecodeLogTopicsMismatch));
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>(0, _abiJs.InvalidAbiDecodingTypeError));
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>(0, _abiJs.InvalidAbiEncodingTypeError));
parcelHelpers.export(exports, "InvalidArrayError", ()=>(0, _abiJs.InvalidArrayError));
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>(0, _abiJs.InvalidDefinitionTypeError));
parcelHelpers.export(exports, "BaseError", ()=>(0, _baseJs.BaseError));
parcelHelpers.export(exports, "BlockNotFoundError", ()=>(0, _blockJs.BlockNotFoundError));
parcelHelpers.export(exports, "CallExecutionError", ()=>(0, _contractJs.CallExecutionError));
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>(0, _contractJs.ContractFunctionExecutionError));
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>(0, _contractJs.ContractFunctionRevertedError));
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>(0, _contractJs.ContractFunctionZeroDataError));
parcelHelpers.export(exports, "RawContractError", ()=>(0, _contractJs.RawContractError));
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>(0, _rpcJs.ChainDisconnectedError));
parcelHelpers.export(exports, "InternalRpcError", ()=>(0, _rpcJs.InternalRpcError));
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>(0, _rpcJs.InvalidInputRpcError));
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>(0, _rpcJs.InvalidParamsRpcError));
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>(0, _rpcJs.InvalidRequestRpcError));
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>(0, _rpcJs.JsonRpcVersionUnsupportedError));
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>(0, _rpcJs.LimitExceededRpcError));
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>(0, _rpcJs.MethodNotFoundRpcError));
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>(0, _rpcJs.MethodNotSupportedRpcError));
parcelHelpers.export(exports, "ParseRpcError", ()=>(0, _rpcJs.ParseRpcError));
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>(0, _rpcJs.ProviderDisconnectedError));
parcelHelpers.export(exports, "ProviderRpcError", ()=>(0, _rpcJs.ProviderRpcError));
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>(0, _rpcJs.ResourceNotFoundRpcError));
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>(0, _rpcJs.ResourceUnavailableRpcError));
parcelHelpers.export(exports, "RpcError", ()=>(0, _rpcJs.RpcError));
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>(0, _rpcJs.TransactionRejectedRpcError));
parcelHelpers.export(exports, "SwitchChainError", ()=>(0, _rpcJs.SwitchChainError));
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>(0, _rpcJs.UnauthorizedProviderError));
parcelHelpers.export(exports, "UnknownRpcError", ()=>(0, _rpcJs.UnknownRpcError));
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>(0, _rpcJs.UnsupportedProviderMethodError));
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>(0, _rpcJs.UserRejectedRequestError));
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>(0, _chainJs.ChainDoesNotSupportContract));
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>(0, _chainJs.ClientChainNotConfiguredError));
parcelHelpers.export(exports, "InvalidChainIdError", ()=>(0, _chainJs.InvalidChainIdError));
parcelHelpers.export(exports, "DataLengthTooLongError", ()=>(0, _encodingJs.DataLengthTooLongError));
parcelHelpers.export(exports, "DataLengthTooShortError", ()=>(0, _encodingJs.DataLengthTooShortError));
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>(0, _encodingJs.InvalidBytesBooleanError));
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>(0, _encodingJs.InvalidHexBooleanError));
parcelHelpers.export(exports, "InvalidHexValueError", ()=>(0, _encodingJs.InvalidHexValueError));
parcelHelpers.export(exports, "OffsetOutOfBoundsError", ()=>(0, _encodingJs.OffsetOutOfBoundsError));
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>(0, _ensJs.EnsAvatarUriResolutionError));
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>(0, _estimateGasJs.EstimateGasExecutionError));
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>(0, _nodeJs.ExecutionRevertedError));
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>(0, _nodeJs.FeeCapTooHighError));
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>(0, _nodeJs.FeeCapTooLowError));
parcelHelpers.export(exports, "InsufficientFundsError", ()=>(0, _nodeJs.InsufficientFundsError));
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>(0, _nodeJs.IntrinsicGasTooHighError));
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>(0, _nodeJs.IntrinsicGasTooLowError));
parcelHelpers.export(exports, "NonceMaxValueError", ()=>(0, _nodeJs.NonceMaxValueError));
parcelHelpers.export(exports, "NonceTooHighError", ()=>(0, _nodeJs.NonceTooHighError));
parcelHelpers.export(exports, "NonceTooLowError", ()=>(0, _nodeJs.NonceTooLowError));
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>(0, _nodeJs.TipAboveFeeCapError));
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>(0, _nodeJs.TransactionTypeNotSupportedError));
parcelHelpers.export(exports, "UnknownNodeError", ()=>(0, _nodeJs.UnknownNodeError));
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>(0, _logJs.FilterTypeNotSupportedError));
parcelHelpers.export(exports, "HttpRequestError", ()=>(0, _requestJs.HttpRequestError));
parcelHelpers.export(exports, "RpcRequestError", ()=>(0, _requestJs.RpcRequestError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _requestJs.TimeoutError));
parcelHelpers.export(exports, "WebSocketRequestError", ()=>(0, _requestJs.WebSocketRequestError));
parcelHelpers.export(exports, "InvalidAddressError", ()=>(0, _addressJs1.InvalidAddressError));
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>(0, _transactionJs.InvalidLegacyVError));
parcelHelpers.export(exports, "TransactionExecutionError", ()=>(0, _transactionJs.TransactionExecutionError));
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>(0, _transactionJs.TransactionNotFoundError));
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>(0, _transactionJs.TransactionReceiptNotFoundError));
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>(0, _transactionJs.WaitForTransactionReceiptTimeoutError));
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>(0, _dataJs.SizeExceedsPaddingSizeError));
parcelHelpers.export(exports, "UrlRequiredError", ()=>(0, _transportJs.UrlRequiredError));
parcelHelpers.export(exports, "labelhash", ()=>(0, _labelhashJs.labelhash));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehashJs.namehash));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs1.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs1.formatBlock));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs1.formatLog));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeDeployData", ()=>(0, _decodeDeployDataJs.decodeDeployData));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs1.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs1.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs1.transactionType));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "bytesToBigint", ()=>(0, _fromBytesJs.bytesToBigint));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipFetch));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _chainJs1.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _chainJs1.defineChain));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _getEventSelectorJs.getEventSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _getFunctionSelectorJs.getFunctionSelector));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "prepareRequest", ()=>(0, _prepareRequestJs.prepareRequest));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs.validateTypedData));
var _abitype = require("abitype");
var _getContractJs = require("./actions/getContract.js");
var _addChainJs = require("./actions/wallet/addChain.js");
var _callJs = require("./actions/public/call.js");
var _createClientJs = require("./clients/createClient.js");
var _customJs = require("./clients/transports/custom.js");
var _fallbackJs = require("./clients/transports/fallback.js");
var _httpJs = require("./clients/transports/http.js");
var _createPublicClientJs = require("./clients/createPublicClient.js");
var _createTestClientJs = require("./clients/createTestClient.js");
var _publicJs = require("./clients/decorators/public.js");
var _testJs = require("./clients/decorators/test.js");
var _walletJs = require("./clients/decorators/wallet.js");
var _createTransportJs = require("./clients/transports/createTransport.js");
var _createWalletClientJs = require("./clients/createWalletClient.js");
var _webSocketJs = require("./clients/transports/webSocket.js");
var _abisJs = require("./constants/abis.js");
var _unitJs = require("./constants/unit.js");
var _addressJs = require("./constants/address.js");
var _abiJs = require("./errors/abi.js");
var _baseJs = require("./errors/base.js");
var _blockJs = require("./errors/block.js");
var _contractJs = require("./errors/contract.js");
var _rpcJs = require("./errors/rpc.js");
var _chainJs = require("./errors/chain.js");
var _encodingJs = require("./errors/encoding.js");
var _ensJs = require("./errors/ens.js");
var _estimateGasJs = require("./errors/estimateGas.js");
var _nodeJs = require("./errors/node.js");
var _logJs = require("./errors/log.js");
var _requestJs = require("./errors/request.js");
var _addressJs1 = require("./errors/address.js");
var _transactionJs = require("./errors/transaction.js");
var _dataJs = require("./errors/data.js");
var _transportJs = require("./errors/transport.js");
var _labelhashJs = require("./utils/ens/labelhash.js");
var _namehashJs = require("./utils/ens/namehash.js");
var _blockJs1 = require("./utils/formatters/block.js");
var _logJs1 = require("./utils/formatters/log.js");
var _decodeAbiParametersJs = require("./utils/abi/decodeAbiParameters.js");
var _decodeDeployDataJs = require("./utils/abi/decodeDeployData.js");
var _decodeErrorResultJs = require("./utils/abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./utils/abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./utils/abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./utils/abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./utils/abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./utils/abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./utils/abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./utils/abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./utils/abi/encodeFunctionData.js");
var _encodeFunctionResultJs = require("./utils/abi/encodeFunctionResult.js");
var _transactionJs1 = require("./utils/formatters/transaction.js");
var _transactionReceiptJs = require("./utils/formatters/transactionReceipt.js");
var _transactionRequestJs = require("./utils/formatters/transactionRequest.js");
var _getAbiItemJs = require("./utils/abi/getAbiItem.js");
var _getContractAddressJs = require("./utils/address/getContractAddress.js");
var _getSerializedTransactionTypeJs = require("./utils/transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./utils/transaction/getTransactionType.js");
var _hashTypedDataJs = require("./utils/signature/hashTypedData.js");
var _recoverAddressJs = require("./utils/signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./utils/signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./utils/signature/recoverPublicKey.js");
var _recoverTypedDataAddressJs = require("./utils/signature/recoverTypedDataAddress.js");
var _toRlpJs = require("./utils/encoding/toRlp.js");
var _verifyMessageJs = require("./utils/signature/verifyMessage.js");
var _verifyTypedDataJs = require("./utils/signature/verifyTypedData.js");
var _assertRequestJs = require("./utils/transaction/assertRequest.js");
var _assertTransactionJs = require("./utils/transaction/assertTransaction.js");
var _toBytesJs = require("./utils/encoding/toBytes.js");
var _toHexJs = require("./utils/encoding/toHex.js");
var _fromBytesJs = require("./utils/encoding/fromBytes.js");
var _ccipJs = require("./utils/ccip.js");
var _concatJs = require("./utils/data/concat.js");
var _chainJs1 = require("./utils/chain.js");
var _encodePackedJs = require("./utils/abi/encodePacked.js");
var _formatEtherJs = require("./utils/unit/formatEther.js");
var _formatGweiJs = require("./utils/unit/formatGwei.js");
var _formatUnitsJs = require("./utils/unit/formatUnits.js");
var _fromHexJs = require("./utils/encoding/fromHex.js");
var _fromRlpJs = require("./utils/encoding/fromRlp.js");
var _getAddressJs = require("./utils/address/getAddress.js");
var _getContractErrorJs = require("./utils/errors/getContractError.js");
var _getEventSelectorJs = require("./utils/hash/getEventSelector.js");
var _getFunctionSelectorJs = require("./utils/hash/getFunctionSelector.js");
var _hashMessageJs = require("./utils/signature/hashMessage.js");
var _isAddressJs = require("./utils/address/isAddress.js");
var _isAddressEqualJs = require("./utils/address/isAddressEqual.js");
var _isBytesJs = require("./utils/data/isBytes.js");
var _isHashJs = require("./utils/hash/isHash.js");
var _isHexJs = require("./utils/data/isHex.js");
var _keccak256Js = require("./utils/hash/keccak256.js");
var _padJs = require("./utils/data/pad.js");
var _parseEtherJs = require("./utils/unit/parseEther.js");
var _parseGweiJs = require("./utils/unit/parseGwei.js");
var _parseTransactionJs = require("./utils/transaction/parseTransaction.js");
var _parseUnitsJs = require("./utils/unit/parseUnits.js");
var _prepareRequestJs = require("./utils/transaction/prepareRequest.js");
var _serializeAccessListJs = require("./utils/transaction/serializeAccessList.js");
var _serializeTransactionJs = require("./utils/transaction/serializeTransaction.js");
var _sizeJs = require("./utils/data/size.js");
var _sliceJs = require("./utils/data/slice.js");
var _stringifyJs = require("./utils/stringify.js");
var _trimJs = require("./utils/data/trim.js");
var _typedDataJs = require("./utils/typedData.js");

},{"abitype":false,"./actions/getContract.js":"2yaRv","./actions/wallet/addChain.js":"a5HPl","./actions/public/call.js":"8bUID","./clients/createClient.js":false,"./clients/transports/custom.js":"i7BEF","./clients/transports/fallback.js":"6PgHn","./clients/transports/http.js":"hjRtb","./clients/createPublicClient.js":"baY0I","./clients/createTestClient.js":false,"./clients/decorators/public.js":false,"./clients/decorators/test.js":false,"./clients/decorators/wallet.js":false,"./clients/transports/createTransport.js":false,"./clients/createWalletClient.js":"fX3TA","./clients/transports/webSocket.js":"2ZZ0i","./constants/abis.js":false,"./constants/unit.js":false,"./constants/address.js":false,"./errors/abi.js":false,"./errors/base.js":false,"./errors/block.js":false,"./errors/contract.js":"3O0YB","./errors/rpc.js":"lvqvl","./errors/chain.js":false,"./errors/encoding.js":false,"./errors/ens.js":false,"./errors/estimateGas.js":false,"./errors/node.js":false,"./errors/log.js":false,"./errors/request.js":false,"./errors/address.js":false,"./errors/transaction.js":false,"./errors/data.js":false,"./errors/transport.js":false,"./utils/ens/labelhash.js":false,"./utils/ens/namehash.js":false,"./utils/formatters/block.js":false,"./utils/formatters/log.js":false,"./utils/abi/decodeAbiParameters.js":false,"./utils/abi/decodeDeployData.js":false,"./utils/abi/decodeErrorResult.js":false,"./utils/abi/decodeEventLog.js":false,"./utils/abi/decodeFunctionData.js":false,"./utils/abi/decodeFunctionResult.js":false,"./utils/abi/encodeAbiParameters.js":false,"./utils/abi/encodeDeployData.js":false,"./utils/abi/encodeErrorResult.js":false,"./utils/abi/encodeEventTopics.js":false,"./utils/abi/encodeFunctionData.js":false,"./utils/abi/encodeFunctionResult.js":false,"./utils/formatters/transaction.js":false,"./utils/formatters/transactionReceipt.js":false,"./utils/formatters/transactionRequest.js":false,"./utils/abi/getAbiItem.js":false,"./utils/address/getContractAddress.js":false,"./utils/transaction/getSerializedTransactionType.js":false,"./utils/transaction/getTransactionType.js":false,"./utils/signature/hashTypedData.js":false,"./utils/signature/recoverAddress.js":false,"./utils/signature/recoverMessageAddress.js":false,"./utils/signature/recoverPublicKey.js":false,"./utils/signature/recoverTypedDataAddress.js":false,"./utils/encoding/toRlp.js":false,"./utils/signature/verifyMessage.js":false,"./utils/signature/verifyTypedData.js":false,"./utils/transaction/assertRequest.js":false,"./utils/transaction/assertTransaction.js":false,"./utils/encoding/toBytes.js":"jM9VU","./utils/encoding/toHex.js":"67sRi","./utils/encoding/fromBytes.js":false,"./utils/ccip.js":false,"./utils/data/concat.js":false,"./utils/chain.js":false,"./utils/abi/encodePacked.js":false,"./utils/unit/formatEther.js":false,"./utils/unit/formatGwei.js":false,"./utils/unit/formatUnits.js":"1ELmV","./utils/encoding/fromHex.js":"6RbMz","./utils/encoding/fromRlp.js":false,"./utils/address/getAddress.js":"1Wg1M","./utils/errors/getContractError.js":false,"./utils/hash/getEventSelector.js":false,"./utils/hash/getFunctionSelector.js":false,"./utils/signature/hashMessage.js":false,"./utils/address/isAddress.js":"gRnzT","./utils/address/isAddressEqual.js":false,"./utils/data/isBytes.js":false,"./utils/hash/isHash.js":false,"./utils/data/isHex.js":"gOtuZ","./utils/hash/keccak256.js":false,"./utils/data/pad.js":false,"./utils/unit/parseEther.js":"cJwcn","./utils/unit/parseGwei.js":"gKNAM","./utils/transaction/parseTransaction.js":false,"./utils/unit/parseUnits.js":false,"./utils/transaction/prepareRequest.js":false,"./utils/transaction/serializeAccessList.js":false,"./utils/transaction/serializeTransaction.js":false,"./utils/data/size.js":false,"./utils/data/slice.js":false,"./utils/stringify.js":false,"./utils/data/trim.js":"khJVi","./utils/typedData.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2yaRv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.
 *
 * - Docs https://viem.sh/docs/contract/getContract.html
 *
 * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properites every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract.html), [`writeContract`](https://viem.sh/docs/contract/writeContract.html), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas.html), etc.
 *
 * @example
 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const publicClient = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const contract = getContract({
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi([
 *     'function balanceOf(address owner) view returns (uint256)',
 *     'function ownerOf(uint256 tokenId) view returns (address)',
 *     'function totalSupply() view returns (uint256)',
 *   ]),
 *   publicClient,
 * })
 */ parcelHelpers.export(exports, "getContract", ()=>getContract);
/**
 * @internal exporting for testing only
 */ parcelHelpers.export(exports, "getFunctionParameters", ()=>getFunctionParameters);
/**
 * @internal exporting for testing only
 */ parcelHelpers.export(exports, "getEventParameters", ()=>getEventParameters);
var _createContractEventFilterJs = require("./public/createContractEventFilter.js");
var _estimateContractGasJs = require("./public/estimateContractGas.js");
var _readContractJs = require("./public/readContract.js");
var _simulateContractJs = require("./public/simulateContract.js");
var _watchContractEventJs = require("./public/watchContractEvent.js");
var _writeContractJs = require("./wallet/writeContract.js");
function getContract({ abi, address, publicClient, walletClient }) {
    const hasPublicClient = publicClient !== undefined && publicClient !== null;
    const hasWalletClient = walletClient !== undefined && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi){
        if (item.type === "function") {
            if (item.stateMutability === "view" || item.stateMutability === "pure") hasReadFunction = true;
            else hasWriteFunction = true;
        } else if (item.type === "event") hasEvent = true;
        // Exit early if all flags are `true`
        if (hasReadFunction && hasWriteFunction && hasEvent) break;
    }
    if (hasPublicClient) {
        if (hasReadFunction) contract.read = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _readContractJs.readContract)(publicClient, {
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
        if (hasWriteFunction) contract.simulate = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _simulateContractJs.simulateContract)(publicClient, {
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
        if (hasEvent) {
            contract.createEventFilter = new Proxy({}, {
                get (_, eventName) {
                    return (...parameters)=>{
                        const abiEvent = abi.find((x)=>x.type === "event" && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, _createContractEventFilterJs.createContractEventFilter)(publicClient, {
                            abi,
                            address,
                            eventName,
                            args,
                            ...options
                        });
                    };
                }
            });
            contract.watchEvent = new Proxy({}, {
                get (_, eventName) {
                    return (...parameters)=>{
                        const abiEvent = abi.find((x)=>x.type === "event" && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, _watchContractEventJs.watchContractEvent)(publicClient, {
                            abi,
                            address,
                            eventName,
                            args,
                            ...options
                        });
                    };
                }
            });
        }
    }
    if (hasWalletClient) {
        if (hasWriteFunction) contract.write = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _writeContractJs.writeContract)(walletClient, {
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
    }
    if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction) contract.estimateGas = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    const client = publicClient ?? walletClient;
                    return (0, _estimateContractGasJs.estimateContractGas)(client, {
                        abi,
                        address,
                        functionName,
                        args,
                        ...options,
                        account: options.account ?? walletClient.account
                    });
                };
            }
        });
    }
    contract.address = address;
    contract.abi = abi;
    return contract;
}
function getFunctionParameters(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return {
        args,
        options
    };
}
function getEventParameters(values, abiEvent) {
    let hasArgs = false;
    // If first item is array, must be `args`
    if (Array.isArray(values[0])) hasArgs = true;
    else if (values.length === 1) // if event has indexed inputs, must have `args`
    hasArgs = abiEvent.inputs.some((x)=>x.indexed);
    else if (values.length === 2) hasArgs = true;
    const args = hasArgs ? values[0] : undefined;
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return {
        args,
        options
    };
}

},{"./public/createContractEventFilter.js":"g5tcn","./public/estimateContractGas.js":"hpW3E","./public/readContract.js":"cW2al","./public/simulateContract.js":"ephq0","./public/watchContractEvent.js":"gUVqN","./wallet/writeContract.js":"6s57Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g5tcn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).
 *
 * - Docs: https://viem.sh/docs/contract/createContractEventFilter.html
 *
 * @param client - Client to use
 * @param parameters - {@link CreateContractEventFilterParameters}
 * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateContractEventFilterReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createContractEventFilter } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createContractEventFilter(client, {
 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
 * })
 */ parcelHelpers.export(exports, "createContractEventFilter", ()=>createContractEventFilter);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: "eth_newFilter"
    });
    const topics = eventName ? (0, _encodeEventTopicsJs.encodeEventTopics)({
        abi,
        args,
        eventName
    }) : undefined;
    const id = await client.request({
        method: "eth_newFilter",
        params: [
            {
                address,
                fromBlock: typeof fromBlock === "bigint" ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === "bigint" ? (0, _toHexJs.numberToHex)(toBlock) : toBlock,
                topics
            }
        ]
    });
    return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: "event"
    };
}

},{"../../utils/abi/encodeEventTopics.js":"3DslQ","../../utils/encoding/toHex.js":"67sRi","../../utils/filters/createFilterRequestScope.js":"9kxlX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3DslQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeEventTopics", ()=>encodeEventTopics);
var _abiJs = require("../../errors/abi.js");
var _logJs = require("../../errors/log.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _getEventSelectorJs = require("../hash/getEventSelector.js");
var _keccak256Js = require("../hash/keccak256.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
function encodeEventTopics({ abi, eventName, args }) {
    let abiItem = abi[0];
    if (eventName) {
        abiItem = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: eventName
        });
        if (!abiItem) throw new (0, _abiJs.AbiEventNotFoundError)(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
        });
    }
    if (abiItem.type !== "event") throw new (0, _abiJs.AbiEventNotFoundError)(undefined, {
        docsPath: "/docs/contract/encodeEventTopics"
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _getEventSelectorJs.getEventSelector)(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param)=>"indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x)=>args[x.name]) ?? [] : [];
        if (args_.length > 0) topics = indexedInputs?.map((param, i)=>Array.isArray(args_[i]) ? args_[i].map((_, j)=>encodeArg({
                    param,
                    value: args_[i][j]
                })) : args_[i] ? encodeArg({
                param,
                value: args_[i]
            }) : null) ?? [];
    }
    return [
        signature,
        ...topics
    ];
}
function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes") return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) throw new (0, _logJs.FilterTypeNotSupportedError)(param.type);
    return (0, _encodeAbiParametersJs.encodeAbiParameters)([
        param
    ], [
        value
    ]);
}

},{"../../errors/abi.js":"l5DIr","../../errors/log.js":"lRDLH","../encoding/toBytes.js":"jM9VU","../hash/getEventSelector.js":"f36dY","../hash/keccak256.js":"9tbZR","./encodeAbiParameters.js":"9xZxs","./formatAbiItem.js":"02tRX","./getAbiItem.js":"4efUi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l5DIr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>AbiConstructorNotFoundError);
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>AbiConstructorParamsNotFoundError);
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>AbiDecodingDataSizeInvalidError);
parcelHelpers.export(exports, "AbiDecodingDataSizeTooSmallError", ()=>AbiDecodingDataSizeTooSmallError);
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>AbiDecodingZeroDataError);
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>AbiEncodingArrayLengthMismatchError);
parcelHelpers.export(exports, "AbiEncodingBytesSizeMismatchError", ()=>AbiEncodingBytesSizeMismatchError);
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>AbiEncodingLengthMismatchError);
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>AbiErrorInputsNotFoundError);
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>AbiErrorNotFoundError);
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>AbiErrorSignatureNotFoundError);
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>AbiEventSignatureEmptyTopicsError);
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>AbiEventSignatureNotFoundError);
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>AbiEventNotFoundError);
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>AbiFunctionNotFoundError);
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>AbiFunctionOutputsNotFoundError);
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>AbiFunctionSignatureNotFoundError);
parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>BytesSizeMismatchError);
parcelHelpers.export(exports, "DecodeLogDataMismatch", ()=>DecodeLogDataMismatch);
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>DecodeLogTopicsMismatch);
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>InvalidAbiEncodingTypeError);
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>InvalidAbiDecodingTypeError);
parcelHelpers.export(exports, "InvalidArrayError", ()=>InvalidArrayError);
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>InvalidDefinitionTypeError);
parcelHelpers.export(exports, "UnsupportedPackedAbiType", ()=>UnsupportedPackedAbiType);
var _formatAbiItemJs = require("../utils/abi/formatAbiItem.js");
var _sizeJs = require("../utils/data/size.js");
var _baseJs = require("./base.js");
class AbiConstructorNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super([
            "A constructor was not found on the ABI.",
            "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorNotFoundError"
        });
    }
}
class AbiConstructorParamsNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super([
            "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
            "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorParamsNotFoundError"
        });
    }
}
class AbiDecodingDataSizeInvalidError extends (0, _baseJs.BaseError) {
    constructor({ data, size }){
        super([
            `Data size of ${size} bytes is invalid.`,
            "Size must be in increments of 32 bytes (size % 32 === 0)."
        ].join("\n"), {
            metaMessages: [
                `Data: ${data} (${size} bytes)`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingDataSizeInvalidError"
        });
    }
}
class AbiDecodingDataSizeTooSmallError extends (0, _baseJs.BaseError) {
    constructor({ data, params, size }){
        super([
            `Data size of ${size} bytes is too small for given parameters.`
        ].join("\n"), {
            metaMessages: [
                `Params: (${(0, _formatAbiItemJs.formatAbiParams)(params, {
                    includeName: true
                })})`,
                `Data:   ${data} (${size} bytes)`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
class AbiDecodingZeroDataError extends (0, _baseJs.BaseError) {
    constructor(){
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingZeroDataError"
        });
    }
}
class AbiEncodingArrayLengthMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedLength, givenLength, type }){
        super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingArrayLengthMismatchError"
        });
    }
}
class AbiEncodingBytesSizeMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedSize, value }){
        super(`Size of bytes "${value}" (bytes${(0, _sizeJs.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingBytesSizeMismatchError"
        });
    }
}
class AbiEncodingLengthMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedLength, givenLength }){
        super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingLengthMismatchError"
        });
    }
}
class AbiErrorInputsNotFoundError extends (0, _baseJs.BaseError) {
    constructor(errorName, { docsPath }){
        super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            "Cannot encode error result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the inputs exist on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiErrorInputsNotFoundError"
        });
    }
}
class AbiErrorNotFoundError extends (0, _baseJs.BaseError) {
    constructor(errorName, { docsPath } = {}){
        super([
            `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiErrorNotFoundError"
        });
    }
}
class AbiErrorSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded error signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiErrorSignatureNotFoundError"
        });
    }
}
class AbiEventSignatureEmptyTopicsError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super("Cannot extract event signature from empty topics.", {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureEmptyTopicsError"
        });
    }
}
class AbiEventSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded event signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureNotFoundError"
        });
    }
}
class AbiEventNotFoundError extends (0, _baseJs.BaseError) {
    constructor(eventName, { docsPath } = {}){
        super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventNotFoundError"
        });
    }
}
class AbiFunctionNotFoundError extends (0, _baseJs.BaseError) {
    constructor(functionName, { docsPath } = {}){
        super([
            `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionNotFoundError"
        });
    }
}
class AbiFunctionOutputsNotFoundError extends (0, _baseJs.BaseError) {
    constructor(functionName, { docsPath }){
        super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            "Cannot decode function result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionOutputsNotFoundError"
        });
    }
}
class AbiFunctionSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded function signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionSignatureNotFoundError"
        });
    }
}
class BytesSizeMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedSize, givenSize }){
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BytesSizeMismatchError"
        });
    }
}
class DecodeLogDataMismatch extends (0, _baseJs.BaseError) {
    constructor({ abiItem, data, params, size }){
        super([
            `Data size of ${size} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
            metaMessages: [
                `Params: (${(0, _formatAbiItemJs.formatAbiParams)(params, {
                    includeName: true
                })})`,
                `Data:   ${data} (${size} bytes)`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
class DecodeLogTopicsMismatch extends (0, _baseJs.BaseError) {
    constructor({ abiItem, param }){
        super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, _formatAbiItemJs.formatAbiItem)(abiItem, {
                includeName: true
            })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
    }
}
class InvalidAbiEncodingTypeError extends (0, _baseJs.BaseError) {
    constructor(type, { docsPath }){
        super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiEncodingType"
        });
    }
}
class InvalidAbiDecodingTypeError extends (0, _baseJs.BaseError) {
    constructor(type, { docsPath }){
        super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
        ].join("\n"), {
            docsPath
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiDecodingType"
        });
    }
}
class InvalidArrayError extends (0, _baseJs.BaseError) {
    constructor(value){
        super([
            `Value "${value}" is not a valid array.`
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidArrayError"
        });
    }
}
class InvalidDefinitionTypeError extends (0, _baseJs.BaseError) {
    constructor(type){
        super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidDefinitionTypeError"
        });
    }
}
class UnsupportedPackedAbiType extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnsupportedPackedAbiType"
        });
    }
}

},{"../utils/abi/formatAbiItem.js":"02tRX","../utils/data/size.js":"jRUcy","./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"02tRX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatAbiItem", ()=>formatAbiItem);
parcelHelpers.export(exports, "formatAbiParams", ()=>formatAbiParams);
var _abiJs = require("../../errors/abi.js");
function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error") throw new (0, _abiJs.InvalidDefinitionTypeError)(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, {
        includeName
    })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
    if (!params) return "";
    return params.map((param)=>formatAbiParam(param, {
            includeName
        })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) return `(${formatAbiParams(param.components, {
        includeName
    })})${param.type.slice(5)}`;
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
}

},{"../../errors/abi.js":"l5DIr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lRDLH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>FilterTypeNotSupportedError);
var _baseJs = require("./base.js");
class FilterTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FilterTypeNotSupportedError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f36dY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEventSelector", ()=>getEventSelector);
var _hashFunctionJs = require("./hashFunction.js");
const getEventSelector = (event)=>{
    if (typeof event === "string") return (0, _hashFunctionJs.hashFunction)(event);
    return (0, _hashFunctionJs.hashAbiItem)(event);
};

},{"./hashFunction.js":"kisVC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kisVC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashFunction", ()=>hashFunction);
parcelHelpers.export(exports, "hashAbiItem", ()=>hashAbiItem);
var _extractFunctionPartsJs = require("../contract/extractFunctionParts.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("./keccak256.js");
const hash = (value)=>(0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
function hashFunction(def) {
    const name = (0, _extractFunctionPartsJs.extractFunctionName)(def);
    const params = (0, _extractFunctionPartsJs.extractFunctionParams)(def) || [];
    return hash(`${name}(${params.map(({ type })=>type).join(",")})`);
}
function hashAbiItem(def) {
    return hash(`${def.name}(${def.inputs.map(({ type })=>type).join(",")})`);
}

},{"../contract/extractFunctionParts.js":"2V3jC","../encoding/toBytes.js":"jM9VU","./keccak256.js":"9tbZR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2V3jC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractFunctionParts", ()=>extractFunctionParts);
parcelHelpers.export(exports, "extractFunctionName", ()=>extractFunctionName);
parcelHelpers.export(exports, "extractFunctionParams", ()=>extractFunctionParams);
parcelHelpers.export(exports, "extractFunctionType", ()=>extractFunctionType);
const paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
function extractFunctionParts(def) {
    const parts = def.match(paramsRegex);
    const type = parts?.[2] || undefined;
    const name = parts?.[3];
    const params = parts?.[5] || undefined;
    return {
        type,
        name,
        params
    };
}
function extractFunctionName(def) {
    return extractFunctionParts(def).name;
}
function extractFunctionParams(def) {
    const params = extractFunctionParts(def).params;
    const splitParams = params?.split(",").map((x)=>x.trim().split(" "));
    return splitParams?.map((param)=>({
            type: param[0],
            name: param[1] === "indexed" ? param[2] : param[1],
            ...param[1] === "indexed" ? {
                indexed: true
            } : {}
        }));
}
function extractFunctionType(def) {
    return extractFunctionParts(def).type;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tbZR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
var _sha3 = require("@noble/hashes/sha3");
var _isHexJs = require("../data/isHex.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function keccak256(value, to_) {
    const to = to_ || "hex";
    const bytes = (0, _sha3.keccak_256)((0, _isHexJs.isHex)(value, {
        strict: false
    }) ? (0, _toBytesJs.toBytes)(value) : value);
    if (to === "bytes") return bytes;
    return (0, _toHexJs.toHex)(bytes);
}

},{"@noble/hashes/sha3":"cJt9C","../data/isHex.js":"gOtuZ","../encoding/toBytes.js":"jM9VU","../encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJt9C":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("ae71bb61dc34d578");
const _u64_js_1 = require("907ac68ff2e44fc3");
const utils_js_1 = require("b9e2908a2afbeac4");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [
    [],
    [],
    []
];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(10);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta θ
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished) throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 28);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */ exports.sha3_256 = gen(0x06, 136, 32);
exports.sha3_384 = gen(0x06, 104, 48);
exports.sha3_512 = gen(0x06, 72, 64);
exports.keccak_224 = gen(0x01, 144, 28);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */ exports.keccak_256 = gen(0x01, 136, 32);
exports.keccak_384 = gen(0x01, 104, 48);
exports.keccak_512 = gen(0x01, 72, 64);
const genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 16);
exports.shake256 = genShake(0x1f, 136, 32);

},{"ae71bb61dc34d578":"dyuMO","907ac68ff2e44fc3":"69tkj","b9e2908a2afbeac4":"8eiyO"}],"dyuMO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== "function" || typeof hash.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{}],"69tkj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for(let i = 0; i < lst.length; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
exports.split = split;
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l)=>l;
const rotr32L = (h, l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig: exports.toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{}],"8eiyO":[function(require,module,exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use `globalThis.crypto`, but node.js versions earlier than v19 don't
// declare it in global scope. For node.js, package.json#exports field mapping
// rewrites import from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = require("acbb3b357d7a0c6c");
// Cast array to different type
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
if (!exports.isLE) throw new Error("Non little-endian hardware is not supported");
const hexes = Array.from({
    length: 256
}, (v, i)=>i.toString(16).padStart(2, "0"));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'
 */ function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array)) throw new Error("Uint8Array expected");
    let hex = "";
    for(let i = 0; i < uint8a.length; i++)hex += hexes[uint8a[i]];
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])
 */ function hexToBytes(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    if (hex.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async ()=>{};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */ function concatBytes(...arrays) {
    if (!arrays.every((a)=>a instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj)=>Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts))) throw new TypeError("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message)=>hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.
 */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    throw new Error("crypto.getRandomValues must be defined");
}
exports.randomBytes = randomBytes;

},{"acbb3b357d7a0c6c":"ePRDN"}],"ePRDN":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

},{}],"9xZxs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Encodes a list of primitive values into an ABI-encoded hex value.
 */ parcelHelpers.export(exports, "encodeAbiParameters", ()=>encodeAbiParameters);
parcelHelpers.export(exports, "getArrayComponents", ()=>getArrayComponents);
var _abiJs = require("../../errors/abi.js");
var _addressJs = require("../../errors/address.js");
var _isAddressJs = require("../address/isAddress.js");
var _concatJs = require("../data/concat.js");
var _padJs = require("../data/pad.js");
var _sizeJs = require("../data/size.js");
var _sliceJs = require("../data/slice.js");
var _toHexJs = require("../encoding/toHex.js");
function encodeAbiParameters(params, values) {
    if (params.length !== values.length) throw new (0, _abiJs.AbiEncodingLengthMismatchError)({
        expectedLength: params.length,
        givenLength: values.length
    });
    // Prepare the parameters to determine dynamic types to encode.
    const preparedParams = prepareParams({
        params: params,
        values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0) return "0x";
    return data;
}
function prepareParams({ params, values }) {
    const preparedParams = [];
    for(let i = 0; i < params.length; i++)preparedParams.push(prepareParam({
        param: params[i],
        value: values[i]
    }));
    return preparedParams;
}
function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, {
            length,
            param: {
                ...param,
                type
            }
        });
    }
    if (param.type === "tuple") return encodeTuple(value, {
        param: param
    });
    if (param.type === "address") return encodeAddress(value);
    if (param.type === "bool") return encodeBool(value);
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber(value, {
            signed
        });
    }
    if (param.type.startsWith("bytes")) return encodeBytes(value, {
        param
    });
    if (param.type === "string") return encodeString(value);
    throw new (0, _abiJs.InvalidAbiEncodingTypeError)(param.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
    });
}
/////////////////////////////////////////////////////////////////
function encodeParams(preparedParams) {
    // 1. Compute the size of the static part of the parameters.
    let staticSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) staticSize += 32;
        else staticSize += (0, _sizeJs.size)(encoded);
    }
    // 2. Split the parameters into static and dynamic parts.
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticParams.push((0, _toHexJs.numberToHex)(staticSize + dynamicSize, {
                size: 32
            }));
            dynamicParams.push(encoded);
            dynamicSize += (0, _sizeJs.size)(encoded);
        } else staticParams.push(encoded);
    }
    // 3. Concatenate static and dynamic parts.
    return (0, _concatJs.concat)([
        ...staticParams,
        ...dynamicParams
    ]);
}
/////////////////////////////////////////////////////////////////
function encodeAddress(value) {
    if (!(0, _isAddressJs.isAddress)(value)) throw new (0, _addressJs.InvalidAddressError)({
        address: value
    });
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)(value.toLowerCase())
    };
}
function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value)) throw new (0, _abiJs.InvalidArrayError)(value);
    if (!dynamic && value.length !== length) throw new (0, _abiJs.AbiEncodingArrayLengthMismatchError)({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
    });
    let dynamicChild = false;
    const preparedParams = [];
    for(let i = 0; i < value.length; i++){
        const preparedParam = prepareParam({
            param,
            value: value[i]
        });
        if (preparedParam.dynamic) dynamicChild = true;
        preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
            const length = (0, _toHexJs.numberToHex)(preparedParams.length, {
                size: 32
            });
            return {
                dynamic: true,
                encoded: preparedParams.length > 0 ? (0, _concatJs.concat)([
                    length,
                    data
                ]) : length
            };
        }
        if (dynamicChild) return {
            dynamic: true,
            encoded: data
        };
    }
    return {
        dynamic: false,
        encoded: (0, _concatJs.concat)(preparedParams.map(({ encoded })=>encoded))
    };
}
function encodeBytes(value, { param }) {
    const [_, size_] = param.type.split("bytes");
    if (!size_) {
        const partsLength = Math.ceil((0, _sizeJs.size)(value) / 32);
        const parts = [];
        for(let i = 0; i < partsLength; i++)parts.push((0, _padJs.padHex)((0, _sliceJs.slice)(value, i * 32, (i + 1) * 32), {
            dir: "right"
        }));
        return {
            dynamic: true,
            encoded: (0, _concatJs.concat)([
                (0, _padJs.padHex)((0, _toHexJs.numberToHex)((0, _sizeJs.size)(value), {
                    size: 32
                })),
                ...parts
            ])
        };
    }
    if ((0, _sizeJs.size)(value) !== parseInt(size_)) throw new (0, _abiJs.AbiEncodingBytesSizeMismatchError)({
        expectedSize: parseInt(size_),
        value
    });
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)(value, {
            dir: "right"
        })
    };
}
function encodeBool(value) {
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)((0, _toHexJs.boolToHex)(value))
    };
}
function encodeNumber(value, { signed }) {
    return {
        dynamic: false,
        encoded: (0, _toHexJs.numberToHex)(value, {
            size: 32,
            signed
        })
    };
}
function encodeString(value) {
    const hexValue = (0, _toHexJs.stringToHex)(value);
    const partsLength = Math.ceil((0, _sizeJs.size)(hexValue) / 32);
    const parts = [];
    for(let i = 0; i < partsLength; i++)parts.push((0, _padJs.padHex)((0, _sliceJs.slice)(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
    }));
    return {
        dynamic: true,
        encoded: (0, _concatJs.concat)([
            (0, _padJs.padHex)((0, _toHexJs.numberToHex)((0, _sizeJs.size)(hexValue), {
                size: 32
            })),
            ...parts
        ])
    };
}
function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for(let i = 0; i < param.components.length; i++){
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
            param: param_,
            value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic) dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, _concatJs.concat)(preparedParams.map(({ encoded })=>encoded))
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [
        matches[2] ? Number(matches[2]) : null,
        matches[1]
    ] : undefined;
}

},{"../../errors/abi.js":"l5DIr","../../errors/address.js":"4cSuV","../address/isAddress.js":"gRnzT","../data/concat.js":"6Izt3","../data/pad.js":"NSHzf","../data/size.js":"jRUcy","../data/slice.js":"gro9m","../encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4cSuV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidAddressError", ()=>InvalidAddressError);
var _baseJs = require("./base.js");
class InvalidAddressError extends (0, _baseJs.BaseError) {
    constructor({ address }){
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAddressError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gRnzT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAddress", ()=>isAddress);
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(address) {
    return addressRegex.test(address);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Izt3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
parcelHelpers.export(exports, "concatHex", ()=>concatHex);
function concat(values) {
    if (typeof values[0] === "string") return concatHex(values);
    return concatBytes(values);
}
function concatBytes(values) {
    let length = 0;
    for (const arr of values)length += arr.length;
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values){
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
function concatHex(values) {
    return `0x${values.reduce((acc, x)=>acc + x.replace("0x", ""), "")}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gro9m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Returns a section of the hex or byte array given a start/end bytes offset.
 *
 * @param value The hex or byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "slice", ()=>slice);
/**
 * @description Returns a section of the byte array given a start/end bytes offset.
 *
 * @param value The byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "sliceBytes", ()=>sliceBytes);
/**
 * @description Returns a section of the hex value given a start/end bytes offset.
 *
 * @param value The hex value to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "sliceHex", ()=>sliceHex);
var _dataJs = require("../../errors/data.js");
var _isHexJs = require("./isHex.js");
var _sizeJs = require("./size.js");
function slice(value, start, end, { strict } = {}) {
    if ((0, _isHexJs.isHex)(value, {
        strict: false
    })) return sliceHex(value, start, end, {
        strict
    });
    return sliceBytes(value, start, end, {
        strict
    });
}
function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > (0, _sizeJs.size)(value) - 1) throw new (0, _dataJs.SliceOffsetOutOfBoundsError)({
        offset: start,
        position: "start",
        size: (0, _sizeJs.size)(value)
    });
}
function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && (0, _sizeJs.size)(value) !== end - start) throw new (0, _dataJs.SliceOffsetOutOfBoundsError)({
        offset: end,
        position: "end",
        size: (0, _sizeJs.size)(value)
    });
}
function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict) assertEndOffset(value, start, end);
    return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict) assertEndOffset(value, start, end);
    return value;
}

},{"../../errors/data.js":"71w8M","./isHex.js":"gOtuZ","./size.js":"jRUcy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4efUi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAbiItem", ()=>getAbiItem);
parcelHelpers.export(exports, "isArgOfType", ()=>isArgOfType);
var _isAddressJs = require("../address/isAddress.js");
function getAbiItem({ abi, args = [], name }) {
    const abiItems = abi.filter((x)=>"name" in x && x.name === name);
    if (abiItems.length === 0) return undefined;
    if (abiItems.length === 1) return abiItems[0];
    for (const abiItem of abiItems){
        if (!("inputs" in abiItem)) continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;
            continue;
        }
        if (!abiItem.inputs) continue;
        if (abiItem.inputs.length === 0) continue;
        if (abiItem.inputs.length !== args.length) continue;
        const matched = args.every((arg, index)=>{
            const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
            if (!abiParameter) return false;
            return isArgOfType(arg, abiParameter);
        });
        if (matched) return abiItem;
    }
    return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch(abiParameterType){
        case "address":
            return (0, _isAddressJs.isAddress)(arg);
        case "bool":
            return argType === "boolean";
        case "function":
            return argType === "string";
        case "string":
            return argType === "string";
        default:
            if (abiParameterType === "tuple" && "components" in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{
                return isArgOfType(Object.values(arg)[index], component);
            });
            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
            // https://regexr.com/6v8hp
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === "number" || argType === "bigint";
            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
            // https://regexr.com/6va55
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === "string" || arg instanceof Uint8Array;
            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays
            // https://regexr.com/6va6i
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {
                    ...abiParameter,
                    // Pop off `[]` or `[M]` from end of type
                    type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
                }));
            return false;
    }
}

},{"../address/isAddress.js":"gRnzT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kxlX":[function(require,module,exports) {
/**
 * Scopes `request` to the filter ID. If the client is a fallback, it will
 * listen for responses and scope the child transport `request` function
 * to the successful filter ID.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFilterRequestScope", ()=>createFilterRequestScope);
function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback") client.transport.onResponse?.(({ method: method_, response: id, status, transport })=>{
        if (status === "success" && method === method_) requestMap[id] = transport.request;
    });
    return (id)=>requestMap[id] || client.request;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpW3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Estimates the gas required to successfully execute a contract write function call.
 *
 * - Docs: https://viem.sh/docs/contract/estimateContractGas.html
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateContractGasParameters}
 * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateContractGas } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gas = await estimateContractGas(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint() public']),
 *   functionName: 'mint',
 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 * })
 */ parcelHelpers.export(exports, "estimateContractGas", ()=>estimateContractGas);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _estimateGasJs = require("./estimateGas.js");
async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
    const data = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const gas = await (0, _estimateGasJs.estimateGas)(client, {
            data,
            to: address,
            ...request
        });
        return gas;
    } catch (err) {
        const account = request.account ? (0, _parseAccountJs.parseAccount)(request.account) : undefined;
        throw (0, _getContractErrorJs.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: "/docs/contract/simulateContract",
            functionName,
            sender: account?.address
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/errors/getContractError.js":"iYnRt","./estimateGas.js":"cQ1pW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mF64":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseAccount", ()=>parseAccount);
function parseAccount(account) {
    if (typeof account === "string") return {
        address: account,
        type: "json-rpc"
    };
    return account;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b9Kue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeFunctionData", ()=>encodeFunctionData);
var _abiJs = require("../../errors/abi.js");
var _concatJs = require("../data/concat.js");
var _getFunctionSelectorJs = require("../hash/getFunctionSelector.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
function encodeFunctionData({ abi, args, functionName }) {
    let abiItem = abi[0];
    if (functionName) {
        abiItem = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        if (!abiItem) throw new (0, _abiJs.AbiFunctionNotFoundError)(functionName, {
            docsPath: "/docs/contract/encodeFunctionData"
        });
    }
    if (abiItem.type !== "function") throw new (0, _abiJs.AbiFunctionNotFoundError)(undefined, {
        docsPath: "/docs/contract/encodeFunctionData"
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _getFunctionSelectorJs.getFunctionSelector)(definition);
    const data = "inputs" in abiItem && abiItem.inputs ? (0, _encodeAbiParametersJs.encodeAbiParameters)(abiItem.inputs, args ?? []) : undefined;
    return (0, _concatJs.concatHex)([
        signature,
        data ?? "0x"
    ]);
}

},{"../../errors/abi.js":"l5DIr","../data/concat.js":"6Izt3","../hash/getFunctionSelector.js":"eqKLX","./encodeAbiParameters.js":"9xZxs","./formatAbiItem.js":"02tRX","./getAbiItem.js":"4efUi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eqKLX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getFunctionSelector", ()=>getFunctionSelector);
var _sliceJs = require("../data/slice.js");
var _hashFunctionJs = require("./hashFunction.js");
const getFunctionSelector = (fn)=>{
    if (typeof fn === "string") return (0, _sliceJs.slice)((0, _hashFunctionJs.hashFunction)(fn), 0, 4);
    return (0, _sliceJs.slice)((0, _hashFunctionJs.hashAbiItem)(fn), 0, 4);
};

},{"../data/slice.js":"gro9m","./hashFunction.js":"kisVC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYnRt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractError", ()=>getContractError);
var _abiJs = require("../../errors/abi.js");
var _baseJs = require("../../errors/base.js");
var _contractJs = require("../../errors/contract.js");
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
    const { code, data, message, shortMessage } = err instanceof (0, _contractJs.RawContractError) ? err : err instanceof (0, _baseJs.BaseError) ? err.walk((err)=>"data" in err) : {};
    let cause = err;
    if (err instanceof (0, _abiJs.AbiDecodingZeroDataError)) cause = new (0, _contractJs.ContractFunctionZeroDataError)({
        functionName
    });
    else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message || shortMessage)) cause = new (0, _contractJs.ContractFunctionRevertedError)({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
    });
    return new (0, _contractJs.ContractFunctionExecutionError)(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
    });
}

},{"../../errors/abi.js":"l5DIr","../../errors/base.js":"Osf13","../../errors/contract.js":"3O0YB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3O0YB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CallExecutionError", ()=>CallExecutionError);
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>ContractFunctionExecutionError);
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>ContractFunctionRevertedError);
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>ContractFunctionZeroDataError);
parcelHelpers.export(exports, "RawContractError", ()=>RawContractError);
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _solidityJs = require("../constants/solidity.js");
var _decodeErrorResultJs = require("../utils/abi/decodeErrorResult.js");
var _formatAbiItemJs = require("../utils/abi/formatAbiItem.js");
var _formatAbiItemWithArgsJs = require("../utils/abi/formatAbiItemWithArgs.js");
var _getAbiItemJs = require("../utils/abi/getAbiItem.js");
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
var _transactionJs = require("./transaction.js");
var _utilsJs = require("./utils.js");
class CallExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }){
        const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
        const prettyArgs = (0, _transactionJs.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    " "
                ] : [],
                "Raw Call Arguments:",
                prettyArgs
            ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CallExecutionError"
        });
        this.cause = cause;
    }
}
class ContractFunctionExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }){
        const abiItem = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        const formattedArgs = abiItem ? (0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs)({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
        }) : undefined;
        const functionWithParams = abiItem ? (0, _formatAbiItemJs.formatAbiItem)(abiItem, {
            includeName: true
        }) : undefined;
        const prettyArgs = (0, _transactionJs.prettyPrint)({
            address: contractAddress && (0, _utilsJs.getContractAddress)(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== "()" && `${[
                ...Array(functionName?.length ?? 0).keys()
            ].map(()=>" ").join("")}${formattedArgs}`,
            sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    " "
                ] : [],
                "Contract Call:",
                prettyArgs
            ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
    }
}
class ContractFunctionRevertedError extends (0, _baseJs.BaseError) {
    constructor({ abi, data, functionName, message }){
        let decodedData = undefined;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
            decodedData = (0, _decodeErrorResultJs.decodeErrorResult)({
                abi,
                data
            });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") reason = errorArgs[0];
            else if (errorName === "Panic") {
                const [firstArg] = errorArgs;
                reason = (0, _solidityJs.panicReasons)[firstArg];
            } else {
                const errorWithParams = abiItem ? (0, _formatAbiItemJs.formatAbiItem)(abiItem, {
                    includeName: true
                }) : undefined;
                const formattedArgs = abiItem && errorArgs ? (0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs)({
                    abiItem,
                    args: errorArgs,
                    includeFunctionName: false,
                    includeName: false
                }) : undefined;
                metaMessages = [
                    errorWithParams ? `Error: ${errorWithParams}` : "",
                    formattedArgs && formattedArgs !== "()" ? `       ${[
                        ...Array(errorName?.length ?? 0).keys()
                    ].map(()=>" ").join("")}${formattedArgs}` : ""
                ];
            }
        } else if (message) reason = message;
        super(reason && reason !== "execution reverted" ? [
            `The contract function "${functionName}" reverted with the following reason:`,
            reason
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
            metaMessages
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.reason = reason;
        this.data = decodedData;
    }
}
class ContractFunctionZeroDataError extends (0, _baseJs.BaseError) {
    constructor({ functionName }){
        super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
                "This could be due to any of the following:",
                `  - The contract does not have the function "${functionName}",`,
                "  - The parameters passed to the contract function may be invalid, or",
                "  - The address is not a contract."
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionZeroDataError"
        });
    }
}
class RawContractError extends (0, _baseJs.BaseError) {
    constructor({ data, message }){
        super(message || "");
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
    }
}

},{"../accounts/utils/parseAccount.js":"6mF64","../constants/solidity.js":"1ySy2","../utils/abi/decodeErrorResult.js":"1skqX","../utils/abi/formatAbiItem.js":"02tRX","../utils/abi/formatAbiItemWithArgs.js":"bscsz","../utils/abi/getAbiItem.js":"4efUi","../utils/unit/formatEther.js":"2QKZT","../utils/unit/formatGwei.js":"7iM0q","./base.js":"Osf13","./transaction.js":"3UjDK","./utils.js":"58gbo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ySy2":[function(require,module,exports) {
// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "panicReasons", ()=>panicReasons);
parcelHelpers.export(exports, "solidityError", ()=>solidityError);
parcelHelpers.export(exports, "solidityPanic", ()=>solidityPanic);
const panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError = {
    inputs: [
        {
            name: "message",
            type: "string"
        }
    ],
    name: "Error",
    type: "error"
};
const solidityPanic = {
    inputs: [
        {
            name: "reason",
            type: "uint256"
        }
    ],
    name: "Panic",
    type: "error"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1skqX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeErrorResult", ()=>decodeErrorResult);
var _solidityJs = require("../../constants/solidity.js");
var _abiJs = require("../../errors/abi.js");
var _sliceJs = require("../data/slice.js");
var _getFunctionSelectorJs = require("../hash/getFunctionSelector.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
function decodeErrorResult({ abi, data }) {
    const signature = (0, _sliceJs.slice)(data, 0, 4);
    if (signature === "0x") throw new (0, _abiJs.AbiDecodingZeroDataError)();
    const abi_ = [
        ...abi || [],
        (0, _solidityJs.solidityError),
        (0, _solidityJs.solidityPanic)
    ];
    const abiItem = abi_.find((x)=>x.type === "error" && signature === (0, _getFunctionSelectorJs.getFunctionSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!abiItem) throw new (0, _abiJs.AbiErrorSignatureNotFoundError)(signature, {
        docsPath: "/docs/contract/decodeErrorResult"
    });
    return {
        abiItem,
        args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, _decodeAbiParametersJs.decodeAbiParameters)(abiItem.inputs, (0, _sliceJs.slice)(data, 4)) : undefined,
        errorName: abiItem.name
    };
}

},{"../../constants/solidity.js":"1ySy2","../../errors/abi.js":"l5DIr","../data/slice.js":"gro9m","../hash/getFunctionSelector.js":"eqKLX","./decodeAbiParameters.js":"dBdSI","./formatAbiItem.js":"02tRX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBdSI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeAbiParameters", ()=>decodeAbiParameters);
var _abiJs = require("../../errors/abi.js");
var _getAddressJs = require("../address/getAddress.js");
var _sizeJs = require("../data/size.js");
var _sliceJs = require("../data/slice.js");
var _trimJs = require("../data/trim.js");
var _fromHexJs = require("../encoding/fromHex.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
function decodeAbiParameters(params, data) {
    if (data === "0x" && params.length > 0) throw new (0, _abiJs.AbiDecodingZeroDataError)();
    if ((0, _sizeJs.size)(data) && (0, _sizeJs.size)(data) < 32) throw new (0, _abiJs.AbiDecodingDataSizeTooSmallError)({
        data,
        params: params,
        size: (0, _sizeJs.size)(data)
    });
    return decodeParams({
        data,
        params: params
    });
}
function decodeParams({ data, params }) {
    const decodedValues = [];
    let position = 0;
    for(let i = 0; i < params.length; i++){
        if (position >= (0, _sizeJs.size)(data)) throw new (0, _abiJs.AbiDecodingDataSizeTooSmallError)({
            data,
            params,
            size: (0, _sizeJs.size)(data)
        });
        const param = params[i];
        const { consumed, value } = decodeParam({
            data,
            param,
            position
        });
        decodedValues.push(value);
        // Step across the data by the amount of data consumed by this parameter.
        position += consumed;
    }
    return decodedValues;
}
function decodeParam({ data, param, position }) {
    const arrayComponents = (0, _encodeAbiParametersJs.getArrayComponents)(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
            length,
            param: {
                ...param,
                type: type
            },
            position
        });
    }
    if (param.type === "tuple") return decodeTuple(data, {
        param: param,
        position
    });
    if (param.type === "string") return decodeString(data, {
        position
    });
    if (param.type.startsWith("bytes")) return decodeBytes(data, {
        param,
        position
    });
    const value = (0, _sliceJs.slice)(data, position, position + 32, {
        strict: true
    });
    if (param.type.startsWith("uint") || param.type.startsWith("int")) return decodeNumber(value, {
        param
    });
    if (param.type === "address") return decodeAddress(value);
    if (param.type === "bool") return decodeBool(value);
    throw new (0, _abiJs.InvalidAbiDecodingTypeError)(param.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
    });
}
////////////////////////////////////////////////////////////////////
function decodeAddress(value) {
    return {
        consumed: 32,
        value: (0, _getAddressJs.checksumAddress)((0, _sliceJs.slice)(value, -20))
    };
}
function decodeArray(data, { param, length, position }) {
    // If the length of the array is not known in advance (dynamic array),
    // we will need to decode the offset of the array data.
    if (!length) {
        // Get the offset of the array data.
        const offset = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, position, position + 32, {
            strict: true
        }));
        // Get the length of the array from the offset.
        const length = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, offset, offset + 32, {
            strict: true
        }));
        let consumed = 0;
        const value = [];
        for(let i = 0; i < length; ++i){
            const decodedChild = decodeParam({
                data: (0, _sliceJs.slice)(data, offset + 32),
                param,
                position: consumed
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return {
            value,
            consumed: 32
        };
    }
    // If the length of the array is known in advance,
    // and the length of an element deeply nested in the array is not known,
    // we need to decode the offset of the array data.
    if (hasDynamicChild(param)) {
        // Get the child type of the array.
        const arrayComponents = (0, _encodeAbiParametersJs.getArrayComponents)(param.type);
        // If the child type is not known, the array is dynamic.
        const dynamicChild = !arrayComponents?.[0];
        let consumed = 0;
        const value = [];
        for(let i = 0; i < length; ++i){
            const offset = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, position, position + 32, {
                strict: true
            }));
            const decodedChild = decodeParam({
                data: (0, _sliceJs.slice)(data, offset),
                param,
                position: dynamicChild ? consumed : i * 32
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return {
            value,
            consumed: 32
        };
    }
    // If the length of the array is known in advance,
    // and the length of each element in the array is known,
    // the array data is encoded contiguously after the array.
    let consumed = 0;
    const value = [];
    for(let i = 0; i < length; ++i){
        const decodedChild = decodeParam({
            data,
            param,
            position: position + consumed
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
    }
    return {
        value,
        consumed
    };
}
function decodeBool(value) {
    return {
        consumed: 32,
        value: (0, _fromHexJs.hexToBool)(value)
    };
}
function decodeBytes(data, { param, position }) {
    const [_, size] = param.type.split("bytes");
    if (!size) {
        // If we don't have a size, we're dealing with a dynamic-size array
        // so we need to read the offset of the data part first.
        const offset = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, position, position + 32, {
            strict: true
        }));
        const length = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, offset, offset + 32, {
            strict: true
        }));
        // If there is no length, we have zero data.
        if (length === 0) return {
            consumed: 32,
            value: "0x"
        };
        const value = (0, _sliceJs.slice)(data, offset + 32, offset + 32 + length, {
            strict: true
        });
        return {
            consumed: 32,
            value
        };
    }
    const value = (0, _sliceJs.slice)(data, position, position + parseInt(size), {
        strict: true
    });
    return {
        consumed: 32,
        value
    };
}
function decodeNumber(value, { param }) {
    const signed = param.type.startsWith("int");
    const size = parseInt(param.type.split("int")[1] || "256");
    return {
        consumed: 32,
        value: size > 48 ? (0, _fromHexJs.hexToBigInt)(value, {
            signed
        }) : (0, _fromHexJs.hexToNumber)(value, {
            signed
        })
    };
}
function decodeString(data, { position }) {
    const offset = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, position, position + 32, {
        strict: true
    }));
    const length = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, offset, offset + 32, {
        strict: true
    }));
    // If there is no length, we have zero data (empty string).
    if (length === 0) return {
        consumed: 32,
        value: ""
    };
    const value = (0, _fromHexJs.hexToString)((0, _trimJs.trim)((0, _sliceJs.slice)(data, offset + 32, offset + 32 + length, {
        strict: true
    })));
    return {
        consumed: 32,
        value
    };
}
function decodeTuple(data, { param, position }) {
    // Tuples can have unnamed components (i.e. they are arrays), so we must
    // determine whether the tuple is named or unnamed. In the case of a named
    // tuple, the value will be an object where each property is the name of the
    // component. In the case of an unnamed tuple, the value will be an array.
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);
    // Initialize the value to an object or an array, depending on whether the
    // tuple is named or unnamed.
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    // If the tuple has a dynamic child, we must first decode the offset to the
    // tuple data.
    if (hasDynamicChild(param)) {
        const offset = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(data, position, position + 32, {
            strict: true
        }));
        // Decode each component of the tuple, starting at the offset.
        for(let i = 0; i < param.components.length; ++i){
            const component = param.components[i];
            const decodedChild = decodeParam({
                data: (0, _sliceJs.slice)(data, offset),
                param: component,
                position: consumed
            });
            consumed += decodedChild.consumed;
            value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return {
            consumed: 32,
            value
        };
    }
    // If the tuple has static children, we can just decode each component
    // in sequence.
    for(let i = 0; i < param.components.length; ++i){
        const component = param.components[i];
        const decodedChild = decodeParam({
            data,
            param: component,
            position: position + consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
    }
    return {
        consumed,
        value
    };
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string") return true;
    if (type === "bytes") return true;
    if (type.endsWith("[]")) return true;
    if (type === "tuple") return param.components?.some(hasDynamicChild);
    const arrayComponents = (0, _encodeAbiParametersJs.getArrayComponents)(param.type);
    if (arrayComponents && hasDynamicChild({
        ...param,
        type: arrayComponents[1]
    })) return true;
    return false;
}

},{"../../errors/abi.js":"l5DIr","../address/getAddress.js":"1Wg1M","../data/size.js":"jRUcy","../data/slice.js":"gro9m","../data/trim.js":"khJVi","../encoding/fromHex.js":"6RbMz","./encodeAbiParameters.js":"9xZxs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Wg1M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checksumAddress", ()=>checksumAddress);
parcelHelpers.export(exports, "getAddress", ()=>getAddress);
var _addressJs = require("../../errors/address.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _isAddressJs = require("./isAddress.js");
function checksumAddress(address_, chainId) {
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash = (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for(let i = 0; i < 40; i += 2){
        if (hash[i >> 1] >> 4 >= 8 && address[i]) address[i] = address[i].toUpperCase();
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) address[i + 1] = address[i + 1].toUpperCase();
    }
    return `0x${address.join("")}`;
}
function getAddress(address, chainId) {
    if (!(0, _isAddressJs.isAddress)(address)) throw new (0, _addressJs.InvalidAddressError)({
        address
    });
    return checksumAddress(address, chainId);
}

},{"../../errors/address.js":"4cSuV","../encoding/toBytes.js":"jM9VU","../hash/keccak256.js":"9tbZR","./isAddress.js":"gRnzT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bscsz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatAbiItemWithArgs", ()=>formatAbiItemWithArgs);
var _stringifyJs = require("../stringify.js");
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem)) return;
    if (!("inputs" in abiItem)) return;
    if (!abiItem.inputs) return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i)=>`${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, _stringifyJs.stringify)(args[i]) : args[i]}`).join(", ")})`;
}

},{"../stringify.js":"e0Ibk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e0Ibk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringify", ()=>stringify);
const stringify = (value, replacer, space)=>JSON.stringify(value, (key, value_)=>{
        const value = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value) : value;
    }, space);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2QKZT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatEther", ()=>formatEther);
var _unitJs = require("../../constants/unit.js");
var _formatUnitsJs = require("./formatUnits.js");
function formatEther(wei, unit = "wei") {
    return (0, _formatUnitsJs.formatUnits)(wei, (0, _unitJs.etherUnits)[unit]);
}

},{"../../constants/unit.js":"8soM9","./formatUnits.js":"1ELmV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8soM9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "etherUnits", ()=>etherUnits);
parcelHelpers.export(exports, "gweiUnits", ()=>gweiUnits);
parcelHelpers.export(exports, "weiUnits", ()=>weiUnits);
const etherUnits = {
    gwei: 9,
    wei: 18
};
const gweiUnits = {
    ether: -9,
    wei: 9
};
const weiUnits = {
    ether: -18,
    gwei: -9
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1ELmV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatUnits", ()=>formatUnits);
function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative) display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7iM0q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatGwei", ()=>formatGwei);
var _unitJs = require("../../constants/unit.js");
var _formatUnitsJs = require("./formatUnits.js");
function formatGwei(wei, unit = "wei") {
    return (0, _formatUnitsJs.formatUnits)(wei, (0, _unitJs.gweiUnits)[unit]);
}

},{"../../constants/unit.js":"8soM9","./formatUnits.js":"1ELmV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3UjDK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prettyPrint", ()=>prettyPrint);
parcelHelpers.export(exports, "FeeConflictError", ()=>FeeConflictError);
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>InvalidLegacyVError);
parcelHelpers.export(exports, "InvalidSerializableTransactionError", ()=>InvalidSerializableTransactionError);
parcelHelpers.export(exports, "InvalidSerializedTransactionTypeError", ()=>InvalidSerializedTransactionTypeError);
parcelHelpers.export(exports, "InvalidSerializedTransactionError", ()=>InvalidSerializedTransactionError);
parcelHelpers.export(exports, "InvalidStorageKeySizeError", ()=>InvalidStorageKeySizeError);
parcelHelpers.export(exports, "TransactionExecutionError", ()=>TransactionExecutionError);
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>TransactionNotFoundError);
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>TransactionReceiptNotFoundError);
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>WaitForTransactionReceiptTimeoutError);
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value])=>{
        if (value === undefined || value === false) return null;
        return [
            key,
            value
        ];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);
    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
class FeeConflictError extends (0, _baseJs.BaseError) {
    constructor(){
        super([
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
            "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeConflictError"
        });
    }
}
class InvalidLegacyVError extends (0, _baseJs.BaseError) {
    constructor({ v }){
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidLegacyVError"
        });
    }
}
class InvalidSerializableTransactionError extends (0, _baseJs.BaseError) {
    constructor({ transaction }){
        super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
                "Provided Transaction:",
                "{",
                prettyPrint(transaction),
                "}",
                "",
                "To infer the type, either provide:",
                "- a `type` to the Transaction, or",
                "- an EIP-1559 Transaction with `maxFeePerGas`, or",
                "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
                "- a Legacy Transaction with `gasPrice`"
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSerializableTransactionError"
        });
    }
}
class InvalidSerializedTransactionTypeError extends (0, _baseJs.BaseError) {
    constructor({ serializedType }){
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSerializedTransactionType"
        });
        Object.defineProperty(this, "serializedType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedType = serializedType;
    }
}
class InvalidSerializedTransactionError extends (0, _baseJs.BaseError) {
    constructor({ attributes, serializedTransaction, type }){
        const missing = Object.entries(attributes).map(([key, value])=>typeof value === "undefined" ? key : undefined).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
                `Serialized Transaction: "${serializedTransaction}"`,
                missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
            ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSerializedTransactionError"
        });
        Object.defineProperty(this, "serializedTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
    }
}
class InvalidStorageKeySizeError extends (0, _baseJs.BaseError) {
    constructor({ storageKey }){
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStorageKeySizeError"
        });
    }
}
class TransactionExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }){
        const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    " "
                ] : [],
                "Request Arguments:",
                prettyArgs
            ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionExecutionError"
        });
        this.cause = cause;
    }
}
class TransactionNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ blockHash, blockNumber, blockTag, hash, index }){
        let identifier = "Transaction";
        if (blockTag && index !== undefined) identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== undefined) identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== undefined) identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash) identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionNotFoundError"
        });
    }
}
class TransactionReceiptNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ hash }){
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionReceiptNotFoundError"
        });
    }
}
class WaitForTransactionReceiptTimeoutError extends (0, _baseJs.BaseError) {
    constructor({ hash }){
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WaitForTransactionReceiptTimeoutError"
        });
    }
}

},{"../utils/unit/formatEther.js":"2QKZT","../utils/unit/formatGwei.js":"7iM0q","./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ1pW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Estimates the gas necessary to complete a transaction without submitting it to the network.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateGas.html
 * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateGasParameters}
 * @returns The gas estimate (in wei). {@link EstimateGasReturnType}
 *
 * @example
 * import { createPublicClient, http, parseEther } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateGas } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasEstimate = await estimateGas(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: parseEther('1'),
 * })
 */ parcelHelpers.export(exports, "estimateGas", ()=>estimateGas);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getEstimateGasErrorJs = require("../../utils/errors/getEstimateGasError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _prepareRequestJs = require("../../utils/transaction/prepareRequest.js");
async function estimateGas(client, args) {
    const account_ = args.account ?? client.account;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: "/docs/actions/public/estimateGas"
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, _prepareRequestJs.prepareRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        (0, _assertRequestJs.assertRequest)(args);
        const format = client.chain?.formatters?.transactionRequest?.format || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format
            }),
            from: account.address,
            accessList,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        });
        const balance = await client.request({
            method: "eth_estimateGas",
            params: block ? [
                request,
                block
            ] : [
                request
            ]
        });
        return BigInt(balance);
    } catch (err) {
        throw (0, _getEstimateGasErrorJs.getEstimateGasError)(err, {
            ...args,
            account,
            chain: client.chain
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../errors/account.js":"8zVdX","../../utils/encoding/toHex.js":"67sRi","../../utils/errors/getEstimateGasError.js":"1IS0z","../../utils/formatters/extract.js":"dGARJ","../../utils/formatters/transactionRequest.js":"hmBeH","../../utils/transaction/assertRequest.js":"j38hR","../../utils/transaction/prepareRequest.js":"kxDDz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zVdX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountNotFoundError", ()=>AccountNotFoundError);
var _baseJs = require("./base.js");
class AccountNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath } = {}){
        super([
            "Could not find an Account to execute with this Action.",
            "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
            docsPath,
            docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AccountNotFoundError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1IS0z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEstimateGasError", ()=>getEstimateGasError);
var _estimateGasJs = require("../../errors/estimateGas.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getEstimateGasError(err, { docsPath, ...args }) {
    let cause = err;
    if ((0, _getNodeErrorJs.containsNodeError)(err)) cause = (0, _getNodeErrorJs.getNodeError)(err, args);
    return new (0, _estimateGasJs.EstimateGasExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/estimateGas.js":"gVve9","./getNodeError.js":"ejKR4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVve9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>EstimateGasExecutionError);
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
var _transactionJs = require("./transaction.js");
class EstimateGasExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }){
        const prettyArgs = (0, _transactionJs.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    " "
                ] : [],
                "Estimate Gas Arguments:",
                prettyArgs
            ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EstimateGasExecutionError"
        });
        this.cause = cause;
    }
}

},{"../utils/unit/formatEther.js":"2QKZT","../utils/unit/formatGwei.js":"7iM0q","./base.js":"Osf13","./transaction.js":"3UjDK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ejKR4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "containsNodeError", ()=>containsNodeError);
parcelHelpers.export(exports, "getNodeError", ()=>getNodeError);
var _nodeJs = require("../../errors/node.js");
var _requestJs = require("../../errors/request.js");
var _rpcJs = require("../../errors/rpc.js");
function containsNodeError(err) {
    return err instanceof (0, _rpcJs.TransactionRejectedRpcError) || err instanceof (0, _rpcJs.InvalidInputRpcError) || err instanceof (0, _requestJs.RpcRequestError) && err.code === (0, _nodeJs.ExecutionRevertedError).code;
}
function getNodeError(err, args) {
    const message = err.details.toLowerCase();
    if ((0, _nodeJs.FeeCapTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.FeeCapTooHighError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
    });
    else if ((0, _nodeJs.FeeCapTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.FeeCapTooLowError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
    });
    else if ((0, _nodeJs.NonceTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.NonceTooHighError)({
        cause: err,
        nonce: args?.nonce
    });
    else if ((0, _nodeJs.NonceTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.NonceTooLowError)({
        cause: err,
        nonce: args?.nonce
    });
    else if ((0, _nodeJs.NonceMaxValueError).nodeMessage.test(message)) return new (0, _nodeJs.NonceMaxValueError)({
        cause: err,
        nonce: args?.nonce
    });
    else if ((0, _nodeJs.InsufficientFundsError).nodeMessage.test(message)) return new (0, _nodeJs.InsufficientFundsError)({
        cause: err
    });
    else if ((0, _nodeJs.IntrinsicGasTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.IntrinsicGasTooHighError)({
        cause: err,
        gas: args?.gas
    });
    else if ((0, _nodeJs.IntrinsicGasTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.IntrinsicGasTooLowError)({
        cause: err,
        gas: args?.gas
    });
    else if ((0, _nodeJs.TransactionTypeNotSupportedError).nodeMessage.test(message)) return new (0, _nodeJs.TransactionTypeNotSupportedError)({
        cause: err
    });
    else if ((0, _nodeJs.TipAboveFeeCapError).nodeMessage.test(message)) return new (0, _nodeJs.TipAboveFeeCapError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
    else if (message.match((0, _nodeJs.ExecutionRevertedError).nodeMessage) || "code" in err.cause && err.cause?.code === (0, _nodeJs.ExecutionRevertedError).code) return new (0, _nodeJs.ExecutionRevertedError)({
        cause: err,
        message: err.cause.details || err.details
    });
    return new (0, _nodeJs.UnknownNodeError)({
        cause: err.cause.cause
    });
}

},{"../../errors/node.js":"axp7B","../../errors/request.js":"vUxFy","../../errors/rpc.js":"lvqvl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"axp7B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>ExecutionRevertedError);
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>FeeCapTooHighError);
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>FeeCapTooLowError);
parcelHelpers.export(exports, "NonceTooHighError", ()=>NonceTooHighError);
parcelHelpers.export(exports, "NonceTooLowError", ()=>NonceTooLowError);
parcelHelpers.export(exports, "NonceMaxValueError", ()=>NonceMaxValueError);
parcelHelpers.export(exports, "InsufficientFundsError", ()=>InsufficientFundsError);
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>IntrinsicGasTooHighError);
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>IntrinsicGasTooLowError);
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>TransactionTypeNotSupportedError);
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>TipAboveFeeCapError);
parcelHelpers.export(exports, "UnknownNodeError", ()=>UnknownNodeError);
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
/**
 * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go
 *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41
 *
 * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go
 *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46
 *
 * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108
 */ class ExecutionRevertedError extends (0, _baseJs.BaseError) {
    constructor({ cause, message } = {}){
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ExecutionRevertedError"
        });
    }
}
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
});
class FeeCapTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxFeePerGas } = {}){
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooHigh"
        });
    }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxFeePerGas } = {}){
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooLow"
        });
    }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooHighError"
        });
    }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
});
class NonceTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooLowError"
        });
    }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported/
});
class NonceMaxValueError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceMaxValueError"
        });
    }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
});
class InsufficientFundsError extends (0, _baseJs.BaseError) {
    constructor({ cause } = {}){
        super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
            cause,
            metaMessages: [
                "This error could arise when the account does not have enough funds to:",
                " - pay for the total gas fee,",
                " - pay for the value to send.",
                " ",
                "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
                " - `gas` is the amount of gas needed for transaction to execute,",
                " - `gas fee` is the gas fee,",
                " - `value` is the amount of ether to send to the recipient."
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InsufficientFundsError"
        });
    }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds/
});
class IntrinsicGasTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, gas } = {}){
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooHighError"
        });
    }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, gas } = {}){
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooLowError"
        });
    }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor({ cause }){
        super("The transaction type is not supported for this chain.", {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionTypeNotSupportedError"
        });
    }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
});
class TipAboveFeeCapError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}){
        super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TipAboveFeeCapError"
        });
    }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends (0, _baseJs.BaseError) {
    constructor({ cause }){
        super(`An error occurred while executing: ${cause?.message}`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownNodeError"
        });
    }
}

},{"../utils/unit/formatGwei.js":"7iM0q","./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"vUxFy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HttpRequestError", ()=>HttpRequestError);
parcelHelpers.export(exports, "WebSocketRequestError", ()=>WebSocketRequestError);
parcelHelpers.export(exports, "RpcRequestError", ()=>RpcRequestError);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
var _stringifyJs = require("../utils/stringify.js");
var _baseJs = require("./base.js");
var _utilsJs = require("./utils.js");
class HttpRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, details, headers, status, url }){
        super("HTTP request failed.", {
            details,
            metaMessages: [
                status && `Status: ${status}`,
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                body && `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
    }
}
class WebSocketRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, details, url }){
        super("WebSocket request failed.", {
            details,
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WebSocketRequestError"
        });
    }
}
class RpcRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, error, url }){
        super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = error.code;
    }
}
class TimeoutError extends (0, _baseJs.BaseError) {
    constructor({ body, url }){
        super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TimeoutError"
        });
    }
}

},{"../utils/stringify.js":"e0Ibk","./base.js":"Osf13","./utils.js":"58gbo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lvqvl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 *
 * - EIP https://eips.ethereum.org/EIPS/eip-1474
 */ parcelHelpers.export(exports, "RpcError", ()=>RpcError);
/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 *
 * - EIP https://eips.ethereum.org/EIPS/eip-1193
 */ parcelHelpers.export(exports, "ProviderRpcError", ()=>ProviderRpcError);
parcelHelpers.export(exports, "ParseRpcError", ()=>ParseRpcError);
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>InvalidRequestRpcError);
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>MethodNotFoundRpcError);
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>InvalidParamsRpcError);
parcelHelpers.export(exports, "InternalRpcError", ()=>InternalRpcError);
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>InvalidInputRpcError);
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>ResourceNotFoundRpcError);
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>ResourceUnavailableRpcError);
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>TransactionRejectedRpcError);
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>MethodNotSupportedRpcError);
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>LimitExceededRpcError);
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>JsonRpcVersionUnsupportedError);
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>UserRejectedRequestError);
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>UnauthorizedProviderError);
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>UnsupportedProviderMethodError);
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>ProviderDisconnectedError);
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>ChainDisconnectedError);
parcelHelpers.export(exports, "SwitchChainError", ()=>SwitchChainError);
/**
 * Subclass for an unknown RPC error.
 */ parcelHelpers.export(exports, "UnknownRpcError", ()=>UnknownRpcError);
var _baseJs = require("./base.js");
var _requestJs = require("./request.js");
const unknownErrorCode = -1;
class RpcError extends (0, _baseJs.BaseError) {
    constructor(cause, { code, docsPath, metaMessages, shortMessage }){
        super(shortMessage, {
            cause,
            docsPath,
            metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcError"
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof (0, _requestJs.RpcRequestError) ? cause.code : code ?? unknownErrorCode;
    }
}
class ProviderRpcError extends RpcError {
    constructor(cause, options){
        super(cause, options);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = options.data;
    }
}
/**
 * Subclass for a "Parse error" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class ParseRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ParseRpcError.code,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ParseRpcError"
        });
    }
}
Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
});
/**
 * Subclass for a "Invalid request" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class InvalidRequestRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidRequestRpcError.code,
            shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidRequestRpcError"
        });
    }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
});
/**
 * Subclass for a "Method not found" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class MethodNotFoundRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: MethodNotFoundRpcError.code,
            shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotFoundRpcError"
        });
    }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
});
/**
 * Subclass for an "Invalid params" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class InvalidParamsRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidParamsRpcError.code,
            shortMessage: [
                "Invalid parameters were provided to the RPC method.",
                "Double check you have provided the correct parameters."
            ].join("\n")
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParamsRpcError"
        });
    }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
});
/**
 * Subclass for an "Internal error" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class InternalRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InternalRpcError.code,
            shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InternalRpcError"
        });
    }
}
Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
});
/**
 * Subclass for an "Invalid input" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class InvalidInputRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidInputRpcError.code,
            shortMessage: [
                "Missing or invalid parameters.",
                "Double check you have provided the correct parameters."
            ].join("\n")
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidInputRpcError"
        });
    }
}
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
});
/**
 * Subclass for a "Resource not found" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class ResourceNotFoundRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ResourceNotFoundRpcError.code,
            shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
        });
    }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
});
/**
 * Subclass for a "Resource unavailable" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class ResourceUnavailableRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ResourceUnavailableRpcError.code,
            shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceUnavailableRpcError"
        });
    }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
});
/**
 * Subclass for a "Transaction rejected" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class TransactionRejectedRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: TransactionRejectedRpcError.code,
            shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionRejectedRpcError"
        });
    }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
});
/**
 * Subclass for a "Method not supported" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class MethodNotSupportedRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: MethodNotSupportedRpcError.code,
            shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotSupportedRpcError"
        });
    }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
});
/**
 * Subclass for a "Limit exceeded" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class LimitExceededRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: LimitExceededRpcError.code,
            shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "LimitExceededRpcError"
        });
    }
}
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
});
/**
 * Subclass for a "JSON-RPC version not supported" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */ class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause){
        super(cause, {
            code: JsonRpcVersionUnsupportedError.code,
            shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "JsonRpcVersionUnsupportedError"
        });
    }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
});
/**
 * Subclass for a "User Rejected Request" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UserRejectedRequestError.code,
            shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UserRejectedRequestError"
        });
    }
}
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
});
/**
 * Subclass for an "Unauthorized" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnauthorizedProviderError.code,
            shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnauthorizedProviderError"
        });
    }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
});
/**
 * Subclass for an "Unsupported Method" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnsupportedProviderMethodError.code,
            shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnsupportedProviderMethodError"
        });
    }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
});
/**
 * Subclass for an "Disconnected" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: ProviderDisconnectedError.code,
            shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderDisconnectedError"
        });
    }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
});
/**
 * Subclass for an "Chain Disconnected" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: ChainDisconnectedError.code,
            shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDisconnectedError"
        });
    }
}
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
});
/**
 * Subclass for an "Switch Chain" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */ class SwitchChainError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: SwitchChainError.code,
            shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SwitchChainError"
        });
    }
}
Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
});
class UnknownRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            shortMessage: "An unknown RPC error occurred."
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownRpcError"
        });
    }
}

},{"./base.js":"Osf13","./request.js":"vUxFy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGARJ":[function(require,module,exports) {
/**
 * @description Picks out the keys from `value` that exist in the formatter.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extract", ()=>extract);
function extract(value, { format }) {
    if (!format) return {};
    const keys = Object.keys(format({}));
    return keys.reduce((data, key)=>{
        if (value?.hasOwnProperty(key)) data[key] = value[key];
        return data;
    }, {});
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j38hR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertRequest", ()=>assertRequest);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _addressJs = require("../../errors/address.js");
var _nodeJs = require("../../errors/node.js");
var _transactionJs = require("../../errors/transaction.js");
var _isAddressJs = require("../address/isAddress.js");
function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    if (account && !(0, _isAddressJs.isAddress)(account.address)) throw new (0, _addressJs.InvalidAddressError)({
        address: account.address
    });
    if (to && !(0, _isAddressJs.isAddress)(to)) throw new (0, _addressJs.InvalidAddressError)({
        address: to
    });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")) throw new (0, _transactionJs.FeeConflictError)();
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n) throw new (0, _nodeJs.FeeCapTooHighError)({
        maxFeePerGas
    });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new (0, _nodeJs.TipAboveFeeCapError)({
        maxFeePerGas,
        maxPriorityFeePerGas
    });
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../errors/address.js":"4cSuV","../../errors/node.js":"axp7B","../../errors/transaction.js":"3UjDK","../address/isAddress.js":"gRnzT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kxDDz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultTip", ()=>defaultTip);
parcelHelpers.export(exports, "prepareRequest", ()=>prepareRequest);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _estimateGasJs = require("../../actions/public/estimateGas.js");
var _getBlockJs = require("../../actions/public/getBlock.js");
var _getGasPriceJs = require("../../actions/public/getGasPrice.js");
var _getTransactionCountJs = require("../../actions/public/getTransactionCount.js");
var _accountJs = require("../../errors/account.js");
var _baseJs = require("../../errors/base.js");
var _assertRequestJs = require("./assertRequest.js");
const defaultTip = 1500000000n; // 1.5 gwei
async function prepareRequest(client, args) {
    const { account: account_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)();
    const account = (0, _parseAccountJs.parseAccount)(account_);
    const block = await (0, _getBlockJs.getBlock)(client, {
        blockTag: "latest"
    });
    const request = {
        ...args,
        from: account.address
    };
    if (typeof nonce === "undefined") request.nonce = await (0, _getTransactionCountJs.getTransactionCount)(client, {
        address: account.address,
        blockTag: "pending"
    });
    if (block.baseFeePerGas) {
        if (typeof gasPrice !== "undefined") throw new (0, _baseJs.BaseError)("Chain does not support legacy `gasPrice`.");
        // EIP-1559 fees
        if (typeof maxFeePerGas === "undefined") {
            // Set a buffer of 1.2x on top of the base fee to account for fluctuations.
            request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
            request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
        } else {
            if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultTip) throw new (0, _baseJs.BaseError)("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
            request.maxFeePerGas = maxFeePerGas;
            request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
        }
    } else {
        if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined") throw new (0, _baseJs.BaseError)("Chain does not support EIP-1559 fees.");
        // Legacy fees
        if (typeof gasPrice === "undefined") // Set a buffer of 1.2x on top of the base fee to account for fluctuations.
        request.gasPrice = await (0, _getGasPriceJs.getGasPrice)(client) * 120n / 100n;
    }
    if (typeof gas === "undefined") request.gas = await (0, _estimateGasJs.estimateGas)(client, {
        ...request,
        account: {
            address: account.address,
            type: "json-rpc"
        }
    });
    (0, _assertRequestJs.assertRequest)(request);
    return request;
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../actions/public/estimateGas.js":"cQ1pW","../../actions/public/getBlock.js":"eKkgZ","../../actions/public/getGasPrice.js":"gLIMm","../../actions/public/getTransactionCount.js":"8CzRo","../../errors/account.js":"8zVdX","../../errors/base.js":"Osf13","./assertRequest.js":"j38hR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eKkgZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns information about a block at a block number, hash, or tag.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlock.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks
 * - JSON-RPC Methods:
 *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
 *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockParameters}
 * @returns Information about the block. {@link GetBlockReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlock } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const block = await getBlock(client)
 */ parcelHelpers.export(exports, "getBlock", ()=>getBlock);
var _blockJs = require("../../errors/block.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _blockJs1 = require("../../utils/formatters/block.js");
async function getBlock(client, { blockHash, blockNumber, blockTag = "latest", includeTransactions = false } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let block = null;
    if (blockHash) block = await client.request({
        method: "eth_getBlockByHash",
        params: [
            blockHash,
            includeTransactions
        ]
    });
    else block = await client.request({
        method: "eth_getBlockByNumber",
        params: [
            blockNumberHex || blockTag,
            includeTransactions
        ]
    });
    if (!block) throw new (0, _blockJs.BlockNotFoundError)({
        blockHash,
        blockNumber
    });
    const format = client.chain?.formatters?.block?.format || (0, _blockJs1.formatBlock);
    return format(block);
}

},{"../../errors/block.js":"h6LdG","../../utils/encoding/toHex.js":"67sRi","../../utils/formatters/block.js":"iBInX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6LdG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlockNotFoundError", ()=>BlockNotFoundError);
var _baseJs = require("./base.js");
class BlockNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ blockHash, blockNumber }){
        let identifier = "Block";
        if (blockHash) identifier = `Block at hash "${blockHash}"`;
        if (blockNumber) identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BlockNotFoundError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gLIMm":[function(require,module,exports) {
/**
 * Returns the current price of gas (in wei).
 *
 * - Docs: https://viem.sh/docs/actions/public/getGasPrice.html
 * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
 *
 * @param client - Client to use
 * @returns The gas price (in wei). {@link GetGasPriceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getGasPrice } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasPrice = await getGasPrice(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getGasPrice", ()=>getGasPrice);
async function getGasPrice(client) {
    const gasPrice = await client.request({
        method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8CzRo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html
 * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionCountParameters}
 * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionCount } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionCount = await getTransactionCount(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "getTransactionCount", ()=>getTransactionCount);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
        method: "eth_getTransactionCount",
        params: [
            address,
            blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : blockTag
        ]
    });
    return (0, _fromHexJs.hexToNumber)(count);
}

},{"../../utils/encoding/fromHex.js":"6RbMz","../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cW2al":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calls a read-only function on a contract, and returns the response.
 *
 * - Docs: https://viem.sh/docs/contract/readContract.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts
 *
 * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
 *
 * @param client - Client to use
 * @param parameters - {@link ReadContractParameters}
 * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { readContract } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const result = await readContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
 *   functionName: 'balanceOf',
 *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 * })
 * // 424122n
 */ parcelHelpers.export(exports, "readContract", ()=>readContract);
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _callJs = require("./call.js");
async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
    const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const { data } = await (0, _callJs.call)(client, {
            data: calldata,
            to: address,
            ...callRequest
        });
        return (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || "0x"
        });
    } catch (err) {
        throw (0, _getContractErrorJs.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: "/docs/contract/readContract",
            functionName
        });
    }
}

},{"../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/errors/getContractError.js":"iYnRt","./call.js":"8bUID","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gez2c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeFunctionResult", ()=>decodeFunctionResult);
var _abiJs = require("../../errors/abi.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult({ abi, args, functionName, data }) {
    let abiItem = abi[0];
    if (functionName) {
        abiItem = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        if (!abiItem) throw new (0, _abiJs.AbiFunctionNotFoundError)(functionName, {
            docsPath
        });
    }
    if (abiItem.type !== "function") throw new (0, _abiJs.AbiFunctionNotFoundError)(undefined, {
        docsPath
    });
    if (!abiItem.outputs) throw new (0, _abiJs.AbiFunctionOutputsNotFoundError)(abiItem.name, {
        docsPath
    });
    const values = (0, _decodeAbiParametersJs.decodeAbiParameters)(abiItem.outputs, data);
    if (values && values.length > 1) return values;
    if (values && values.length === 1) return values[0];
    return undefined;
}

},{"../../errors/abi.js":"l5DIr","./decodeAbiParameters.js":"dBdSI","./getAbiItem.js":"4efUi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bUID":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Executes a new message call immediately without submitting a transaction to the network.
 *
 * - Docs: https://viem.sh/docs/actions/public/call.html
 * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
 *
 * @param client - Client to use
 * @param parameters - {@link CallParameters}
 * @returns The call data. {@link CallReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { call } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const data = await call(client, {
 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 * })
 */ parcelHelpers.export(exports, "call", ()=>call);
parcelHelpers.export(exports, "getRevertErrorData", ()=>getRevertErrorData);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _abisJs = require("../../constants/abis.js");
var _contractJs = require("../../constants/contract.js");
var _baseJs = require("../../errors/base.js");
var _chainJs = require("../../errors/chain.js");
var _contractJs1 = require("../../errors/contract.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _chainJs1 = require("../../utils/chain.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getCallErrorJs = require("../../utils/errors/getCallError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _createBatchSchedulerJs = require("../../utils/promise/createBatchScheduler.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
async function call(client, args) {
    const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    try {
        (0, _assertRequestJs.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const format = client.chain?.formatters?.transactionRequest?.format || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format
            }),
            from: account?.address,
            accessList,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        });
        if (batch && shouldPerformMulticall({
            request
        })) try {
            return await scheduleMulticall(client, {
                ...request,
                blockNumber,
                blockTag
            });
        } catch (err) {
            if (!(err instanceof (0, _chainJs.ClientChainNotConfiguredError)) && !(err instanceof (0, _chainJs.ChainDoesNotSupportContract))) throw err;
        }
        const response = await client.request({
            method: "eth_call",
            params: block ? [
                request,
                block
            ] : [
                request
            ]
        });
        if (response === "0x") return {
            data: undefined
        };
        return {
            data: response
        };
    } catch (err) {
        const data = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await require("10c177230b1a3e52");
        if (data?.slice(0, 10) === offchainLookupSignature && to) return {
            data: await offchainLookup(client, {
                data,
                to
            })
        };
        throw (0, _getCallErrorJs.getCallError)(err, {
            ...args,
            account,
            chain: client.chain
        });
    }
}
// We only want to perform a scheduled multicall if:
// - The request has calldata,
// - The request has a target address,
// - The target address is not already the aggregate3 signature,
// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).
function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data) return false;
    if (data.startsWith((0, _contractJs.aggregate3Signature))) return false;
    if (!to) return false;
    if (Object.values(request_).filter((x)=>typeof x !== "undefined").length > 0) return false;
    return true;
}
async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
    const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain) throw new (0, _chainJs.ClientChainNotConfiguredError)();
        multicallAddress = (0, _chainJs1.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "multicall3"
        });
    }
    const blockNumberHex = blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch (args) {
            const size = args.reduce((size, { data })=>size + (data.length - 2), 0);
            return size > batchSize * 2;
        },
        fn: async (requests)=>{
            const calls = requests.map((request)=>({
                    allowFailure: true,
                    callData: request.data,
                    target: request.to
                }));
            const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
                abi: (0, _abisJs.multicall3Abi),
                args: [
                    calls
                ],
                functionName: "aggregate3"
            });
            const data = await client.request({
                method: "eth_call",
                params: [
                    {
                        data: calldata,
                        to: multicallAddress
                    },
                    block
                ]
            });
            return (0, _decodeFunctionResultJs.decodeFunctionResult)({
                abi: (0, _abisJs.multicall3Abi),
                args: [
                    calls
                ],
                functionName: "aggregate3",
                data: data || "0x"
            });
        }
    });
    const [{ returnData, success }] = await schedule({
        data,
        to
    });
    if (!success) throw new (0, _contractJs1.RawContractError)({
        data: returnData
    });
    if (returnData === "0x") return {
        data: undefined
    };
    return {
        data: returnData
    };
}
function getRevertErrorData(err) {
    if (!(err instanceof (0, _baseJs.BaseError))) return undefined;
    const error = err.walk();
    return typeof error.data === "object" ? error.data.data : error.data;
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../constants/abis.js":"mYIU4","../../constants/contract.js":"228sC","../../errors/base.js":"Osf13","../../errors/chain.js":"11dLm","../../errors/contract.js":"3O0YB","../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/chain.js":"cruNy","../../utils/encoding/toHex.js":"67sRi","../../utils/errors/getCallError.js":"70ZzY","../../utils/formatters/extract.js":"dGARJ","../../utils/formatters/transactionRequest.js":"hmBeH","../../utils/promise/createBatchScheduler.js":"iJ7xI","../../utils/transaction/assertRequest.js":"j38hR","10c177230b1a3e52":"gdL0j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"mYIU4":[function(require,module,exports) {
/* [Multicall3](https://github.com/mds1/multicall) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicall3Abi", ()=>multicall3Abi);
parcelHelpers.export(exports, "universalResolverAbi", ()=>universalResolverAbi);
parcelHelpers.export(exports, "textResolverAbi", ()=>textResolverAbi);
parcelHelpers.export(exports, "singleAddressResolverAbi", ()=>singleAddressResolverAbi);
parcelHelpers.export(exports, "smartAccountAbi", ()=>smartAccountAbi);
parcelHelpers.export(exports, "universalSignatureValidatorAbi", ()=>universalSignatureValidatorAbi);
const multicall3Abi = [
    {
        inputs: [
            {
                components: [
                    {
                        name: "target",
                        type: "address"
                    },
                    {
                        name: "allowFailure",
                        type: "bool"
                    },
                    {
                        name: "callData",
                        type: "bytes"
                    }
                ],
                name: "calls",
                type: "tuple[]"
            }
        ],
        name: "aggregate3",
        outputs: [
            {
                components: [
                    {
                        name: "success",
                        type: "bool"
                    },
                    {
                        name: "returnData",
                        type: "bytes"
                    }
                ],
                name: "returnData",
                type: "tuple[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
const universalResolverAbi = [
    {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
            {
                name: "name",
                type: "bytes"
            },
            {
                name: "data",
                type: "bytes"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bytes"
            },
            {
                name: "address",
                type: "address"
            }
        ]
    }
];
const textResolverAbi = [
    {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
            {
                name: "name",
                type: "bytes32"
            },
            {
                name: "key",
                type: "string"
            }
        ],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    }
];
const singleAddressResolverAbi = [
    {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [
            {
                name: "name",
                type: "bytes32"
            }
        ],
        outputs: [
            {
                name: "",
                type: "address"
            }
        ]
    }
];
const smartAccountAbi = [
    {
        name: "isValidSignature",
        type: "function",
        stateMutability: "view",
        inputs: [
            {
                name: "hash",
                type: "bytes32"
            },
            {
                name: "signature",
                type: "bytes"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bytes4"
            }
        ]
    }
];
const universalSignatureValidatorAbi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_signer",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"228sC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "aggregate3Signature", ()=>aggregate3Signature);
const aggregate3Signature = "0x82ad56cb";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"70ZzY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCallError", ()=>getCallError);
var _contractJs = require("../../errors/contract.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getCallError(err, { docsPath, ...args }) {
    let cause = err;
    if ((0, _getNodeErrorJs.containsNodeError)(err)) cause = (0, _getNodeErrorJs.getNodeError)(err, args);
    return new (0, _contractJs.CallExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/contract.js":"3O0YB","./getNodeError.js":"ejKR4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJ7xI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createBatchScheduler", ()=>createBatchScheduler);
const schedulerCache = /*#__PURE__*/ new Map();
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0 }) {
    const exec = async ()=>{
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args })=>args);
        if (args.length === 0) return;
        fn(args).then((data)=>{
            scheduler.forEach(({ pendingPromise }, i)=>pendingPromise.resolve?.([
                    data[i],
                    data
                ]));
        }).catch((err)=>{
            scheduler.forEach(({ pendingPromise })=>pendingPromise.reject?.(err));
        });
    };
    const flush = ()=>schedulerCache.delete(id);
    const getBatchedArgs = ()=>getScheduler().map(({ args })=>args);
    const getScheduler = ()=>schedulerCache.get(id) || [];
    const setScheduler = (item)=>schedulerCache.set(id, [
            ...getScheduler(),
            item
        ]);
    return {
        flush,
        async schedule (args) {
            const pendingPromise = {};
            const promise = new Promise((resolve, reject)=>{
                pendingPromise.resolve = resolve;
                pendingPromise.reject = reject;
            });
            const split = shouldSplitBatch?.([
                ...getBatchedArgs(),
                args
            ]);
            if (split) exec();
            const hasActiveScheduler = getScheduler().length > 0;
            if (hasActiveScheduler) {
                setScheduler({
                    args,
                    pendingPromise
                });
                return promise;
            }
            setScheduler({
                args,
                pendingPromise
            });
            setTimeout(exec, wait);
            return promise;
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gdL0j":[function(require,module,exports) {
module.exports = require("5d4860415f1ad305")(require("ad183254a09a0b9a").getBundleURL("UckoE") + "ccip.21178af4.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("5Nyoj"));

},{"5d4860415f1ad305":"61B45","ad183254a09a0b9a":"lgJ39"}],"61B45":[function(require,module,exports) {
"use strict";
var cacheLoader = require("ca2a84f7fa4a3bb0");
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName("script");
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var preloadLink = document.createElement("link");
        preloadLink.href = bundle;
        preloadLink.rel = "preload";
        preloadLink.as = "script";
        document.head.appendChild(preloadLink);
        var script = document.createElement("script");
        script.async = true;
        script.type = "text/javascript";
        script.src = bundle;
        script.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script.onerror = script.onload = null;
            script.remove();
            reject(error);
        };
        script.onload = function() {
            script.onerror = script.onload = null;
            resolve();
        };
        document.getElementsByTagName("head")[0].appendChild(script);
    });
});

},{"ca2a84f7fa4a3bb0":"j49pS"}],"j49pS":[function(require,module,exports) {
"use strict";
var cachedBundles = {};
var cachedPreloads = {};
var cachedPrefetches = {};
function getCache(type) {
    switch(type){
        case "preload":
            return cachedPreloads;
        case "prefetch":
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"ephq0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.
 *
 * - Docs: https://viem.sh/docs/contract/simulateContract.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts
 *
 * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions.
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
 *
 * @param client - Client to use
 * @param parameters - {@link SimulateContractParameters}
 * @returns The simulation result and write request. {@link SimulateContractReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateContract } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const result = await simulateContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),
 *   functionName: 'mint',
 *   args: ['69420'],
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "simulateContract", ()=>simulateContract);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _callJs = require("./call.js");
async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
    const account = callRequest.account ? (0, _parseAccountJs.parseAccount)(callRequest.account) : undefined;
    const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const { data } = await (0, _callJs.call)(client, {
            batch: false,
            data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
            to: address,
            ...callRequest
        });
        const result = (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || "0x"
        });
        return {
            result,
            request: {
                abi,
                address,
                args,
                functionName,
                ...callRequest
            }
        };
    } catch (err) {
        throw (0, _getContractErrorJs.getContractError)(err, {
            abi: abi,
            address,
            args,
            docsPath: "/docs/contract/simulateContract",
            functionName,
            sender: account?.address
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/errors/getContractError.js":"iYnRt","./call.js":"8bUID","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gUVqN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns emitted contract event logs.
 *
 * - Docs: https://viem.sh/docs/contract/watchContractEvent.html
 *
 * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).
 *
 * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchContractEventParameters}
 * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchContractEvent } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchContractEvent(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
 *   eventName: 'Transfer',
 *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
 *   onLogs: (logs) => console.log(logs),
 * })
 */ parcelHelpers.export(exports, "watchContractEvent", ()=>watchContractEvent);
var _getAbiItemJs = require("../../utils/abi/getAbiItem.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _createContractEventFilterJs = require("./createContractEventFilter.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _getLogsJs = require("./getLogs.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const observerId = (0, _stringifyJs.stringify)([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval
    ]);
    const strict = strict_ ?? false;
    return (0, _observeJs.observe)(observerId, {
        onLogs,
        onError
    }, (emit)=>{
        let previousBlockNumber;
        let filter;
        let initialized = false;
        const unwatch = (0, _pollJs.poll)(async ()=>{
            if (!initialized) {
                try {
                    filter = await (0, _createContractEventFilterJs.createContractEventFilter)(client, {
                        abi,
                        address,
                        args,
                        eventName,
                        strict
                    });
                } catch  {}
                initialized = true;
                return;
            }
            try {
                let logs;
                if (filter) logs = await (0, _getFilterChangesJs.getFilterChanges)(client, {
                    filter
                });
                else {
                    // If the filter doesn't exist, we will fall back to use `getLogs`.
                    // The fall back exists because some RPC Providers do not support filters.
                    // Fetch the block number to use for `getLogs`.
                    const blockNumber = await (0, _getBlockNumberJs.getBlockNumber)(client);
                    // If the block number has changed, we will need to fetch the logs.
                    // If the block number doesn't exist, we are yet to reach the first poll interval,
                    // so do not emit any logs.
                    if (previousBlockNumber && previousBlockNumber !== blockNumber) logs = await (0, _getLogsJs.getLogs)(client, {
                        address,
                        args,
                        fromBlock: previousBlockNumber + 1n,
                        toBlock: blockNumber,
                        event: (0, _getAbiItemJs.getAbiItem)({
                            abi,
                            name: eventName
                        })
                    });
                    else logs = [];
                    previousBlockNumber = blockNumber;
                }
                if (logs.length === 0) return;
                if (batch) emit.onLogs(logs);
                else logs.forEach((log)=>emit.onLogs([
                        log
                    ]));
            } catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin: true,
            interval: pollingInterval
        });
        return async ()=>{
            if (filter) await (0, _uninstallFilterJs.uninstallFilter)(client, {
                filter
            });
            unwatch();
        };
    });
}

},{"../../utils/abi/getAbiItem.js":"4efUi","../../utils/observe.js":"5tvm0","../../utils/poll.js":"akoxB","../../utils/stringify.js":"e0Ibk","./createContractEventFilter.js":"g5tcn","./getBlockNumber.js":"8c8Ud","./getFilterChanges.js":"1gr1F","./getLogs.js":"2mlJj","./uninstallFilter.js":"3qnsl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tvm0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "listenersCache", ()=>listenersCache);
parcelHelpers.export(exports, "cleanupCache", ()=>cleanupCache);
/**
 * @description Sets up an observer for a given function. If another function
 * is set up under the same observer id, the function will only be called once
 * for both instances of the observer.
 */ parcelHelpers.export(exports, "observe", ()=>observe);
const listenersCache = /*#__PURE__*/ new Map();
const cleanupCache = /*#__PURE__*/ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = ()=>listenersCache.get(observerId) || [];
    const unsubscribe = ()=>{
        const listeners = getListeners();
        listenersCache.set(observerId, listeners.filter((cb)=>cb.id !== callbackId));
    };
    const unwatch = ()=>{
        const cleanup = cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup) cleanup();
        unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
        ...listeners,
        {
            id: callbackId,
            fns: callbacks
        }
    ]);
    if (listeners && listeners.length > 0) return unwatch;
    const emit = {};
    for(const key in callbacks)emit[key] = (...args)=>{
        const listeners = getListeners();
        if (listeners.length === 0) return;
        listeners.forEach((listener)=>listener.fns[key]?.(...args));
    };
    const cleanup = fn(emit);
    if (typeof cleanup === "function") cleanupCache.set(observerId, cleanup);
    return unwatch;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"akoxB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Polls a function at a specified interval.
 */ parcelHelpers.export(exports, "poll", ()=>poll);
var _waitJs = require("./wait.js");
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = ()=>active = false;
    const watch = async ()=>{
        let data;
        if (emitOnBegin) data = await fn({
            unpoll: unwatch
        });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, _waitJs.wait)(initialWait);
        const poll = async ()=>{
            if (!active) return;
            await fn({
                unpoll: unwatch
            });
            await (0, _waitJs.wait)(interval);
            poll();
        };
        poll();
    };
    watch();
    return unwatch;
}

},{"./wait.js":"daYNk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"daYNk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wait", ()=>wait);
async function wait(time) {
    return new Promise((res)=>setTimeout(res, time));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8c8Ud":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBlockNumberCache", ()=>getBlockNumberCache);
/**
 * Returns the number of the most recent block seen.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks
 * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockNumberParameters}
 * @returns The number of the block. {@link GetBlockNumberReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlockNumber } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const blockNumber = await getBlockNumber(client)
 * // 69420n
 */ parcelHelpers.export(exports, "getBlockNumber", ()=>getBlockNumber);
var _withCacheJs = require("../../utils/promise/withCache.js");
const cacheKey = (id)=>`blockNumber.${id}`;
function getBlockNumberCache(id) {
    return (0, _withCacheJs.getCache)(cacheKey(id));
}
async function getBlockNumber(client, { maxAge = client.pollingInterval } = {}) {
    const blockNumberHex = await (0, _withCacheJs.withCache)(()=>client.request({
            method: "eth_blockNumber"
        }), {
        cacheKey: cacheKey(client.uid),
        maxAge
    });
    return BigInt(blockNumberHex);
}

},{"../../utils/promise/withCache.js":"alSBI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alSBI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "promiseCache", ()=>promiseCache);
parcelHelpers.export(exports, "responseCache", ()=>responseCache);
parcelHelpers.export(exports, "getCache", ()=>getCache);
/**
 * @description Returns the result of a given promise, and caches the result for
 * subsequent invocations against a provided cache key.
 */ parcelHelpers.export(exports, "withCache", ()=>withCache);
const promiseCache = /*#__PURE__*/ new Map();
const responseCache = /*#__PURE__*/ new Map();
function getCache(cacheKey) {
    const buildCache = (cacheKey, cache)=>({
            clear: ()=>cache.delete(cacheKey),
            get: ()=>cache.get(cacheKey),
            set: (data)=>cache.set(cacheKey, data)
        });
    const promise = buildCache(cacheKey, promiseCache);
    const response = buildCache(cacheKey, responseCache);
    return {
        clear: ()=>{
            promise.clear();
            response.clear();
        },
        promise,
        response
    };
}
async function withCache(fn, { cacheKey, maxAge = Infinity }) {
    const cache = getCache(cacheKey);
    // If a response exists in the cache, and it's not expired, return it
    // and do not invoke the promise.
    // If the max age is 0, the cache is disabled.
    const response = cache.response.get();
    if (response && maxAge > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < maxAge) return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
        promise = fn();
        // Store the promise in the cache so that subsequent invocations
        // will wait for the same promise to resolve (deduping).
        cache.promise.set(promise);
    }
    try {
        const data = await promise;
        // Store the response in the cache so that subsequent invocations
        // will return the same response.
        cache.response.set({
            created: new Date(),
            data
        });
        return data;
    } finally{
        // Clear the promise cache so that subsequent invocations will
        // invoke the promise again.
        cache.promise.clear();
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1gr1F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html
 * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)
 *
 * A Filter can be created from the following actions:
 *
 * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)
 * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html)
 * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)
 * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)
 *
 * Depending on the type of filter, the return value will be different:
 *
 * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.
 * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.
 * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.
 *
 * @param client - Client to use
 * @param parameters - {@link GetFilterChangesParameters}
 * @returns Logs or hashes. {@link GetFilterChangesReturnType}
 *
 * @example
 * // Blocks
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createBlockFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createBlockFilter(client)
 * const hashes = await getFilterChanges(client, { filter })
 *
 * @example
 * // Contract Events
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createContractEventFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createContractEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
 *   eventName: 'Transfer',
 * })
 * const logs = await getFilterChanges(client, { filter })
 *
 * @example
 * // Raw Events
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
 * })
 * const logs = await getFilterChanges(client, { filter })
 *
 * @example
 * // Transactions
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createPendingTransactionFilter(client)
 * const hashes = await getFilterChanges(client, { filter })
 */ parcelHelpers.export(exports, "getFilterChanges", ()=>getFilterChanges);
var _abiJs = require("../../errors/abi.js");
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _logJs = require("../../utils/formatters/log.js");
async function getFilterChanges(_client, { filter }) {
    const strict = "strict" in filter && filter.strict;
    const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [
            filter.id
        ]
    });
    return logs.map((log)=>{
        if (typeof log === "string") return log;
        try {
            const { eventName, args } = "abi" in filter && filter.abi ? (0, _decodeEventLogJs.decodeEventLog)({
                abi: filter.abi,
                data: log.data,
                topics: log.topics,
                strict
            }) : {
                eventName: undefined,
                args: undefined
            };
            return (0, _logJs.formatLog)(log, {
                args,
                eventName
            });
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if ("strict" in filter && filter.strict) return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!("name" in x && x.name));
            }
            // Set args undefined if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return (0, _logJs.formatLog)(log, {
                args: isUnnamed ? [] : {},
                eventName
            });
        }
    }).filter(Boolean);
}

},{"../../errors/abi.js":"l5DIr","../../utils/abi/decodeEventLog.js":"htH60","../../utils/formatters/log.js":"7uIcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"htH60":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeEventLog", ()=>decodeEventLog);
var _abiJs = require("../../errors/abi.js");
var _getEventSelectorJs = require("../hash/getEventSelector.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
const docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog({ abi, data, strict: strict_, topics }) {
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature) throw new (0, _abiJs.AbiEventSignatureEmptyTopicsError)({
        docsPath
    });
    const abiItem = abi.find((x)=>x.type === "event" && signature === (0, _getEventSelectorJs.getEventSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event") throw new (0, _abiJs.AbiEventSignatureNotFoundError)(signature, {
        docsPath
    });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x)=>!("name" in x && x.name));
    let args = isUnnamed ? [] : {};
    // Decode topics (indexed args).
    const indexedInputs = inputs.filter((x)=>"indexed" in x && x.indexed);
    if (argTopics.length > 0) for(let i = 0; i < indexedInputs.length; i++){
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic) throw new (0, _abiJs.DecodeLogTopicsMismatch)({
            abiItem,
            param: param
        });
        args[param.name || i] = decodeTopic({
            param,
            value: topic
        });
    }
    // Decode data (non-indexed args).
    const nonIndexedInputs = inputs.filter((x)=>!("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") try {
            const decodedData = (0, _decodeAbiParametersJs.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
                if (isUnnamed) args = [
                    ...args,
                    ...decodedData
                ];
                else for(let i = 0; i < nonIndexedInputs.length; i++)args[nonIndexedInputs[i].name] = decodedData[i];
            }
        } catch (err) {
            if (strict) {
                if (err instanceof (0, _abiJs.AbiDecodingDataSizeTooSmallError)) throw new (0, _abiJs.DecodeLogDataMismatch)({
                    abiItem,
                    data: err.data,
                    params: err.params,
                    size: err.size
                });
                throw err;
            }
        }
        else if (strict) throw new (0, _abiJs.DecodeLogDataMismatch)({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
        });
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined
    };
}
function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) return value;
    const decodedArg = (0, _decodeAbiParametersJs.decodeAbiParameters)([
        param
    ], value) || [];
    return decodedArg[0];
}

},{"../../errors/abi.js":"l5DIr","../hash/getEventSelector.js":"f36dY","./decodeAbiParameters.js":"dBdSI","./formatAbiItem.js":"02tRX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2mlJj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs matching the provided parameters.
 *
 * - Docs: https://viem.sh/docs/actions/public/getLogs.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetLogsParameters}
 * @returns A list of event logs. {@link GetLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getLogs(client)
 */ parcelHelpers.export(exports, "getLogs", ()=>getLogs);
var _abiJs = require("../../errors/abi.js");
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _logJs = require("../../utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    let topics = [];
    if (event) topics = (0, _encodeEventTopicsJs.encodeEventTopics)({
        abi: [
            event
        ],
        eventName: event.name,
        args
    });
    let logs;
    if (blockHash) logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                blockHash
            }
        ]
    });
    else logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                fromBlock: typeof fromBlock === "bigint" ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === "bigint" ? (0, _toHexJs.numberToHex)(toBlock) : toBlock
            }
        ]
    });
    return logs.map((log)=>{
        try {
            const { eventName, args } = event ? (0, _decodeEventLogJs.decodeEventLog)({
                abi: [
                    event
                ],
                data: log.data,
                topics: log.topics,
                strict
            }) : {
                eventName: undefined,
                args: undefined
            };
            return (0, _logJs.formatLog)(log, {
                args,
                eventName
            });
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if (strict) return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!("name" in x && x.name));
            }
            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return (0, _logJs.formatLog)(log, {
                args: isUnnamed ? [] : {},
                eventName
            });
        }
    }).filter(Boolean);
}

},{"../../errors/abi.js":"l5DIr","../../utils/abi/decodeEventLog.js":"htH60","../../utils/abi/encodeEventTopics.js":"3DslQ","../../utils/encoding/toHex.js":"67sRi","../../utils/formatters/log.js":"7uIcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3qnsl":[function(require,module,exports) {
/**
 * Destroys a [`Filter`](https://viem.sh/docs/glossary/types.html#filter).
 *
 * - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html
 * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)
 *
 * Destroys a Filter that was created from one of the following Actions:
 * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)
 * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)
 * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)
 *
 * @param client - Client to use
 * @param parameters - {@link UninstallFilterParameters}
 * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'
 *
 * const filter = await createPendingTransactionFilter(client)
 * const uninstalled = await uninstallFilter(client, { filter })
 * // true
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uninstallFilter", ()=>uninstallFilter);
async function uninstallFilter(_client, { filter }) {
    return filter.request({
        method: "eth_uninstallFilter",
        params: [
            filter.id
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6s57Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Executes a write function on a contract.
 *
 * - Docs: https://viem.sh/docs/contract/writeContract.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts
 *
 * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.
 *
 * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).
 *
 * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__
 *
 * @param client - Client to use
 * @param parameters - {@link WriteContractParameters}
 * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}
 *
 * @example
 * import { createWalletClient, custom, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await writeContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * })
 *
 * @example
 * // With Validation
 * import { createWalletClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateContract, writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const { request } = await simulateContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * }
 * const hash = await writeContract(client, request)
 */ parcelHelpers.export(exports, "writeContract", ()=>writeContract);
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _sendTransactionJs = require("./sendTransaction.js");
async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
    const data = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    const hash = await (0, _sendTransactionJs.sendTransaction)(client, {
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
    });
    return hash;
}

},{"../../utils/abi/encodeFunctionData.js":"b9Kue","./sendTransaction.js":"c6D87","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c6D87":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates, signs, and sends a new transaction to the network.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
 *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
 *
 * @param client - Client to use
 * @param parameters - {@link SendTransactionParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await sendTransaction(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x…'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await sendTransaction(client, {
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 */ parcelHelpers.export(exports, "sendTransaction", ()=>sendTransaction);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _chainJs = require("../../utils/chain.js");
var _getTransactionErrorJs = require("../../utils/errors/getTransactionError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _prepareRequestJs = require("../../utils/transaction/prepareRequest.js");
var _getChainIdJs = require("../public/getChainId.js");
async function sendTransaction(client, args) {
    const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: "/docs/actions/wallet/sendTransaction"
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    try {
        (0, _assertRequestJs.assertRequest)(args);
        let chainId;
        if (chain !== null) {
            chainId = await (0, _getChainIdJs.getChainId)(client);
            (0, _chainJs.assertCurrentChain)({
                currentChainId: chainId,
                chain
            });
        }
        if (account.type === "local") {
            // Prepare the request for signing (assign appropriate fees, etc.)
            const request = await (0, _prepareRequestJs.prepareRequest)(client, {
                account,
                accessList,
                chain,
                data,
                gas,
                gasPrice,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
                ...rest
            });
            if (!chainId) chainId = await (0, _getChainIdJs.getChainId)(client);
            const serializer = chain?.serializers?.transaction;
            const signedRequest = await account.signTransaction({
                ...request,
                chainId
            }, {
                serializer
            });
            return await client.request({
                method: "eth_sendRawTransaction",
                params: [
                    signedRequest
                ]
            });
        }
        const format = chain?.formatters?.transactionRequest?.format || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format
            }),
            accessList,
            data,
            from: account.address,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        });
        return await client.request({
            method: "eth_sendTransaction",
            params: [
                request
            ]
        });
    } catch (err) {
        throw (0, _getTransactionErrorJs.getTransactionError)(err, {
            ...args,
            account,
            chain: args.chain || undefined
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../errors/account.js":"8zVdX","../../utils/chain.js":"cruNy","../../utils/errors/getTransactionError.js":"jEPgp","../../utils/formatters/extract.js":"dGARJ","../../utils/formatters/transactionRequest.js":"hmBeH","../../utils/transaction/assertRequest.js":"j38hR","../../utils/transaction/prepareRequest.js":"kxDDz","../public/getChainId.js":"gyNal","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jEPgp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTransactionError", ()=>getTransactionError);
var _transactionJs = require("../../errors/transaction.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getTransactionError(err, { docsPath, ...args }) {
    let cause = err;
    if ((0, _getNodeErrorJs.containsNodeError)(err)) cause = (0, _getNodeErrorJs.getNodeError)(err, args);
    return new (0, _transactionJs.TransactionExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/transaction.js":"3UjDK","./getNodeError.js":"ejKR4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gyNal":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the chain ID associated with the current network.
 *
 * - Docs: https://viem.sh/docs/actions/public/getChainId.html
 * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
 *
 * @param client - Client to use
 * @returns The current chain ID. {@link GetChainIdReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getChainId } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const chainId = await getChainId(client)
 * // 1
 */ parcelHelpers.export(exports, "getChainId", ()=>getChainId);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
async function getChainId(client) {
    const chainIdHex = await client.request({
        method: "eth_chainId"
    });
    return (0, _fromHexJs.hexToNumber)(chainIdHex);
}

},{"../../utils/encoding/fromHex.js":"6RbMz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a5HPl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/addChain.html
 * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
 *
 * @param client - Client to use
 * @param parameters - {@link AddChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { optimism } from 'viem/chains'
 * import { addChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   transport: custom(window.ethereum),
 * })
 * await addChain(client, { chain: optimism })
 */ parcelHelpers.export(exports, "addChain", ()=>addChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: "wallet_addEthereumChain",
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url })=>url) : undefined
            }
        ]
    });
}

},{"../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2JKGW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a base client with the given transport.
 */ parcelHelpers.export(exports, "createClient", ()=>createClient);
var _accountsJs = require("../utils/accounts.js");
var _uidJs = require("../utils/uid.js");
function createClient({ account, batch, chain, key = "base", name = "Base Client", pollingInterval = 4000, transport, type = "base" }) {
    const { config, request, value } = transport({
        chain,
        pollingInterval
    });
    const client = {
        account: account ? (0, _accountsJs.parseAccount)(account) : undefined,
        batch,
        chain: chain,
        key,
        name,
        pollingInterval,
        request,
        transport: {
            ...config,
            ...value
        },
        type,
        uid: (0, _uidJs.uid)()
    };
    function extend(client_) {
        return (fn)=>{
            const extended = fn(client_);
            for(const key in client)delete extended[key];
            const nextClient = {
                ...client_,
                ...extended
            };
            return Object.assign(nextClient, {
                extend: extend(nextClient)
            });
        };
    }
    return Object.assign(client, {
        extend: extend(client)
    });
}

},{"../utils/accounts.js":"fru7A","../utils/uid.js":"gjM2C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fru7A":[function(require,module,exports) {
// Tree-shaking doesn't work well when we import from an index entrypoint. We don't
// want to bundle libs like `@noble/curves`, etc within the `/accounts` entrypoint
// as that will dramatically increase bundle size. So we export the modules directly.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseAccount", ()=>(0, _parseAccountJs.parseAccount));
parcelHelpers.export(exports, "publicKeyToAddress", ()=>(0, _publicKeyToAddressJs.publicKeyToAddress));
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _publicKeyToAddressJs = require("../accounts/utils/publicKeyToAddress.js");

},{"../accounts/utils/parseAccount.js":"6mF64","../accounts/utils/publicKeyToAddress.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gjM2C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uid", ()=>uid);
const size = 256;
let index = size;
let buffer;
function uid(length = 11) {
    if (!buffer || index + length > size * 2) {
        buffer = "";
        index = 0;
        for(let i = 0; i < size; i++)buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
    return buffer.substring(index, index++ + length);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i7BEF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.
 */ parcelHelpers.export(exports, "custom", ()=>custom);
var _createTransportJs = require("./createTransport.js");
function custom(provider, config = {}) {
    const { key = "custom", name = "Custom Provider", retryDelay } = config;
    return ({ retryCount: defaultRetryCount })=>(0, _createTransportJs.createTransport)({
            key,
            name,
            request: provider.request.bind(provider),
            retryCount: config.retryCount ?? defaultRetryCount,
            retryDelay,
            type: "custom"
        });
}

},{"./createTransport.js":"cUQ8K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cUQ8K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates an transport intended to be used with a client.
 */ parcelHelpers.export(exports, "createTransport", ()=>createTransport);
var _buildRequestJs = require("../../utils/buildRequest.js");
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    return {
        config: {
            key,
            name,
            request,
            retryCount,
            retryDelay,
            timeout,
            type
        },
        request: (0, _buildRequestJs.buildRequest)(request, {
            retryCount,
            retryDelay
        }),
        value
    };
}

},{"../../utils/buildRequest.js":"dXPq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dXPq5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isDeterministicError", ()=>isDeterministicError);
parcelHelpers.export(exports, "buildRequest", ()=>buildRequest);
var _baseJs = require("../errors/base.js");
var _requestJs = require("../errors/request.js");
var _rpcJs = require("../errors/rpc.js");
var _withRetryJs = require("./promise/withRetry.js");
const isDeterministicError = (error)=>{
    if ("code" in error) return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
    if (error instanceof (0, _requestJs.HttpRequestError) && error.status) return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
    return false;
};
function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
    return async (args)=>(0, _withRetryJs.withRetry)(async ()=>{
            try {
                return await request(args);
            } catch (err_) {
                const err = err_;
                switch(err.code){
                    // -32700
                    case (0, _rpcJs.ParseRpcError).code:
                        throw new (0, _rpcJs.ParseRpcError)(err);
                    // -32600
                    case (0, _rpcJs.InvalidRequestRpcError).code:
                        throw new (0, _rpcJs.InvalidRequestRpcError)(err);
                    // -32601
                    case (0, _rpcJs.MethodNotFoundRpcError).code:
                        throw new (0, _rpcJs.MethodNotFoundRpcError)(err);
                    // -32602
                    case (0, _rpcJs.InvalidParamsRpcError).code:
                        throw new (0, _rpcJs.InvalidParamsRpcError)(err);
                    // -32603
                    case (0, _rpcJs.InternalRpcError).code:
                        throw new (0, _rpcJs.InternalRpcError)(err);
                    // -32000
                    case (0, _rpcJs.InvalidInputRpcError).code:
                        throw new (0, _rpcJs.InvalidInputRpcError)(err);
                    // -32001
                    case (0, _rpcJs.ResourceNotFoundRpcError).code:
                        throw new (0, _rpcJs.ResourceNotFoundRpcError)(err);
                    // -32002
                    case (0, _rpcJs.ResourceUnavailableRpcError).code:
                        throw new (0, _rpcJs.ResourceUnavailableRpcError)(err);
                    // -32003
                    case (0, _rpcJs.TransactionRejectedRpcError).code:
                        throw new (0, _rpcJs.TransactionRejectedRpcError)(err);
                    // -32004
                    case (0, _rpcJs.MethodNotSupportedRpcError).code:
                        throw new (0, _rpcJs.MethodNotSupportedRpcError)(err);
                    // -32005
                    case (0, _rpcJs.LimitExceededRpcError).code:
                        throw new (0, _rpcJs.LimitExceededRpcError)(err);
                    // -32006
                    case (0, _rpcJs.JsonRpcVersionUnsupportedError).code:
                        throw new (0, _rpcJs.JsonRpcVersionUnsupportedError)(err);
                    // 4001
                    case (0, _rpcJs.UserRejectedRequestError).code:
                        throw new (0, _rpcJs.UserRejectedRequestError)(err);
                    // 4100
                    case (0, _rpcJs.UnauthorizedProviderError).code:
                        throw new (0, _rpcJs.UnauthorizedProviderError)(err);
                    // 4200
                    case (0, _rpcJs.UnsupportedProviderMethodError).code:
                        throw new (0, _rpcJs.UnsupportedProviderMethodError)(err);
                    // 4900
                    case (0, _rpcJs.ProviderDisconnectedError).code:
                        throw new (0, _rpcJs.ProviderDisconnectedError)(err);
                    // 4901
                    case (0, _rpcJs.ChainDisconnectedError).code:
                        throw new (0, _rpcJs.ChainDisconnectedError)(err);
                    // 4902
                    case (0, _rpcJs.SwitchChainError).code:
                        throw new (0, _rpcJs.SwitchChainError)(err);
                    default:
                        if (err_ instanceof (0, _baseJs.BaseError)) throw err_;
                        throw new (0, _rpcJs.UnknownRpcError)(err);
                }
            }
        }, {
            delay: ({ count, error })=>{
                // If we find a Retry-After header, let's retry after the given time.
                if (error && error instanceof (0, _requestJs.HttpRequestError)) {
                    const retryAfter = error?.headers?.get("Retry-After");
                    if (retryAfter?.match(/\d/)) return parseInt(retryAfter) * 1000;
                }
                // Otherwise, let's retry with an exponential backoff.
                return ~~(1 << count) * retryDelay;
            },
            retryCount,
            shouldRetry: ({ error })=>!isDeterministicError(error)
        });
}

},{"../errors/base.js":"Osf13","../errors/request.js":"vUxFy","../errors/rpc.js":"lvqvl","./promise/withRetry.js":"k5h7H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5h7H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withRetry", ()=>withRetry);
var _waitJs = require("../wait.js");
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = ()=>true } = {}) {
    return new Promise((resolve, reject)=>{
        const attemptRetry = async ({ count = 0 } = {})=>{
            const retry = async ({ error })=>{
                const delay = typeof delay_ === "function" ? delay_({
                    count,
                    error
                }) : delay_;
                if (delay) await (0, _waitJs.wait)(delay);
                attemptRetry({
                    count: count + 1
                });
            };
            try {
                const data = await fn();
                resolve(data);
            } catch (err) {
                if (count < retryCount && await shouldRetry({
                    count,
                    error: err
                })) return retry({
                    error: err
                });
                reject(err);
            }
        };
        attemptRetry();
    });
}

},{"../wait.js":"daYNk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PgHn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fallback", ()=>fallback);
parcelHelpers.export(exports, "rankTransports", ()=>rankTransports);
var _buildRequestJs = require("../../utils/buildRequest.js");
var _waitJs = require("../../utils/wait.js");
var _createTransportJs = require("./createTransport.js");
function fallback(transports_, config = {}) {
    const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
    return ({ chain, pollingInterval = 4000, timeout })=>{
        let transports = transports_;
        let onResponse = ()=>{};
        const transport = (0, _createTransportJs.createTransport)({
            key,
            name,
            async request ({ method, params }) {
                const fetch = async (i = 0)=>{
                    const transport = transports[i]({
                        chain,
                        retryCount: 0,
                        timeout
                    });
                    try {
                        const response = await transport.request({
                            method,
                            params
                        });
                        onResponse({
                            method,
                            params: params,
                            response,
                            transport,
                            status: "success"
                        });
                        return response;
                    } catch (err) {
                        onResponse({
                            error: err,
                            method,
                            params: params,
                            transport,
                            status: "error"
                        });
                        // If the error is deterministic, we don't need to fall back.
                        // So throw the error.
                        if ((0, _buildRequestJs.isDeterministicError)(err)) throw err;
                        // If we've reached the end of the fallbacks, throw the error.
                        if (i === transports.length - 1) throw err;
                        // Otherwise, try the next fallback.
                        return fetch(i + 1);
                    }
                };
                return fetch();
            },
            retryCount,
            retryDelay,
            type: "fallback"
        }, {
            onResponse: (fn)=>onResponse = fn,
            transports: transports.map((fn)=>fn({
                    chain,
                    retryCount: 0
                }))
        });
        if (rank) {
            const rankOptions = typeof rank === "object" ? rank : {};
            rankTransports({
                chain,
                interval: rankOptions.interval ?? pollingInterval,
                onTransports: (transports_)=>transports = transports_,
                sampleCount: rankOptions.sampleCount,
                timeout: rankOptions.timeout,
                transports,
                weights: rankOptions.weights
            });
        }
        return transport;
    };
}
function rankTransports({ chain, interval = 4000, onTransports, sampleCount = 10, timeout = 1000, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async ()=>{
        // 1. Take a sample from each Transport.
        const sample = await Promise.all(transports.map(async (transport)=>{
            const transport_ = transport({
                chain,
                retryCount: 0,
                timeout
            });
            const start = Date.now();
            let end;
            let success;
            try {
                await transport_.request({
                    method: "net_listening"
                });
                success = 1;
            } catch  {
                success = 0;
            } finally{
                end = Date.now();
            }
            const latency = end - start;
            return {
                latency,
                success
            };
        }));
        // 2. Store the sample. If we have more than `sampleCount` samples, remove
        // the oldest sample.
        samples.push(sample);
        if (samples.length > sampleCount) samples.shift();
        // 3. Calculate the max latency from samples.
        const maxLatency = Math.max(...samples.map((sample)=>Math.max(...sample.map(({ latency })=>latency))));
        // 4. Calculate the score for each Transport.
        const scores = transports.map((_, i)=>{
            const latencies = samples.map((sample)=>sample[i].latency);
            const meanLatency = latencies.reduce((acc, latency)=>acc + latency, 0) / latencies.length;
            const latencyScore = 1 - meanLatency / maxLatency;
            const successes = samples.map((sample)=>sample[i].success);
            const stabilityScore = successes.reduce((acc, success)=>acc + success, 0) / successes.length;
            if (stabilityScore === 0) return [
                0,
                i
            ];
            return [
                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
                i
            ];
        }).sort((a, b)=>b[0] - a[0]);
        // 5. Sort the Transports by score.
        onTransports(scores.map(([, i])=>transports[i]));
        // 6. Wait, and then rank again.
        await (0, _waitJs.wait)(interval);
        rankTransports_();
    };
    rankTransports_();
}

},{"../../utils/buildRequest.js":"dXPq5","../../utils/wait.js":"daYNk","./createTransport.js":"cUQ8K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hjRtb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a HTTP transport that connects to a JSON-RPC API.
 */ parcelHelpers.export(exports, "http", ()=>http);
var _requestJs = require("../../errors/request.js");
var _transportJs = require("../../errors/transport.js");
var _createBatchSchedulerJs = require("../../utils/promise/createBatchScheduler.js");
var _rpcJs = require("../../utils/rpc.js");
var _createTransportJs = require("./createTransport.js");
function http(/** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */ url, config = {}) {
    const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ })=>{
        const { batchSize = 1000, wait = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_) throw new (0, _transportJs.UrlRequiredError)();
        return (0, _createTransportJs.createTransport)({
            key,
            name,
            async request ({ method, params }) {
                const body = {
                    method,
                    params
                };
                const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
                    id: `${url}`,
                    wait,
                    shouldSplitBatch (requests) {
                        return requests.length > batchSize;
                    },
                    fn: (body)=>(0, _rpcJs.rpc).http(url_, {
                            body,
                            fetchOptions,
                            timeout
                        })
                });
                const fn = async (body)=>batch ? schedule(body) : [
                        await (0, _rpcJs.rpc).http(url_, {
                            body,
                            fetchOptions,
                            timeout
                        })
                    ];
                const [{ error, result }] = await fn(body);
                if (error) throw new (0, _requestJs.RpcRequestError)({
                    body,
                    error,
                    url: url_
                });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: "http"
        }, {
            url
        });
    };
}

},{"../../errors/request.js":"vUxFy","../../errors/transport.js":"gCkTf","../../utils/promise/createBatchScheduler.js":"iJ7xI","../../utils/rpc.js":"72uRz","./createTransport.js":"cUQ8K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gCkTf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UrlRequiredError", ()=>UrlRequiredError);
var _baseJs = require("./base.js");
class UrlRequiredError extends (0, _baseJs.BaseError) {
    constructor(){
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"72uRz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSocket", ()=>getSocket);
parcelHelpers.export(exports, "rpc", ()=>rpc);
var _requestJs = require("../errors/request.js");
var _createBatchSchedulerJs = require("./promise/createBatchScheduler.js");
var _withTimeoutJs = require("./promise/withTimeout.js");
var _stringifyJs = require("./stringify.js");
let id = 0;
async function http(url, { body, fetchOptions = {}, timeout = 10000 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
        const response = await (0, _withTimeoutJs.withTimeout)(async ({ signal })=>{
            const response = await fetch(url, {
                ...fetchOptions,
                body: Array.isArray(body) ? (0, _stringifyJs.stringify)(body.map((body)=>({
                        jsonrpc: "2.0",
                        id: id++,
                        ...body
                    }))) : (0, _stringifyJs.stringify)({
                    jsonrpc: "2.0",
                    id: id++,
                    ...body
                }),
                headers: {
                    ...headers,
                    "Content-Type": "application/json"
                },
                method: method || "POST",
                signal: signal_ || (timeout > 0 ? signal : undefined)
            });
            return response;
        }, {
            errorInstance: new (0, _requestJs.TimeoutError)({
                body,
                url
            }),
            timeout,
            signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) data = await response.json();
        else data = await response.text();
        if (!response.ok) throw new (0, _requestJs.HttpRequestError)({
            body,
            details: (0, _stringifyJs.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
        });
        return data;
    } catch (err) {
        if (err instanceof (0, _requestJs.HttpRequestError)) throw err;
        if (err instanceof (0, _requestJs.TimeoutError)) throw err;
        throw new (0, _requestJs.HttpRequestError)({
            body,
            details: err.message,
            url
        });
    }
}
const sockets = /*#__PURE__*/ new Map();
async function getSocket(url_) {
    const url = new URL(url_);
    const urlKey = url.toString();
    let socket = sockets.get(urlKey);
    // If the socket already exists, return it.
    if (socket) return socket;
    const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
        id: urlKey,
        fn: async ()=>{
            let WebSocket = await require("c1d04810a8257ec0");
            // Workaround for Vite.
            // https://github.com/vitejs/vite/issues/9703
            // TODO: Remove when issue is resolved.
            if (WebSocket.default?.constructor) WebSocket = WebSocket.default;
            else WebSocket = WebSocket.WebSocket;
            const webSocket = new WebSocket(url);
            // Set up a cache for incoming "synchronous" requests.
            const requests = new Map();
            // Set up a cache for subscriptions (eth_subscribe).
            const subscriptions = new Map();
            const onMessage = ({ data })=>{
                const message = JSON.parse(data);
                const isSubscription = message.method === "eth_subscription";
                const id = isSubscription ? message.params.subscription : message.id;
                const cache = isSubscription ? subscriptions : requests;
                const callback = cache.get(id);
                if (callback) callback({
                    data
                });
                if (!isSubscription) cache.delete(id);
            };
            const onClose = ()=>{
                sockets.delete(urlKey);
                webSocket.removeEventListener("close", onClose);
                webSocket.removeEventListener("message", onMessage);
            };
            // Setup event listeners for RPC & subscription responses.
            webSocket.addEventListener("close", onClose);
            webSocket.addEventListener("message", onMessage);
            // Wait for the socket to open.
            if (webSocket.readyState === WebSocket.CONNECTING) await new Promise((resolve, reject)=>{
                if (!webSocket) return;
                webSocket.onopen = resolve;
                webSocket.onerror = reject;
            });
            // Create a new socket instance.
            socket = Object.assign(webSocket, {
                requests,
                subscriptions
            });
            sockets.set(urlKey, socket);
            return [
                socket
            ];
        }
    });
    const [_, [socket_]] = await schedule();
    return socket_;
}
function webSocket(socket, { body, onResponse }) {
    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new (0, _requestJs.WebSocketRequestError)({
        body,
        url: socket.url,
        details: "Socket is closed."
    });
    const id_ = id++;
    const callback = ({ data })=>{
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id) return;
        onResponse?.(message);
        // If we are subscribing to a topic, we want to set up a listener for incoming
        // messages.
        if (body.method === "eth_subscribe" && typeof message.result === "string") socket.subscriptions.set(message.result, callback);
        // If we are unsubscribing from a topic, we want to remove the listener.
        if (body.method === "eth_unsubscribe") socket.subscriptions.delete(body.params?.[0]);
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({
        jsonrpc: "2.0",
        ...body,
        id: id_
    }));
    return socket;
}
async function webSocketAsync(socket, { body, timeout = 10000 }) {
    return (0, _withTimeoutJs.withTimeout)(()=>new Promise((onResponse)=>rpc.webSocket(socket, {
                body,
                onResponse
            })), {
        errorInstance: new (0, _requestJs.TimeoutError)({
            body,
            url: socket.url
        }),
        timeout
    });
}
const rpc = {
    http,
    webSocket,
    webSocketAsync
};

},{"../errors/request.js":"vUxFy","./promise/createBatchScheduler.js":"iJ7xI","./promise/withTimeout.js":"gb33k","./stringify.js":"e0Ibk","c1d04810a8257ec0":"8IhVh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gb33k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withTimeout", ()=>withTimeout);
function withTimeout(fn, { errorInstance, timeout, signal }) {
    return new Promise((resolve, reject)=>{
        (async ()=>{
            let timeoutId;
            try {
                const controller = new AbortController();
                if (timeout > 0) timeoutId = setTimeout(()=>{
                    if (signal) controller.abort();
                    else reject(errorInstance);
                }, timeout);
                resolve(await fn({
                    signal: controller?.signal
                }));
            } catch (err) {
                if (err.name === "AbortError") reject(errorInstance);
                reject(err);
            } finally{
                clearTimeout(timeoutId);
            }
        })();
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IhVh":[function(require,module,exports) {
module.exports = require("1aeb86439997c756")(require("f9f1beeade09fd89").getBundleURL("UckoE") + "browser.e7cb541d.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("efAV5"));

},{"1aeb86439997c756":"61B45","f9f1beeade09fd89":"lgJ39"}],"baY0I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).
 *
 * - Docs: https://viem.sh/docs/clients/public.html
 *
 * A Public Client is an interface to "public" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).
 *
 * @param config - {@link PublicClientConfig}
 * @returns A Public Client. {@link PublicClient}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 */ parcelHelpers.export(exports, "createPublicClient", ()=>createPublicClient);
var _createClientJs = require("./createClient.js");
var _publicJs = require("./decorators/public.js");
function createPublicClient({ batch, chain, key = "public", name = "Public Client", transport, pollingInterval }) {
    return (0, _createClientJs.createClient)({
        batch,
        chain,
        key,
        name,
        pollingInterval,
        transport,
        type: "publicClient"
    }).extend((0, _publicJs.publicActions));
}

},{"./createClient.js":"2JKGW","./decorators/public.js":"iEK8R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iEK8R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publicActions", ()=>publicActions);
var _getEnsAddressJs = require("../../actions/ens/getEnsAddress.js");
var _getEnsAvatarJs = require("../../actions/ens/getEnsAvatar.js");
var _getEnsNameJs = require("../../actions/ens/getEnsName.js");
var _getEnsResolverJs = require("../../actions/ens/getEnsResolver.js");
var _getEnsTextJs = require("../../actions/ens/getEnsText.js");
var _callJs = require("../../actions/public/call.js");
var _createBlockFilterJs = require("../../actions/public/createBlockFilter.js");
var _createContractEventFilterJs = require("../../actions/public/createContractEventFilter.js");
var _createEventFilterJs = require("../../actions/public/createEventFilter.js");
var _createPendingTransactionFilterJs = require("../../actions/public/createPendingTransactionFilter.js");
var _estimateContractGasJs = require("../../actions/public/estimateContractGas.js");
var _estimateGasJs = require("../../actions/public/estimateGas.js");
var _getBalanceJs = require("../../actions/public/getBalance.js");
var _getBlockJs = require("../../actions/public/getBlock.js");
var _getBlockNumberJs = require("../../actions/public/getBlockNumber.js");
var _getBlockTransactionCountJs = require("../../actions/public/getBlockTransactionCount.js");
var _getBytecodeJs = require("../../actions/public/getBytecode.js");
var _getChainIdJs = require("../../actions/public/getChainId.js");
var _getFeeHistoryJs = require("../../actions/public/getFeeHistory.js");
var _getFilterChangesJs = require("../../actions/public/getFilterChanges.js");
var _getFilterLogsJs = require("../../actions/public/getFilterLogs.js");
var _getGasPriceJs = require("../../actions/public/getGasPrice.js");
var _getLogsJs = require("../../actions/public/getLogs.js");
var _getStorageAtJs = require("../../actions/public/getStorageAt.js");
var _getTransactionJs = require("../../actions/public/getTransaction.js");
var _getTransactionConfirmationsJs = require("../../actions/public/getTransactionConfirmations.js");
var _getTransactionCountJs = require("../../actions/public/getTransactionCount.js");
var _getTransactionReceiptJs = require("../../actions/public/getTransactionReceipt.js");
var _multicallJs = require("../../actions/public/multicall.js");
var _readContractJs = require("../../actions/public/readContract.js");
var _simulateContractJs = require("../../actions/public/simulateContract.js");
var _uninstallFilterJs = require("../../actions/public/uninstallFilter.js");
var _verifyMessageJs = require("../../actions/public/verifyMessage.js");
var _verifyTypedDataJs = require("../../actions/public/verifyTypedData.js");
var _waitForTransactionReceiptJs = require("../../actions/public/waitForTransactionReceipt.js");
var _watchBlockNumberJs = require("../../actions/public/watchBlockNumber.js");
var _watchBlocksJs = require("../../actions/public/watchBlocks.js");
var _watchContractEventJs = require("../../actions/public/watchContractEvent.js");
var _watchEventJs = require("../../actions/public/watchEvent.js");
var _watchPendingTransactionsJs = require("../../actions/public/watchPendingTransactions.js");
const publicActions = (client)=>({
        call: (args)=>(0, _callJs.call)(client, args),
        createBlockFilter: ()=>(0, _createBlockFilterJs.createBlockFilter)(client),
        createContractEventFilter: (args)=>(0, _createContractEventFilterJs.createContractEventFilter)(client, args),
        createEventFilter: (args)=>(0, _createEventFilterJs.createEventFilter)(client, args),
        createPendingTransactionFilter: ()=>(0, _createPendingTransactionFilterJs.createPendingTransactionFilter)(client),
        estimateContractGas: (args)=>(0, _estimateContractGasJs.estimateContractGas)(client, args),
        estimateGas: (args)=>(0, _estimateGasJs.estimateGas)(client, args),
        getBalance: (args)=>(0, _getBalanceJs.getBalance)(client, args),
        getBlock: (args)=>(0, _getBlockJs.getBlock)(client, args),
        getBlockNumber: (args)=>(0, _getBlockNumberJs.getBlockNumber)(client, args),
        getBlockTransactionCount: (args)=>(0, _getBlockTransactionCountJs.getBlockTransactionCount)(client, args),
        getBytecode: (args)=>(0, _getBytecodeJs.getBytecode)(client, args),
        getChainId: ()=>(0, _getChainIdJs.getChainId)(client),
        getEnsAddress: (args)=>(0, _getEnsAddressJs.getEnsAddress)(client, args),
        getEnsAvatar: (args)=>(0, _getEnsAvatarJs.getEnsAvatar)(client, args),
        getEnsName: (args)=>(0, _getEnsNameJs.getEnsName)(client, args),
        getEnsResolver: (args)=>(0, _getEnsResolverJs.getEnsResolver)(client, args),
        getEnsText: (args)=>(0, _getEnsTextJs.getEnsText)(client, args),
        getFeeHistory: (args)=>(0, _getFeeHistoryJs.getFeeHistory)(client, args),
        getFilterChanges: (args)=>(0, _getFilterChangesJs.getFilterChanges)(client, args),
        getFilterLogs: (args)=>(0, _getFilterLogsJs.getFilterLogs)(client, args),
        getGasPrice: ()=>(0, _getGasPriceJs.getGasPrice)(client),
        getLogs: (args)=>(0, _getLogsJs.getLogs)(client, args),
        getStorageAt: (args)=>(0, _getStorageAtJs.getStorageAt)(client, args),
        getTransaction: (args)=>(0, _getTransactionJs.getTransaction)(client, args),
        getTransactionConfirmations: (args)=>(0, _getTransactionConfirmationsJs.getTransactionConfirmations)(client, args),
        getTransactionCount: (args)=>(0, _getTransactionCountJs.getTransactionCount)(client, args),
        getTransactionReceipt: (args)=>(0, _getTransactionReceiptJs.getTransactionReceipt)(client, args),
        multicall: (args)=>(0, _multicallJs.multicall)(client, args),
        readContract: (args)=>(0, _readContractJs.readContract)(client, args),
        simulateContract: (args)=>(0, _simulateContractJs.simulateContract)(client, args),
        verifyMessage: (args)=>(0, _verifyMessageJs.verifyMessage)(client, args),
        verifyTypedData: (args)=>(0, _verifyTypedDataJs.verifyTypedData)(client, args),
        uninstallFilter: (args)=>(0, _uninstallFilterJs.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args)=>(0, _waitForTransactionReceiptJs.waitForTransactionReceipt)(client, args),
        watchBlocks: (args)=>(0, _watchBlocksJs.watchBlocks)(client, args),
        watchBlockNumber: (args)=>(0, _watchBlockNumberJs.watchBlockNumber)(client, args),
        watchContractEvent: (args)=>(0, _watchContractEventJs.watchContractEvent)(client, args),
        watchEvent: (args)=>(0, _watchEventJs.watchEvent)(client, args),
        watchPendingTransactions: (args)=>(0, _watchPendingTransactionsJs.watchPendingTransactions)(client, args)
    });

},{"../../actions/ens/getEnsAddress.js":"du9Bu","../../actions/ens/getEnsAvatar.js":"edQ1u","../../actions/ens/getEnsName.js":"5hg07","../../actions/ens/getEnsResolver.js":"bHjSa","../../actions/ens/getEnsText.js":"jjum5","../../actions/public/call.js":"8bUID","../../actions/public/createBlockFilter.js":"i6JnT","../../actions/public/createContractEventFilter.js":"g5tcn","../../actions/public/createEventFilter.js":"1UumE","../../actions/public/createPendingTransactionFilter.js":"1bmuf","../../actions/public/estimateContractGas.js":"hpW3E","../../actions/public/estimateGas.js":"cQ1pW","../../actions/public/getBalance.js":"axBLr","../../actions/public/getBlock.js":"eKkgZ","../../actions/public/getBlockNumber.js":"8c8Ud","../../actions/public/getBlockTransactionCount.js":"1Dt1Q","../../actions/public/getBytecode.js":"3xbQ4","../../actions/public/getChainId.js":"gyNal","../../actions/public/getFeeHistory.js":"25O13","../../actions/public/getFilterChanges.js":"1gr1F","../../actions/public/getFilterLogs.js":"8PG0x","../../actions/public/getGasPrice.js":"gLIMm","../../actions/public/getLogs.js":"2mlJj","../../actions/public/getStorageAt.js":"ltqLa","../../actions/public/getTransaction.js":"6bI7T","../../actions/public/getTransactionConfirmations.js":"iw7hW","../../actions/public/getTransactionCount.js":"8CzRo","../../actions/public/getTransactionReceipt.js":"4OQFf","../../actions/public/multicall.js":"gj4sq","../../actions/public/readContract.js":"cW2al","../../actions/public/simulateContract.js":"ephq0","../../actions/public/uninstallFilter.js":"3qnsl","../../actions/public/verifyMessage.js":"1Soif","../../actions/public/verifyTypedData.js":"bNj6R","../../actions/public/waitForTransactionReceipt.js":"cLOTh","../../actions/public/watchBlockNumber.js":"a2Skw","../../actions/public/watchBlocks.js":"o4Ph4","../../actions/public/watchContractEvent.js":"gUVqN","../../actions/public/watchEvent.js":"lxvs7","../../actions/public/watchPendingTransactions.js":"5ITxK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"du9Bu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets address for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAddressParameters}
 * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAddress, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAddress = await getEnsAddress(client, {
 *   name: normalize('wagmi-dev.eth'),
 * })
 * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
 */ parcelHelpers.export(exports, "getEnsAddress", ()=>getEnsAddress);
var _abisJs = require("../../constants/abis.js");
var _contractJs = require("../../errors/contract.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _chainJs = require("../../utils/chain.js");
var _trimJs = require("../../utils/data/trim.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _namehashJs = require("../../utils/ens/namehash.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsAddress(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, _chainJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "ensUniversalResolver"
        });
    }
    try {
        const res = await (0, _readContractJs.readContract)(client, {
            address: universalResolverAddress,
            abi: (0, _abisJs.universalResolverAbi),
            functionName: "resolve",
            args: [
                (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name)),
                (0, _encodeFunctionDataJs.encodeFunctionData)({
                    abi: (0, _abisJs.singleAddressResolverAbi),
                    functionName: "addr",
                    args: [
                        (0, _namehashJs.namehash)(name)
                    ]
                })
            ],
            blockNumber,
            blockTag
        });
        if (res[0] === "0x") return null;
        const address = (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi: (0, _abisJs.singleAddressResolverAbi),
            functionName: "addr",
            data: res[0]
        });
        return (0, _trimJs.trim)(address) === "0x00" ? null : address;
    } catch (err) {
        if (err instanceof (0, _contractJs.ContractFunctionExecutionError)) {
            const reason = err.cause?.reason;
            if (reason?.includes("Wildcard on non-extended resolvers is not supported")) return null;
        }
        throw err;
    }
}

},{"../../constants/abis.js":"mYIU4","../../errors/contract.js":"3O0YB","../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/chain.js":"cruNy","../../utils/data/trim.js":"khJVi","../../utils/encoding/toHex.js":"67sRi","../../utils/ens/namehash.js":"4BqpX","../../utils/ens/packetToBytes.js":"lTeEw","../public/readContract.js":"cW2al","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BqpX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Hashes ENS name
 *
 * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @example
 * namehash('wagmi-dev.eth')
 * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
 *
 * @link https://eips.ethereum.org/EIPS/eip-137
 */ parcelHelpers.export(exports, "namehash", ()=>namehash);
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _encodedLabelToLabelhashJs = require("./encodedLabelToLabelhash.js");
function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name) return (0, _toHexJs.bytesToHex)(result);
    const labels = name.split(".");
    // Iterate in reverse order building up hash
    for(let i = labels.length - 1; i >= 0; i -= 1){
        const hashFromEncodedLabel = (0, _encodedLabelToLabelhashJs.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, _toBytesJs.toBytes)(hashFromEncodedLabel) : (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(labels[i]), "bytes");
        result = (0, _keccak256Js.keccak256)((0, _concatJs.concat)([
            result,
            hashed
        ]), "bytes");
    }
    return (0, _toHexJs.bytesToHex)(result);
}

},{"../data/concat.js":"6Izt3","../encoding/toBytes.js":"jM9VU","../encoding/toHex.js":"67sRi","../hash/keccak256.js":"9tbZR","./encodedLabelToLabelhash.js":"hDH69","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hDH69":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodedLabelToLabelhash", ()=>encodedLabelToLabelhash);
var _indexJs = require("../index.js");
function encodedLabelToLabelhash(label) {
    if (label.length !== 66) return null;
    if (label.indexOf("[") !== 0) return null;
    if (label.indexOf("]") !== 65) return null;
    const hash = `0x${label.slice(1, 65)}`;
    if (!(0, _indexJs.isHex)(hash)) return null;
    return hash;
}

},{"../index.js":"9pB6K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9pB6K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildRequest", ()=>(0, _buildRequestJs.buildRequest));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipFetch));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _chainJs.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _chainJs.defineChain));
parcelHelpers.export(exports, "getChainContractAddress", ()=>(0, _chainJs.getChainContractAddress));
parcelHelpers.export(exports, "arrayRegex", ()=>(0, _regexJs.arrayRegex));
parcelHelpers.export(exports, "bytesRegex", ()=>(0, _regexJs.bytesRegex));
parcelHelpers.export(exports, "integerRegex", ()=>(0, _regexJs.integerRegex));
parcelHelpers.export(exports, "getSocket", ()=>(0, _rpcJs.getSocket));
parcelHelpers.export(exports, "rpc", ()=>(0, _rpcJs.rpc));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs.validateTypedData));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "formatAbiItemWithArgs", ()=>(0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs));
parcelHelpers.export(exports, "formatAbiItem", ()=>(0, _formatAbiItemJs.formatAbiItem));
parcelHelpers.export(exports, "formatAbiParams", ()=>(0, _formatAbiItemJs.formatAbiParams));
parcelHelpers.export(exports, "parseAccount", ()=>(0, _parseAccountJs.parseAccount));
parcelHelpers.export(exports, "publicKeyToAddress", ()=>(0, _publicKeyToAddressJs.publicKeyToAddress));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "extractFunctionName", ()=>(0, _extractFunctionPartsJs.extractFunctionName));
parcelHelpers.export(exports, "extractFunctionParams", ()=>(0, _extractFunctionPartsJs.extractFunctionParams));
parcelHelpers.export(exports, "extractFunctionType", ()=>(0, _extractFunctionPartsJs.extractFunctionType));
parcelHelpers.export(exports, "extractFunctionParts", ()=>(0, _extractFunctionPartsJs.extractFunctionParts));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs.formatBlock));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs.transactionType));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs.formatLog));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "extract", ()=>(0, _extractJs.extract));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "bytesToBigint", ()=>(0, _fromBytesJs.bytesToBigint));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "containsNodeError", ()=>(0, _getNodeErrorJs.containsNodeError));
parcelHelpers.export(exports, "getNodeError", ()=>(0, _getNodeErrorJs.getNodeError));
parcelHelpers.export(exports, "getCallError", ()=>(0, _getCallErrorJs.getCallError));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "getEstimateGasError", ()=>(0, _getEstimateGasErrorJs.getEstimateGasError));
parcelHelpers.export(exports, "getTransactionError", ()=>(0, _getTransactionErrorJs.getTransactionError));
parcelHelpers.export(exports, "defineFormatter", ()=>(0, _formatterJs.defineFormatter));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _getEventSelectorJs.getEventSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _getFunctionSelectorJs.getFunctionSelector));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "prepareRequest", ()=>(0, _prepareRequestJs.prepareRequest));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
var _buildRequestJs = require("./buildRequest.js");
var _ccipJs = require("./ccip.js");
var _chainJs = require("./chain.js");
var _regexJs = require("./regex.js");
var _rpcJs = require("./rpc.js");
var _stringifyJs = require("./stringify.js");
var _typedDataJs = require("./typedData.js");
var _decodeAbiParametersJs = require("./abi/decodeAbiParameters.js");
var _decodeErrorResultJs = require("./abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./abi/encodeFunctionData.js");
var _encodeFunctionResultJs = require("./abi/encodeFunctionResult.js");
var _getAbiItemJs = require("./abi/getAbiItem.js");
var _abitype = require("abitype");
var _encodePackedJs = require("./abi/encodePacked.js");
var _formatAbiItemWithArgsJs = require("./abi/formatAbiItemWithArgs.js");
var _formatAbiItemJs = require("./abi/formatAbiItem.js");
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _publicKeyToAddressJs = require("../accounts/utils/publicKeyToAddress.js");
var _getContractAddressJs = require("./address/getContractAddress.js");
var _getAddressJs = require("./address/getAddress.js");
var _isAddressJs = require("./address/isAddress.js");
var _isAddressEqualJs = require("./address/isAddressEqual.js");
var _extractFunctionPartsJs = require("./contract/extractFunctionParts.js");
var _concatJs = require("./data/concat.js");
var _isBytesJs = require("./data/isBytes.js");
var _isHexJs = require("./data/isHex.js");
var _padJs = require("./data/pad.js");
var _sizeJs = require("./data/size.js");
var _sliceJs = require("./data/slice.js");
var _trimJs = require("./data/trim.js");
var _blockJs = require("./formatters/block.js");
var _transactionJs = require("./formatters/transaction.js");
var _logJs = require("./formatters/log.js");
var _transactionReceiptJs = require("./formatters/transactionReceipt.js");
var _transactionRequestJs = require("./formatters/transactionRequest.js");
var _extractJs = require("./formatters/extract.js");
var _toRlpJs = require("./encoding/toRlp.js");
var _toBytesJs = require("./encoding/toBytes.js");
var _toHexJs = require("./encoding/toHex.js");
var _fromBytesJs = require("./encoding/fromBytes.js");
var _fromHexJs = require("./encoding/fromHex.js");
var _fromRlpJs = require("./encoding/fromRlp.js");
var _getNodeErrorJs = require("./errors/getNodeError.js");
var _getCallErrorJs = require("./errors/getCallError.js");
var _getContractErrorJs = require("./errors/getContractError.js");
var _getEstimateGasErrorJs = require("./errors/getEstimateGasError.js");
var _getTransactionErrorJs = require("./errors/getTransactionError.js");
var _formatterJs = require("./formatters/formatter.js");
var _getEventSelectorJs = require("./hash/getEventSelector.js");
var _getFunctionSelectorJs = require("./hash/getFunctionSelector.js");
var _isHashJs = require("./hash/isHash.js");
var _keccak256Js = require("./hash/keccak256.js");
var _hashTypedDataJs = require("./signature/hashTypedData.js");
var _recoverAddressJs = require("./signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./signature/recoverPublicKey.js");
var _recoverTypedDataAddressJs = require("./signature/recoverTypedDataAddress.js");
var _verifyMessageJs = require("./signature/verifyMessage.js");
var _verifyTypedDataJs = require("./signature/verifyTypedData.js");
var _hashMessageJs = require("./signature/hashMessage.js");
var _getSerializedTransactionTypeJs = require("./transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./transaction/getTransactionType.js");
var _assertRequestJs = require("./transaction/assertRequest.js");
var _assertTransactionJs = require("./transaction/assertTransaction.js");
var _parseTransactionJs = require("./transaction/parseTransaction.js");
var _prepareRequestJs = require("./transaction/prepareRequest.js");
var _serializeTransactionJs = require("./transaction/serializeTransaction.js");
var _serializeAccessListJs = require("./transaction/serializeAccessList.js");
var _formatEtherJs = require("./unit/formatEther.js");
var _formatGweiJs = require("./unit/formatGwei.js");
var _formatUnitsJs = require("./unit/formatUnits.js");
var _parseUnitsJs = require("./unit/parseUnits.js");
var _parseEtherJs = require("./unit/parseEther.js");
var _parseGweiJs = require("./unit/parseGwei.js");

},{"./buildRequest.js":false,"./ccip.js":false,"./chain.js":false,"./regex.js":false,"./rpc.js":false,"./stringify.js":false,"./typedData.js":false,"./abi/decodeAbiParameters.js":false,"./abi/decodeErrorResult.js":false,"./abi/decodeEventLog.js":false,"./abi/decodeFunctionData.js":false,"./abi/decodeFunctionResult.js":false,"./abi/encodeAbiParameters.js":false,"./abi/encodeDeployData.js":"1fOog","./abi/encodeErrorResult.js":false,"./abi/encodeEventTopics.js":false,"./abi/encodeFunctionData.js":false,"./abi/encodeFunctionResult.js":false,"./abi/getAbiItem.js":false,"abitype":false,"./abi/encodePacked.js":false,"./abi/formatAbiItemWithArgs.js":false,"./abi/formatAbiItem.js":false,"../accounts/utils/parseAccount.js":false,"../accounts/utils/publicKeyToAddress.js":false,"./address/getContractAddress.js":false,"./address/getAddress.js":false,"./address/isAddress.js":false,"./address/isAddressEqual.js":false,"./contract/extractFunctionParts.js":false,"./data/concat.js":false,"./data/isBytes.js":false,"./data/isHex.js":"gOtuZ","./data/pad.js":false,"./data/size.js":false,"./data/slice.js":false,"./data/trim.js":false,"./formatters/block.js":false,"./formatters/transaction.js":false,"./formatters/log.js":false,"./formatters/transactionReceipt.js":false,"./formatters/transactionRequest.js":false,"./formatters/extract.js":false,"./encoding/toRlp.js":false,"./encoding/toBytes.js":false,"./encoding/toHex.js":"67sRi","./encoding/fromBytes.js":false,"./encoding/fromHex.js":false,"./encoding/fromRlp.js":false,"./errors/getNodeError.js":false,"./errors/getCallError.js":false,"./errors/getContractError.js":false,"./errors/getEstimateGasError.js":false,"./errors/getTransactionError.js":false,"./formatters/formatter.js":false,"./hash/getEventSelector.js":false,"./hash/getFunctionSelector.js":false,"./hash/isHash.js":false,"./hash/keccak256.js":false,"./signature/hashTypedData.js":false,"./signature/recoverAddress.js":false,"./signature/recoverMessageAddress.js":false,"./signature/recoverPublicKey.js":false,"./signature/recoverTypedDataAddress.js":false,"./signature/verifyMessage.js":false,"./signature/verifyTypedData.js":false,"./signature/hashMessage.js":"kabyG","./transaction/getSerializedTransactionType.js":false,"./transaction/getTransactionType.js":false,"./transaction/assertRequest.js":false,"./transaction/assertTransaction.js":false,"./transaction/parseTransaction.js":false,"./transaction/prepareRequest.js":false,"./transaction/serializeTransaction.js":false,"./transaction/serializeAccessList.js":false,"./unit/formatEther.js":false,"./unit/formatGwei.js":false,"./unit/formatUnits.js":false,"./unit/parseUnits.js":false,"./unit/parseEther.js":false,"./unit/parseGwei.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lH0zP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayRegex", ()=>arrayRegex);
parcelHelpers.export(exports, "bytesRegex", ()=>bytesRegex);
parcelHelpers.export(exports, "integerRegex", ()=>integerRegex);
const arrayRegex = /^(.*)\[([0-9]*)\]$/;
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwT9b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateTypedData", ()=>validateTypedData);
var _abiJs = require("../errors/abi.js");
var _addressJs = require("../errors/address.js");
var _isAddressJs = require("./address/isAddress.js");
var _sizeJs = require("./data/size.js");
var _toHexJs = require("./encoding/toHex.js");
var _regexJs = require("./regex.js");
function validateTypedData({ domain, message, primaryType, types: types_ }) {
    const types = types_;
    const validateData = (struct, value_)=>{
        for (const param of struct){
            const { name, type: type_ } = param;
            const type = type_;
            const value = value_[name];
            const integerMatch = type.match((0, _regexJs.integerRegex));
            if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
                const [_type, base, size_] = integerMatch;
                // If number cannot be cast to a sized hex value, it is out of range
                // and will throw.
                (0, _toHexJs.numberToHex)(value, {
                    signed: base === "int",
                    size: parseInt(size_) / 8
                });
            }
            if (type === "address" && typeof value === "string" && !(0, _isAddressJs.isAddress)(value)) throw new (0, _addressJs.InvalidAddressError)({
                address: value
            });
            const bytesMatch = type.match((0, _regexJs.bytesRegex));
            if (bytesMatch) {
                const [_type, size_] = bytesMatch;
                if (size_ && (0, _sizeJs.size)(value) !== parseInt(size_)) throw new (0, _abiJs.BytesSizeMismatchError)({
                    expectedSize: parseInt(size_),
                    givenSize: (0, _sizeJs.size)(value)
                });
            }
            const struct = types[type];
            if (struct) validateData(struct, value);
        }
    };
    // Validate domain types.
    if (types["EIP712Domain"] && domain) validateData(types["EIP712Domain"], domain);
    if (primaryType !== "EIP712Domain") {
        // Validate message types.
        const type = types[primaryType];
        validateData(type, message);
    }
}

},{"../errors/abi.js":"l5DIr","../errors/address.js":"4cSuV","./address/isAddress.js":"gRnzT","./data/size.js":"jRUcy","./encoding/toHex.js":"67sRi","./regex.js":"lH0zP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fOog":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeDeployData", ()=>encodeDeployData);
var _abiJs = require("../../errors/abi.js");
var _concatJs = require("../data/concat.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData({ abi, args, bytecode }) {
    if (!args || args.length === 0) return bytecode;
    const description = abi.find((x)=>"type" in x && x.type === "constructor");
    if (!description) throw new (0, _abiJs.AbiConstructorNotFoundError)({
        docsPath
    });
    if (!("inputs" in description)) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    if (!description.inputs || description.inputs.length === 0) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    const data = (0, _encodeAbiParametersJs.encodeAbiParameters)(description.inputs, args);
    return (0, _concatJs.concatHex)([
        bytecode,
        data
    ]);
}

},{"../../errors/abi.js":"l5DIr","../data/concat.js":"6Izt3","./encodeAbiParameters.js":"9xZxs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lc1dU":[function(require,module,exports) {
// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashTypedData", ()=>hashTypedData);
var _encodeAbiParametersJs = require("../abi/encodeAbiParameters.js");
var _concatJs = require("../data/concat.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _typedDataJs = require("../typedData.js");
function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
    const domain = typeof domain_ === "undefined" ? {} : domain_;
    const types = {
        EIP712Domain: [
            typeof domain?.name === "string" && {
                name: "name",
                type: "string"
            },
            domain?.version && {
                name: "version",
                type: "string"
            },
            typeof domain?.chainId === "number" && {
                name: "chainId",
                type: "uint256"
            },
            domain?.verifyingContract && {
                name: "verifyingContract",
                type: "address"
            },
            domain?.salt && {
                name: "salt",
                type: "bytes32"
            }
        ].filter(Boolean),
        ...types_
    };
    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
    // as we can't statically check this with TypeScript.
    (0, _typedDataJs.validateTypedData)({
        domain,
        message,
        primaryType,
        types
    });
    const parts = [
        "0x1901"
    ];
    if (domain) parts.push(hashDomain({
        domain,
        types: types
    }));
    if (primaryType !== "EIP712Domain") parts.push(hashStruct({
        data: message,
        primaryType: primaryType,
        types: types
    }));
    return (0, _keccak256Js.keccak256)((0, _concatJs.concat)(parts));
}
function hashDomain({ domain, types }) {
    return hashStruct({
        data: domain,
        primaryType: "EIP712Domain",
        types
    });
}
function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
        data,
        primaryType,
        types
    });
    return (0, _keccak256Js.keccak256)(encoded);
}
function encodeData({ data, primaryType, types }) {
    const encodedTypes = [
        {
            type: "bytes32"
        }
    ];
    const encodedValues = [
        hashType({
            primaryType,
            types
        })
    ];
    for (const field of types[primaryType]){
        const [type, value] = encodeField({
            types,
            name: field.name,
            type: field.type,
            value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, _encodeAbiParametersJs.encodeAbiParameters)(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
    const encodedHashType = (0, _toHexJs.toHex)(encodeType({
        primaryType,
        types
    }));
    return (0, _keccak256Js.keccak256)(encodedHashType);
}
function encodeType({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({
        primaryType,
        types
    });
    unsortedDeps.delete(primaryType);
    const deps = [
        primaryType,
        ...Array.from(unsortedDeps).sort()
    ];
    for (const type of deps)result += `${type}(${types[type].map(({ name, type: t })=>`${t} ${name}`).join(",")})`;
    return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) return results;
    results.add(primaryType);
    for (const field of types[primaryType])findTypeDependencies({
        primaryType: field.type,
        types
    }, results);
    return results;
}
function encodeField({ types, name, type, value }) {
    if (types[type] !== undefined) return [
        {
            type: "bytes32"
        },
        (0, _keccak256Js.keccak256)(encodeData({
            data: value,
            primaryType: type,
            types
        }))
    ];
    if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [
            {
                type: "bytes32"
            },
            (0, _keccak256Js.keccak256)(value)
        ];
    }
    if (type === "string") return [
        {
            type: "bytes32"
        },
        (0, _keccak256Js.keccak256)((0, _toHexJs.toHex)(value))
    ];
    if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item)=>encodeField({
                name,
                type: parsedType,
                types,
                value: item
            }));
        return [
            {
                type: "bytes32"
            },
            (0, _keccak256Js.keccak256)((0, _encodeAbiParametersJs.encodeAbiParameters)(typeValuePairs.map(([t])=>t), typeValuePairs.map(([, v])=>v)))
        ];
    }
    return [
        {
            type
        },
        value
    ];
}

},{"../abi/encodeAbiParameters.js":"9xZxs","../data/concat.js":"6Izt3","../encoding/toHex.js":"67sRi","../hash/keccak256.js":"9tbZR","../typedData.js":"hwT9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kabyG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashMessage", ()=>hashMessage);
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
function hashMessage(message, to_) {
    const messageBytes = (()=>{
        if (typeof message === "string") return (0, _toBytesJs.stringToBytes)(message);
        if (message.raw instanceof Uint8Array) return message.raw;
        return (0, _toBytesJs.toBytes)(message.raw);
    })();
    const prefixBytes = (0, _toBytesJs.stringToBytes)(`\x19Ethereum Signed Message:\n${messageBytes.length}`);
    return (0, _keccak256Js.keccak256)((0, _concatJs.concat)([
        prefixBytes,
        messageBytes
    ]), to_);
}

},{"../data/concat.js":"6Izt3","../encoding/toBytes.js":"jM9VU","../hash/keccak256.js":"9tbZR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2UOek":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseUnits", ()=>parseUnits);
function parseUnits(value, decimals) {
    let [integer, fraction = "0"] = value.split(".");
    const negative = integer.startsWith("-");
    if (negative) integer = integer.slice(1);
    // trim leading zeros.
    fraction = fraction.replace(/(0+)$/, "");
    // round off if the fraction is larger than the number of decimals.
    if (decimals === 0) {
        integer = `${Math.round(Number(`${integer}.${fraction}`))}`;
        fraction = "";
    } else if (fraction.length > decimals) {
        const [left, unit, right] = [
            fraction.slice(0, decimals - 1),
            fraction.slice(decimals - 1, decimals),
            fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9) fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
            fraction = fraction.slice(1);
            integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
    } else fraction = fraction.padEnd(decimals, "0");
    return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJwcn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseEther", ()=>parseEther);
var _unitJs = require("../../constants/unit.js");
var _parseUnitsJs = require("./parseUnits.js");
function parseEther(ether, unit = "wei") {
    return (0, _parseUnitsJs.parseUnits)(ether, (0, _unitJs.etherUnits)[unit]);
}

},{"../../constants/unit.js":"8soM9","./parseUnits.js":"2UOek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKNAM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseGwei", ()=>parseGwei);
var _unitJs = require("../../constants/unit.js");
var _parseUnitsJs = require("./parseUnits.js");
function parseGwei(ether, unit = "wei") {
    return (0, _parseUnitsJs.parseUnits)(ether, (0, _unitJs.gweiUnits)[unit]);
}

},{"../../constants/unit.js":"8soM9","./parseUnits.js":"2UOek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lTeEw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * @description Encodes a DNS packet into a ByteArray containing a UDP payload.
 */ parcelHelpers.export(exports, "packetToBytes", ()=>packetToBytes);
var _toBytesJs = require("../encoding/toBytes.js");
var _encodeLabelhashJs = require("./encodeLabelhash.js");
var _labelhashJs = require("./labelhash.js");
function packetToBytes(packet) {
    // strip leading and trailing `.`
    const value = packet.replace(/^\.|\.$/gm, "");
    if (value.length === 0) return new Uint8Array(1);
    const bytes = new Uint8Array((0, _toBytesJs.stringToBytes)(value).byteLength + 2);
    let offset = 0;
    const list = value.split(".");
    for(let i = 0; i < list.length; i++){
        let encoded = (0, _toBytesJs.stringToBytes)(list[i]);
        // if the length is > 255, make the encoded label value a labelhash
        // this is compatible with the universal resolver
        if (encoded.byteLength > 255) encoded = (0, _toBytesJs.stringToBytes)((0, _encodeLabelhashJs.encodeLabelhash)((0, _labelhashJs.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
    }
    if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1);
    return bytes;
}

},{"../encoding/toBytes.js":"jM9VU","./encodeLabelhash.js":"3E5oA","./labelhash.js":"81rgv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3E5oA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeLabelhash", ()=>encodeLabelhash);
function encodeLabelhash(hash) {
    return `[${hash.slice(2)}]`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"81rgv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Hashes ENS label
 *
 * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @example
 * labelhash('eth')
 * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'
 */ parcelHelpers.export(exports, "labelhash", ()=>labelhash);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _encodedLabelToLabelhashJs = require("./encodedLabelToLabelhash.js");
function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label) return (0, _toHexJs.bytesToHex)(result);
    return (0, _encodedLabelToLabelhashJs.encodedLabelToLabelhash)(label) || (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(label));
}

},{"../encoding/toBytes.js":"jM9VU","../encoding/toHex.js":"67sRi","../hash/keccak256.js":"9tbZR","./encodedLabelToLabelhash.js":"hDH69","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edQ1u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the avatar of an ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
 *
 * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAvatarParameters}
 * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAvatar, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAvatar = await getEnsAvatar(client, {
 *   name: normalize('wagmi-dev.eth'),
 * })
 * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
 */ parcelHelpers.export(exports, "getEnsAvatar", ()=>getEnsAvatar);
var _parseAvatarRecordJs = require("../../utils/ens/avatar/parseAvatarRecord.js");
var _getEnsTextJs = require("./getEnsText.js");
async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
    const record = await (0, _getEnsTextJs.getEnsText)(client, {
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
    });
    if (!record) return null;
    try {
        return await (0, _parseAvatarRecordJs.parseAvatarRecord)(client, {
            record,
            gatewayUrls
        });
    } catch  {
        return null;
    }
}

},{"../../utils/ens/avatar/parseAvatarRecord.js":"dLjM5","./getEnsText.js":"jjum5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLjM5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseAvatarRecord", ()=>parseAvatarRecord);
var _utilsJs = require("./utils.js");
async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record)) return parseNftAvatarUri(client, {
        gatewayUrls,
        record
    });
    return (0, _utilsJs.parseAvatarUri)({
        uri: record,
        gatewayUrls
    });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    // parse NFT URI into properties
    const nft = (0, _utilsJs.parseNftUri)(record);
    // fetch tokenURI from the NFT contract
    const nftUri = await (0, _utilsJs.getNftTokenUri)(client, {
        nft
    });
    // resolve the URI from the fetched tokenURI
    const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, _utilsJs.resolveAvatarUri)({
        uri: nftUri,
        gatewayUrls
    });
    // if the resolved URI is on chain, return the data
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, _utilsJs.parseAvatarUri)({
            uri: (0, _utilsJs.getJsonImage)(decoded),
            gatewayUrls
        });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155") uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return (0, _utilsJs.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
}

},{"./utils.js":"avphH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"avphH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isImageUri", ()=>isImageUri);
parcelHelpers.export(exports, "getGateway", ()=>getGateway);
parcelHelpers.export(exports, "resolveAvatarUri", ()=>resolveAvatarUri);
parcelHelpers.export(exports, "getJsonImage", ()=>getJsonImage);
parcelHelpers.export(exports, "getMetadataAvatarUri", ()=>getMetadataAvatarUri);
parcelHelpers.export(exports, "parseAvatarUri", ()=>parseAvatarUri);
parcelHelpers.export(exports, "parseNftUri", ()=>parseNftUri);
parcelHelpers.export(exports, "getNftTokenUri", ()=>getNftTokenUri);
var _readContractJs = require("../../../actions/public/readContract.js");
var _ensJs = require("../../../errors/ens.js");
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
    try {
        const res = await fetch(uri, {
            method: "HEAD"
        });
        // retrieve content type header to check if content is image
        if (res.status === 200) {
            const contentType = res.headers.get("content-type");
            return contentType?.startsWith("image/");
        }
        return false;
    } catch (error) {
        // if error is not cors related then fail
        if (typeof error === "object" && typeof error.response !== "undefined") return false;
        // fail in NodeJS, since the error is not cors but any other network issue
        if (!globalThis.hasOwnProperty("Image")) return false;
        // in case of cors, use image api to validate if given url is an actual image
        return new Promise((resolve)=>{
            const img = new Image();
            img.onload = ()=>{
                resolve(true);
            };
            img.onerror = ()=>{
                resolve(false);
            };
            img.src = uri;
        });
    }
}
function getGateway(custom, defaultGateway) {
    if (!custom) return defaultGateway;
    if (custom.endsWith("/")) return custom.slice(0, -1);
    return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded) return {
        uri,
        isOnChain: true,
        isEncoded
    };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave) replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return {
            uri: replacedUri,
            isOnChain: false,
            isEncoded: false
        };
    }
    if ((isIPNS || isIPFS) && target) return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
    };
    else if (protocol === "ar:/" && target) return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
    };
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) // if svg, base64 encode
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
    };
    throw new (0, _ensJs.EnsAvatarUriResolutionError)({
        uri
    });
}
function getJsonImage(data) {
    // validation check for json data, must include one of theses properties
    if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) throw new (0, _ensJs.EnsAvatarInvalidMetadataError)({
        data
    });
    return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
        const res = await fetch(uri).then((res)=>res.json());
        const image = await parseAvatarUri({
            gatewayUrls,
            uri: getJsonImage(res)
        });
        return image;
    } catch  {
        throw new (0, _ensJs.EnsAvatarUriResolutionError)({
            uri
        });
    }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({
        uri,
        gatewayUrls
    });
    if (isOnChain) return resolvedURI;
    // check if resolvedURI is an image, if it is return the url
    const isImage = await isImageUri(resolvedURI);
    if (isImage) return resolvedURI;
    throw new (0, _ensJs.EnsAvatarUriResolutionError)({
        uri
    });
}
function parseNftUri(uri) {
    // parse valid nft spec (CAIP-22/CAIP-29)
    // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs
    if (uri.startsWith("did:nft:")) // convert DID to CAIP
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155") throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: "Only EIP-155 supported"
    });
    if (!chainID) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: "Chain ID not found"
    });
    if (!contractAddress) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: "Contract address not found"
    });
    if (!tokenID) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: "Token ID not found"
    });
    if (!erc_namespace) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: "ERC namespace not found"
    });
    return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress: contractAddress,
        tokenID
    };
}
async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") return (0, _readContractJs.readContract)(client, {
        address: nft.contractAddress,
        abi: [
            {
                name: "tokenURI",
                type: "function",
                stateMutability: "view",
                inputs: [
                    {
                        name: "tokenId",
                        type: "uint256"
                    }
                ],
                outputs: [
                    {
                        name: "",
                        type: "string"
                    }
                ]
            }
        ],
        functionName: "tokenURI",
        args: [
            BigInt(nft.tokenID)
        ]
    });
    if (nft.namespace === "erc1155") return (0, _readContractJs.readContract)(client, {
        address: nft.contractAddress,
        abi: [
            {
                name: "uri",
                type: "function",
                stateMutability: "view",
                inputs: [
                    {
                        name: "_id",
                        type: "uint256"
                    }
                ],
                outputs: [
                    {
                        name: "",
                        type: "string"
                    }
                ]
            }
        ],
        functionName: "uri",
        args: [
            BigInt(nft.tokenID)
        ]
    });
    throw new (0, _ensJs.EnsAvatarUnsupportedNamespaceError)({
        namespace: nft.namespace
    });
}

},{"../../../actions/public/readContract.js":"cW2al","../../../errors/ens.js":"8SkXv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SkXv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EnsAvatarInvalidMetadataError", ()=>EnsAvatarInvalidMetadataError);
parcelHelpers.export(exports, "EnsAvatarInvalidNftUriError", ()=>EnsAvatarInvalidNftUriError);
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>EnsAvatarUriResolutionError);
parcelHelpers.export(exports, "EnsAvatarUnsupportedNamespaceError", ()=>EnsAvatarUnsupportedNamespaceError);
var _baseJs = require("./base.js");
class EnsAvatarInvalidMetadataError extends (0, _baseJs.BaseError) {
    constructor({ data }){
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: [
                "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
                "",
                `Provided data: ${JSON.stringify(data)}`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarInvalidMetadataError"
        });
    }
}
class EnsAvatarInvalidNftUriError extends (0, _baseJs.BaseError) {
    constructor({ reason }){
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarInvalidNftUriError"
        });
    }
}
class EnsAvatarUriResolutionError extends (0, _baseJs.BaseError) {
    constructor({ uri }){
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarUriResolutionError"
        });
    }
}
class EnsAvatarUnsupportedNamespaceError extends (0, _baseJs.BaseError) {
    constructor({ namespace }){
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarUnsupportedNamespaceError"
        });
    }
}

},{"./base.js":"Osf13","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jjum5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets a text record for specified ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsTextParameters}
 * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsText, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const twitterRecord = await getEnsText(client, {
 *   name: normalize('wagmi-dev.eth'),
 *   key: 'com.twitter',
 * })
 * // 'wagmi_sh'
 */ parcelHelpers.export(exports, "getEnsText", ()=>getEnsText);
var _abisJs = require("../../constants/abis.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _chainJs = require("../../utils/chain.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _namehashJs = require("../../utils/ens/namehash.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, _chainJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "ensUniversalResolver"
        });
    }
    const res = await (0, _readContractJs.readContract)(client, {
        address: universalResolverAddress,
        abi: (0, _abisJs.universalResolverAbi),
        functionName: "resolve",
        args: [
            (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name)),
            (0, _encodeFunctionDataJs.encodeFunctionData)({
                abi: (0, _abisJs.textResolverAbi),
                functionName: "text",
                args: [
                    (0, _namehashJs.namehash)(name),
                    key
                ]
            })
        ],
        blockNumber,
        blockTag
    });
    if (res[0] === "0x") return null;
    const record = (0, _decodeFunctionResultJs.decodeFunctionResult)({
        abi: (0, _abisJs.textResolverAbi),
        functionName: "text",
        data: res[0]
    });
    return record === "" ? null : record;
}

},{"../../constants/abis.js":"mYIU4","../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/chain.js":"cruNy","../../utils/encoding/toHex.js":"67sRi","../../utils/ens/namehash.js":"4BqpX","../../utils/ens/packetToBytes.js":"lTeEw","../public/readContract.js":"cW2al","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hg07":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets primary name for specified address.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsName.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
 *
 * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsNameParameters}
 * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsName } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensName = await getEnsName(client, {
 *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
 * })
 * // 'wagmi-dev.eth'
 */ parcelHelpers.export(exports, "getEnsName", ()=>getEnsName);
var _solidityJs = require("../../constants/solidity.js");
var _contractJs = require("../../errors/contract.js");
var _chainJs = require("../../utils/chain.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, _chainJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "ensUniversalResolver"
        });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
        const res = await (0, _readContractJs.readContract)(client, {
            address: universalResolverAddress,
            abi: [
                {
                    name: "reverse",
                    type: "function",
                    stateMutability: "view",
                    inputs: [
                        {
                            type: "bytes",
                            name: "reverseName"
                        }
                    ],
                    outputs: [
                        {
                            type: "string",
                            name: "resolvedName"
                        },
                        {
                            type: "address",
                            name: "resolvedAddress"
                        },
                        {
                            type: "address",
                            name: "reverseResolver"
                        },
                        {
                            type: "address",
                            name: "resolver"
                        }
                    ]
                }
            ],
            functionName: "reverse",
            args: [
                (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(reverseNode))
            ],
            blockNumber,
            blockTag
        });
        return res[0];
    } catch (error) {
        if (error instanceof (0, _contractJs.ContractFunctionExecutionError) && error.cause.reason === (0, _solidityJs.panicReasons)[50]) // No primary name set for address.
        return null;
        throw error;
    }
}

},{"../../constants/solidity.js":"1ySy2","../../errors/contract.js":"3O0YB","../../utils/chain.js":"cruNy","../../utils/encoding/toHex.js":"67sRi","../../utils/ens/packetToBytes.js":"lTeEw","../public/readContract.js":"cW2al","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHjSa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets resolver for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens
 *
 * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsResolverParameters}
 * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsResolver, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const resolverAddress = await getEnsResolver(client, {
 *   name: normalize('wagmi-dev.eth'),
 * })
 * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
 */ parcelHelpers.export(exports, "getEnsResolver", ()=>getEnsResolver);
var _chainJs = require("../../utils/chain.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, _chainJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "ensUniversalResolver"
        });
    }
    const [resolverAddress] = await (0, _readContractJs.readContract)(client, {
        address: universalResolverAddress,
        abi: [
            {
                inputs: [
                    {
                        type: "bytes"
                    }
                ],
                name: "findResolver",
                outputs: [
                    {
                        type: "address"
                    },
                    {
                        type: "bytes32"
                    }
                ],
                stateMutability: "view",
                type: "function"
            }
        ],
        functionName: "findResolver",
        args: [
            (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name))
        ],
        blockNumber,
        blockTag
    });
    return resolverAddress;
}

},{"../../utils/chain.js":"cruNy","../../utils/encoding/toHex.js":"67sRi","../../utils/ens/packetToBytes.js":"lTeEw","../public/readContract.js":"cW2al","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i6JnT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
 *
 * - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html
 * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)
 *
 * @param client - Client to use
 * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createBlockFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createBlockFilter(client)
 * // { id: "0x345a6572337856574a76364e457a4366", type: 'block' }
 */ parcelHelpers.export(exports, "createBlockFilter", ()=>createBlockFilter);
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createBlockFilter(client) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
    });
    const id = await client.request({
        method: "eth_newBlockFilter"
    });
    return {
        id,
        request: getRequest(id),
        type: "block"
    };
}

},{"../../utils/filters/createFilterRequestScope.js":"9kxlX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1UumE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
 *
 * - Docs: https://viem.sh/docs/actions/public/createEventFilter.html
 * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)
 *
 * @param client - Client to use
 * @param parameters - {@link CreateEventFilterParameters}
 * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateEventFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
 * })
 */ parcelHelpers.export(exports, "createEventFilter", ()=>createEventFilter);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createEventFilter(client, { address, args, event, fromBlock, strict, toBlock } = {}) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: "eth_newFilter"
    });
    let topics = [];
    if (event) topics = (0, _encodeEventTopicsJs.encodeEventTopics)({
        abi: [
            event
        ],
        eventName: event.name,
        args
    });
    const id = await client.request({
        method: "eth_newFilter",
        params: [
            {
                address,
                fromBlock: typeof fromBlock === "bigint" ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === "bigint" ? (0, _toHexJs.numberToHex)(toBlock) : toBlock,
                ...topics.length ? {
                    topics
                } : {}
            }
        ]
    });
    return {
        abi: event ? [
            event
        ] : undefined,
        args,
        eventName: event ? event.name : undefined,
        id,
        request: getRequest(id),
        strict,
        type: "event"
    };
}

},{"../../utils/abi/encodeEventTopics.js":"3DslQ","../../utils/encoding/toHex.js":"67sRi","../../utils/filters/createFilterRequestScope.js":"9kxlX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bmuf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).
 *
 * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html
 * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)
 *
 * @param client - Client to use
 * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createPendingTransactionFilter(client)
 * // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' }
 */ parcelHelpers.export(exports, "createPendingTransactionFilter", ()=>createPendingTransactionFilter);
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createPendingTransactionFilter(client) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
    });
    const id = await client.request({
        method: "eth_newPendingTransactionFilter"
    });
    return {
        id,
        request: getRequest(id),
        type: "transaction"
    };
}

},{"../../utils/filters/createFilterRequestScope.js":"9kxlX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"axBLr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the balance of an address in wei.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBalance.html
 * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
 *
 * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html).
 *
 * ```ts
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   blockTag: 'safe'
 * })
 * const balanceAsEther = formatEther(balance)
 * // "6.942"
 * ```
 *
 * @param client - Client to use
 * @param parameters - {@link GetBalanceParameters}
 * @returns The balance of the address in wei. {@link GetBalanceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBalance } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 * // 10000000000000000000000n (wei)
 */ parcelHelpers.export(exports, "getBalance", ()=>getBalance);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const balance = await client.request({
        method: "eth_getBalance",
        params: [
            address,
            blockNumberHex || blockTag
        ]
    });
    return BigInt(balance);
}

},{"../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Dt1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of Transactions at a block number, hash, or tag.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html
 * - JSON-RPC Methods:
 *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.
 *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockTransactionCountParameters}
 * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlockTransactionCount } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const count = await getBlockTransactionCount(client)
 */ parcelHelpers.export(exports, "getBlockTransactionCount", ()=>getBlockTransactionCount);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let count;
    if (blockHash) count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [
            blockHash
        ]
    });
    else count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [
            blockNumberHex || blockTag
        ]
    });
    return (0, _fromHexJs.hexToNumber)(count);
}

},{"../../utils/encoding/fromHex.js":"6RbMz","../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xbQ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Retrieves the bytecode at an address.
 *
 * - Docs: https://viem.sh/docs/contract/getBytecode.html
 * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)
 *
 * @param client - Client to use
 * @param parameters - {@link GetBytecodeParameters}
 * @returns The contract's bytecode. {@link GetBytecodeReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBytecode } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const code = await getBytecode(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 * })
 */ parcelHelpers.export(exports, "getBytecode", ()=>getBytecode);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const hex = await client.request({
        method: "eth_getCode",
        params: [
            address,
            blockNumberHex || blockTag
        ]
    });
    if (hex === "0x") return undefined;
    return hex;
}

},{"../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25O13":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a collection of historical gas information.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html
 * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)
 *
 * @param client - Client to use
 * @param parameters - {@link GetFeeHistoryParameters}
 * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getFeeHistory } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const feeHistory = await getFeeHistory(client, {
 *   blockCount: 4,
 *   rewardPercentiles: [25, 75],
 * })
 */ parcelHelpers.export(exports, "getFeeHistory", ()=>getFeeHistory);
var _toHexJs = require("../../utils/encoding/toHex.js");
var _feeHistoryJs = require("../../utils/formatters/feeHistory.js");
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = blockNumber ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
            (0, _toHexJs.numberToHex)(blockCount),
            blockNumberHex || blockTag,
            rewardPercentiles
        ]
    });
    return (0, _feeHistoryJs.formatFeeHistory)(feeHistory);
}

},{"../../utils/encoding/toHex.js":"67sRi","../../utils/formatters/feeHistory.js":"8UycI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8UycI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatFeeHistory", ()=>formatFeeHistory);
function formatFeeHistory(feeHistory) {
    return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value)=>BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward)=>reward.map((value)=>BigInt(value)))
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PG0x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs since the filter was created.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html
 * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)
 *
 * `getFilterLogs` is only compatible with **event filters**.
 *
 * @param client - Client to use
 * @param parameters - {@link GetFilterLogsParameters}
 * @returns A list of event logs. {@link GetFilterLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter, getFilterLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
 * })
 * const logs = await getFilterLogs(client, { filter })
 */ parcelHelpers.export(exports, "getFilterLogs", ()=>getFilterLogs);
var _abiJs = require("../../errors/abi.js");
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _logJs = require("../../utils/formatters/log.js");
async function getFilterLogs(_client, { filter }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [
            filter.id
        ]
    });
    return logs.map((log)=>{
        try {
            const { eventName, args } = "abi" in filter && filter.abi ? (0, _decodeEventLogJs.decodeEventLog)({
                abi: filter.abi,
                data: log.data,
                topics: log.topics,
                strict
            }) : {
                eventName: undefined,
                args: undefined
            };
            return (0, _logJs.formatLog)(log, {
                args,
                eventName
            });
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if ("strict" in filter && filter.strict) return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!("name" in x && x.name));
            }
            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return (0, _logJs.formatLog)(log, {
                args: isUnnamed ? [] : {},
                eventName
            });
        }
    }).filter(Boolean);
}

},{"../../errors/abi.js":"l5DIr","../../utils/abi/decodeEventLog.js":"htH60","../../utils/formatters/log.js":"7uIcs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltqLa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the value from a storage slot at a given address.
 *
 * - Docs: https://viem.sh/docs/contract/getStorageAt.html
 * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)
 *
 * @param client - Client to use
 * @param parameters - {@link GetStorageAtParameters}
 * @returns The value of the storage slot. {@link GetStorageAtReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getStorageAt } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const code = await getStorageAt(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   slot: toHex(0),
 * })
 */ parcelHelpers.export(exports, "getStorageAt", ()=>getStorageAt);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const data = await client.request({
        method: "eth_getStorageAt",
        params: [
            address,
            slot,
            blockNumberHex || blockTag
        ]
    });
    return data;
}

},{"../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6bI7T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransaction.html
 * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionParameters}
 * @returns The transaction information. {@link GetTransactionReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransaction } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transaction = await getTransaction(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransaction", ()=>getTransaction);
var _transactionJs = require("../../errors/transaction.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _transactionJs1 = require("../../utils/formatters/transaction.js");
async function getTransaction(client, { blockHash, blockNumber, blockTag = "latest", hash, index }) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let transaction = null;
    if (hash) transaction = await client.request({
        method: "eth_getTransactionByHash",
        params: [
            hash
        ]
    });
    else if (blockHash) transaction = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [
            blockHash,
            (0, _toHexJs.numberToHex)(index)
        ]
    });
    else if (blockNumberHex || blockTag) transaction = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [
            blockNumberHex || blockTag,
            (0, _toHexJs.numberToHex)(index)
        ]
    });
    if (!transaction) throw new (0, _transactionJs.TransactionNotFoundError)({
        blockHash,
        blockNumber,
        blockTag,
        hash,
        index
    });
    const format = client.chain?.formatters?.transaction?.format || (0, _transactionJs1.formatTransaction);
    return format(transaction);
}

},{"../../errors/transaction.js":"3UjDK","../../utils/encoding/toHex.js":"67sRi","../../utils/formatters/transaction.js":"cumRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iw7hW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html
 * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionConfirmationsParameters}
 * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionConfirmations } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const confirmations = await getTransactionConfirmations(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransactionConfirmations", ()=>getTransactionConfirmations);
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getTransactionJs = require("./getTransaction.js");
async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
        (0, _getBlockNumberJs.getBlockNumber)(client),
        hash ? (0, _getTransactionJs.getTransaction)(client, {
            hash
        }) : undefined
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber) return 0n;
    return blockNumber - transactionBlockNumber + 1n;
}

},{"./getBlockNumber.js":"8c8Ud","./getTransaction.js":"6bI7T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4OQFf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html
 * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionReceiptParameters}
 * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionReceipt } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionReceipt = await getTransactionReceipt(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransactionReceipt", ()=>getTransactionReceipt);
var _transactionJs = require("../../errors/transaction.js");
var _transactionReceiptJs = require("../../utils/formatters/transactionReceipt.js");
async function getTransactionReceipt(client, { hash }) {
    const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [
            hash
        ]
    });
    if (!receipt) throw new (0, _transactionJs.TransactionReceiptNotFoundError)({
        hash
    });
    const format = client.chain?.formatters?.transactionReceipt?.format || (0, _transactionReceiptJs.formatTransactionReceipt);
    return format(receipt);
}

},{"../../errors/transaction.js":"3UjDK","../../utils/formatters/transactionReceipt.js":"7zuER","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gj4sq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).
 *
 * - Docs: https://viem.sh/docs/contract/multicall.html
 *
 * @param client - Client to use
 * @param parameters - {@link MulticallParameters}
 * @returns An array of results with accompanying status. {@link MulticallReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { multicall } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const abi = parseAbi([
 *   'function balanceOf(address) view returns (uint256)',
 *   'function totalSupply() view returns (uint256)',
 * ])
 * const results = await multicall(client, {
 *   contracts: [
 *     {
 *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *       abi,
 *       functionName: 'balanceOf',
 *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 *     },
 *     {
 *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *       abi,
 *       functionName: 'totalSupply',
 *     },
 *   ],
 * })
 * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]
 */ parcelHelpers.export(exports, "multicall", ()=>multicall);
var _abisJs = require("../../constants/abis.js");
var _abiJs = require("../../errors/abi.js");
var _contractJs = require("../../errors/contract.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _chainJs = require("../../utils/chain.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _readContractJs = require("./readContract.js");
async function multicall(client, args) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    // Fix type cast from `Narrow` in type definition.
    const contracts = contracts_;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain) throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, _chainJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: "multicall3"
        });
    }
    const chunkedCalls = [
        []
    ];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for(let i = 0; i < contracts.length; i++){
        const { abi, address, args, functionName } = contracts[i];
        try {
            const callData = (0, _encodeFunctionDataJs.encodeFunctionData)({
                abi,
                args,
                functionName
            });
            currentChunkSize += callData.length;
            if (batchSize > 0 && currentChunkSize > batchSize) {
                currentChunk++;
                currentChunkSize = (callData.length - 2) / 2;
                chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData,
                    target: address
                }
            ];
        } catch (err) {
            const error = (0, _getContractErrorJs.getContractError)(err, {
                abi,
                address,
                args,
                docsPath: "/docs/contract/multicall",
                functionName
            });
            if (!allowFailure) throw error;
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData: "0x",
                    target: address
                }
            ];
        }
    }
    const results = await Promise.all(chunkedCalls.map((calls)=>(0, _readContractJs.readContract)(client, {
            abi: (0, _abisJs.multicall3Abi),
            address: multicallAddress,
            args: [
                calls
            ],
            blockNumber,
            blockTag,
            functionName: "aggregate3"
        })));
    return results.flat().map(({ returnData, success }, i)=>{
        const calls = chunkedCalls.flat();
        const { callData } = calls[i];
        const { abi, address, functionName, args } = contracts[i];
        try {
            if (callData === "0x") throw new (0, _abiJs.AbiDecodingZeroDataError)();
            if (!success) throw new (0, _contractJs.RawContractError)({
                data: returnData
            });
            const result = (0, _decodeFunctionResultJs.decodeFunctionResult)({
                abi,
                args,
                data: returnData,
                functionName: functionName
            });
            return allowFailure ? {
                result,
                status: "success"
            } : result;
        } catch (err) {
            const error = (0, _getContractErrorJs.getContractError)(err, {
                abi,
                address,
                args,
                docsPath: "/docs/contract/multicall",
                functionName
            });
            if (!allowFailure) throw error;
            return {
                error,
                result: undefined,
                status: "failure"
            };
        }
    });
}

},{"../../constants/abis.js":"mYIU4","../../errors/abi.js":"l5DIr","../../errors/contract.js":"3O0YB","../../utils/abi/decodeFunctionResult.js":"gez2c","../../utils/abi/encodeFunctionData.js":"b9Kue","../../utils/chain.js":"cruNy","../../utils/errors/getContractError.js":"iYnRt","./readContract.js":"cW2al","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Soif":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that a message was signed by the provided address.
 *
 * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
 *
 * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage.html}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */ parcelHelpers.export(exports, "verifyMessage", ()=>verifyMessage);
var _indexJs = require("../../utils/index.js");
var _verifyHashJs = require("./verifyHash.js");
async function verifyMessage(client, { address, message, signature, ...callRequest }) {
    const hash = (0, _indexJs.hashMessage)(message);
    return (0, _verifyHashJs.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
    });
}

},{"../../utils/index.js":"9pB6K","./verifyHash.js":"hv55p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hv55p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verifies a message hash on chain using ERC-6492.
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyHashParameters}
 * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
 */ parcelHelpers.export(exports, "verifyHash", ()=>verifyHash);
var _abisJs = require("../../constants/abis.js");
var _contractsJs = require("../../constants/contracts.js");
var _contractJs = require("../../errors/contract.js");
var _isBytesEqualJs = require("../../utils/data/isBytesEqual.js");
var _indexJs = require("../../utils/index.js");
var _callJs = require("./call.js");
async function verifyHash(client, { address, hash, signature, ...callRequest }) {
    const signatureHex = (0, _indexJs.isHex)(signature) ? signature : (0, _indexJs.toHex)(signature);
    try {
        const { data } = await (0, _callJs.call)(client, {
            data: (0, _indexJs.encodeDeployData)({
                abi: (0, _abisJs.universalSignatureValidatorAbi),
                args: [
                    address,
                    hash,
                    signatureHex
                ],
                bytecode: (0, _contractsJs.universalSignatureValidatorByteCode)
            }),
            ...callRequest
        });
        return (0, _isBytesEqualJs.isBytesEqual)(data ?? "0x0", "0x1");
    } catch (error) {
        if (error instanceof (0, _contractJs.CallExecutionError)) // if the execution fails, the signature was not valid and an internal method inside of the validator reverted
        // this can happen for many reasons, for example if signer can not be recovered from the signature
        // or if the signature has no valid format
        return false;
        throw error;
    }
}

},{"../../constants/abis.js":"mYIU4","../../constants/contracts.js":"3IalV","../../errors/contract.js":"3O0YB","../../utils/data/isBytesEqual.js":"5F6Ll","../../utils/index.js":"9pB6K","./call.js":"8bUID","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3IalV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "universalSignatureValidatorByteCode", ()=>universalSignatureValidatorByteCode);
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5F6Ll":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBytesEqual", ()=>isBytesEqual);
var _indexJs = require("../../index.js");
var _utils = require("@noble/curves/abstract/utils");
function isBytesEqual(a_, b_) {
    const a = (0, _indexJs.isHex)(a_) ? (0, _indexJs.toBytes)(a_) : a_;
    const b = (0, _indexJs.isHex)(b_) ? (0, _indexJs.toBytes)(b_) : b_;
    return (0, _utils.equalBytes)(a, b);
}

},{"../../index.js":"eKtik","@noble/curves/abstract/utils":"ebfN0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ebfN0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a)=>a instanceof Uint8Array;
const hexes = Array.from({
    length: 256
}, (v, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    // Big Endian
    return BigInt(hex === "" ? "0" : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    if (hex.length % 2) throw new Error("hex string is invalid: unpadded " + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// Big Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!u8a(bytes)) throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
const numberToBytesBE = (n, len)=>hexToBytes(n.toString(16).padStart(len * 2, "0"));
exports.numberToBytesBE = numberToBytesBE;
const numberToBytesLE = (n, len)=>(0, exports.numberToBytesBE)(n, len).reverse();
exports.numberToBytesLE = numberToBytesLE;
// Returns variable number bytes (minimal bigint encoding?)
const numberToVarBytesBE = (n)=>hexToBytes(numberToHexUnpadded(n));
exports.numberToVarBytesBE = numberToVarBytesBE;
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
    else if (u8a(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(`${title} must be hex string or Uint8Array`);
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
// Copies several Uint8Arrays into one.
function concatBytes(...arrs) {
    const r = new Uint8Array(arrs.reduce((sum, a)=>sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrs.forEach((a)=>{
        if (!u8a(a)) throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length) return false;
    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;
    return true;
}
exports.equalBytes = equalBytes;
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
// Amount of bits inside bigint (Same as n.toString(2).length)
function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
exports.bitLen = bitLen;
// Gets single bit at position. NOTE: first bit position is 0 (same as arrays)
// Same as !!+Array.from(n.toString(2)).reverse()[pos]
const bitGet = (n, pos)=>n >> BigInt(pos) & _1n;
exports.bitGet = bitGet;
// Sets single bit at position
const bitSet = (n, pos, value)=>n | (value ? _1n : _0n) << BigInt(pos);
exports.bitSet = bitSet;
// Return mask for N bits (Same as BigInt(`0b${Array(i).fill('1').join('')}`))
// Not using ** operator with bigints for old engines.
const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data)=>new Uint8Array(data); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n())=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === "bigint",
    function: (val)=>typeof val === "function",
    boolean: (val)=>typeof val === "boolean",
    string: (val)=>typeof val === "string",
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject; // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

},{}],"bNj6R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that typed data was signed by the provided address.
 *
 * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData.html}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyTypedDataParameters}
 * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
 */ parcelHelpers.export(exports, "verifyTypedData", ()=>verifyTypedData);
var _hashTypedDataJs = require("../../utils/signature/hashTypedData.js");
var _verifyHashJs = require("./verifyHash.js");
async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
    const hash = (0, _hashTypedDataJs.hashTypedData)({
        message,
        primaryType,
        types,
        domain
    });
    return (0, _verifyHashJs.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
    });
}

},{"../../utils/signature/hashTypedData.js":"lc1dU","./verifyHash.js":"hv55p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cLOTh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.
 *
 * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html
 * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions
 * - JSON-RPC Methods:
 *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.
 *   - If a Transaction has been replaced:
 *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions
 *     - Checks if one of the Transactions is a replacement
 *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).
 *
 * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).
 *
 * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.
 *
 * There are 3 types of Transaction Replacement reasons:
 *
 * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)
 * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)
 * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)
 *
 * @param client - Client to use
 * @param parameters - {@link WaitForTransactionReceiptParameters}
 * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}
 *
 * @example
 * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionReceipt = await waitForTransactionReceipt(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "waitForTransactionReceipt", ()=>waitForTransactionReceipt);
var _transactionJs = require("../../errors/transaction.js");
var _observeJs = require("../../utils/observe.js");
var _withRetryJs = require("../../utils/promise/withRetry.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockJs = require("./getBlock.js");
var _getTransactionJs = require("./getTransaction.js");
var _getTransactionReceiptJs = require("./getTransactionReceipt.js");
var _watchBlockNumberJs = require("./watchBlockNumber.js");
async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
    const observerId = (0, _stringifyJs.stringify)([
        "waitForTransactionReceipt",
        client.uid,
        hash
    ]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    return new Promise((resolve, reject)=>{
        if (timeout) setTimeout(()=>reject(new (0, _transactionJs.WaitForTransactionReceiptTimeoutError)({
                hash
            })), timeout);
        const _unobserve = (0, _observeJs.observe)(observerId, {
            onReplaced,
            resolve,
            reject
        }, (emit)=>{
            const unwatch = (0, _watchBlockNumberJs.watchBlockNumber)(client, {
                emitMissed: true,
                emitOnBegin: true,
                poll: true,
                pollingInterval,
                async onBlockNumber (blockNumber_) {
                    if (retrying) return;
                    let blockNumber = blockNumber_;
                    const done = async (fn)=>{
                        unwatch();
                        fn();
                        _unobserve();
                    };
                    try {
                        // If we already have a valid receipt, let's check if we have enough
                        // confirmations. If we do, then we can resolve.
                        if (receipt) {
                            if (blockNumber - receipt.blockNumber + 1n < confirmations) return;
                            done(()=>emit.resolve(receipt));
                            return;
                        }
                        // Get the transaction to check if it's been replaced.
                        // We need to retry as some RPC Providers may be slow to sync
                        // up mined transactions.
                        if (!transaction) {
                            retrying = true;
                            await (0, _withRetryJs.withRetry)(async ()=>{
                                transaction = await (0, _getTransactionJs.getTransaction)(client, {
                                    hash
                                });
                                if (transaction.blockNumber) blockNumber = transaction.blockNumber;
                            }, {
                                // exponential backoff
                                delay: ({ count })=>~~(1 << count) * 200,
                                retryCount: 6
                            });
                            retrying = false;
                        }
                        // Get the receipt to check if it's been processed.
                        receipt = await (0, _getTransactionReceiptJs.getTransactionReceipt)(client, {
                            hash
                        });
                        // Check if we have enough confirmations. If not, continue polling.
                        if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations) return;
                        done(()=>emit.resolve(receipt));
                    } catch (err) {
                        // If the receipt is not found, the transaction will be pending.
                        // We need to check if it has potentially been replaced.
                        if (transaction && (err instanceof (0, _transactionJs.TransactionNotFoundError) || err instanceof (0, _transactionJs.TransactionReceiptNotFoundError))) {
                            replacedTransaction = transaction;
                            // Let's retrieve the transactions from the current block.
                            const block = await (0, _getBlockJs.getBlock)(client, {
                                blockNumber,
                                includeTransactions: true
                            });
                            const replacementTransaction = block.transactions.find(({ from, nonce })=>from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                            // If we couldn't find a replacement transaction, continue polling.
                            if (!replacementTransaction) return;
                            // If we found a replacement transaction, return it's receipt.
                            receipt = await (0, _getTransactionReceiptJs.getTransactionReceipt)(client, {
                                hash: replacementTransaction.hash
                            });
                            // Check if we have enough confirmations. If not, continue polling.
                            if (blockNumber - receipt.blockNumber + 1n < confirmations) return;
                            let reason = "replaced";
                            if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) reason = "repriced";
                            else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) reason = "cancelled";
                            done(()=>{
                                emit.onReplaced?.({
                                    reason,
                                    replacedTransaction: replacedTransaction,
                                    transaction: replacementTransaction,
                                    transactionReceipt: receipt
                                });
                                emit.resolve(receipt);
                            });
                        } else done(()=>emit.reject(err));
                    }
                }
            });
            return unwatch;
        });
    });
}

},{"../../errors/transaction.js":"3UjDK","../../utils/observe.js":"5tvm0","../../utils/promise/withRetry.js":"k5h7H","../../utils/stringify.js":"e0Ibk","./getBlock.js":"eKkgZ","./getTransaction.js":"6bI7T","./getTransactionReceipt.js":"4OQFf","./watchBlockNumber.js":"a2Skw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2Skw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns incoming block numbers.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks
 * - JSON-RPC Methods:
 *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchBlockNumberParameters}
 * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}
 *
 * @example
 * import { createPublicClient, watchBlockNumber, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchBlockNumber(client, {
 *   onBlockNumber: (blockNumber) => console.log(blockNumber),
 * })
 */ parcelHelpers.export(exports, "watchBlockNumber", ()=>watchBlockNumber);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlockNumber;
    const pollBlockNumber = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            "watchBlockNumber",
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onBlockNumber,
            onError
        }, (emit)=>(0, _pollJs.poll)(async ()=>{
                try {
                    const blockNumber = await (0, _getBlockNumberJs.getBlockNumber)(client, {
                        maxAge: 0
                    });
                    if (prevBlockNumber) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (blockNumber === prevBlockNumber) return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (blockNumber - prevBlockNumber > 1 && emitMissed) for(let i = prevBlockNumber + 1n; i < blockNumber; i++){
                            emit.onBlockNumber(i, prevBlockNumber);
                            prevBlockNumber = i;
                        }
                    }
                    // If the next block number is greater than the previous,
                    // it is not in the past, and we can emit the new block number.
                    if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                        emit.onBlockNumber(blockNumber, prevBlockNumber);
                        prevBlockNumber = blockNumber;
                    }
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval
            }));
    };
    const subscribeBlockNumber = ()=>{
        let active = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: [
                        "newHeads"
                    ],
                    onData (data) {
                        if (!active) return;
                        const blockNumber = (0, _fromHexJs.hexToBigInt)(data.result?.number);
                        onBlockNumber(blockNumber, prevBlockNumber);
                        prevBlockNumber = blockNumber;
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

},{"../../utils/encoding/fromHex.js":"6RbMz","../../utils/observe.js":"5tvm0","../../utils/poll.js":"akoxB","../../utils/stringify.js":"e0Ibk","./getBlockNumber.js":"8c8Ud","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"o4Ph4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns information for incoming blocks.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks
 * - JSON-RPC Methods:
 *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchBlocksParameters}
 * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}
 *
 * @example
 * import { createPublicClient, watchBlocks, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchBlocks(client, {
 *   onBlock: (block) => console.log(block),
 * })
 */ parcelHelpers.export(exports, "watchBlocks", ()=>watchBlocks);
var _blockJs = require("../../utils/formatters/block.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockJs = require("./getBlock.js");
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions = false, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlock;
    const pollBlocks = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            "watchBlocks",
            client.uid,
            emitMissed,
            emitOnBegin,
            includeTransactions,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onBlock,
            onError
        }, (emit)=>(0, _pollJs.poll)(async ()=>{
                try {
                    const block = await (0, _getBlockJs.getBlock)(client, {
                        blockTag,
                        includeTransactions
                    });
                    if (block.number && prevBlock?.number) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (block.number === prevBlock.number) return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (block.number - prevBlock.number > 1 && emitMissed) for(let i = prevBlock?.number + 1n; i < block.number; i++){
                            const block = await (0, _getBlockJs.getBlock)(client, {
                                blockNumber: i,
                                includeTransactions
                            });
                            emit.onBlock(block, prevBlock);
                            prevBlock = block;
                        }
                    }
                    if (// If no previous block exists, emit.
                    !prevBlock?.number || // If the block tag is "pending" with no block number, emit.
                    blockTag === "pending" && !block?.number || // If the next block number is greater than the previous block number, emit.
                    // We don't want to emit blocks in the past.
                    block.number && block.number > prevBlock.number) {
                        emit.onBlock(block, prevBlock);
                        prevBlock = block;
                    }
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval
            }));
    };
    const subscribeBlocks = ()=>{
        let active = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: [
                        "newHeads"
                    ],
                    onData (data) {
                        if (!active) return;
                        const format = client.chain?.formatters?.block?.format || (0, _blockJs.formatBlock);
                        const block = format(data.result);
                        onBlock(block, prevBlock);
                        prevBlock = block;
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
}

},{"../../utils/formatters/block.js":"iBInX","../../utils/observe.js":"5tvm0","../../utils/poll.js":"akoxB","../../utils/stringify.js":"e0Ibk","./getBlock.js":"eKkgZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxvs7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log).
 *
 * - Docs: https://viem.sh/docs/actions/public/watchEvent.html
 * - JSON-RPC Methods:
 *   - **RPC Provider supports `eth_newFilter`:**
 *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
 *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
 *   - **RPC Provider does not support `eth_newFilter`:**
 *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.
 *
 * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs).
 *
 * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchEventParameters}
 * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchEvent } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchEvent(client, {
 *   onLogs: (logs) => console.log(logs),
 * })
 */ parcelHelpers.export(exports, "watchEvent", ()=>watchEvent);
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _createEventFilterJs = require("./createEventFilter.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _getLogsJs = require("./getLogs.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchEvent(client, { address, args, batch = true, event, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const observerId = (0, _stringifyJs.stringify)([
        "watchEvent",
        address,
        args,
        batch,
        client.uid,
        event,
        pollingInterval
    ]);
    const strict = strict_ ?? false;
    return (0, _observeJs.observe)(observerId, {
        onLogs,
        onError
    }, (emit)=>{
        let previousBlockNumber;
        let filter;
        let initialized = false;
        const unwatch = (0, _pollJs.poll)(async ()=>{
            if (!initialized) {
                try {
                    filter = await (0, _createEventFilterJs.createEventFilter)(client, {
                        address,
                        args,
                        event: event,
                        strict
                    });
                } catch  {}
                initialized = true;
                return;
            }
            try {
                let logs;
                if (filter) logs = await (0, _getFilterChangesJs.getFilterChanges)(client, {
                    filter
                });
                else {
                    // If the filter doesn't exist, we will fall back to use `getLogs`.
                    // The fall back exists because some RPC Providers do not support filters.
                    // Fetch the block number to use for `getLogs`.
                    const blockNumber = await (0, _getBlockNumberJs.getBlockNumber)(client);
                    // If the block number has changed, we will need to fetch the logs.
                    // If the block number doesn't exist, we are yet to reach the first poll interval,
                    // so do not emit any logs.
                    if (previousBlockNumber && previousBlockNumber !== blockNumber) logs = await (0, _getLogsJs.getLogs)(client, {
                        address,
                        args,
                        fromBlock: previousBlockNumber + 1n,
                        toBlock: blockNumber,
                        event: event
                    });
                    else logs = [];
                    previousBlockNumber = blockNumber;
                }
                if (logs.length === 0) return;
                if (batch) emit.onLogs(logs);
                else logs.forEach((log)=>emit.onLogs([
                        log
                    ]));
            } catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin: true,
            interval: pollingInterval
        });
        return async ()=>{
            if (filter) await (0, _uninstallFilterJs.uninstallFilter)(client, {
                filter
            });
            unwatch();
        };
    });
}

},{"../../utils/observe.js":"5tvm0","../../utils/poll.js":"akoxB","../../utils/stringify.js":"e0Ibk","./createEventFilter.js":"1UumE","./getBlockNumber.js":"8c8Ud","./getFilterChanges.js":"1gr1F","./getLogs.js":"2mlJj","./uninstallFilter.js":"3qnsl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ITxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns pending transaction hashes.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html
 * - JSON-RPC Methods:
 *   - When `poll: true`
 *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.
 *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event.
 *
 * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).
 *
 * @param client - Client to use
 * @param parameters - {@link WatchPendingTransactionsParameters}
 * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchPendingTransactions } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = await watchPendingTransactions(client, {
 *   onTransactions: (hashes) => console.log(hashes),
 * })
 */ parcelHelpers.export(exports, "watchPendingTransactions", ()=>watchPendingTransactions);
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _createPendingTransactionFilterJs = require("./createPendingTransactionFilter.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    const pollPendingTransactions = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            "watchPendingTransactions",
            client.uid,
            batch,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onTransactions,
            onError
        }, (emit)=>{
            let filter;
            const unwatch = (0, _pollJs.poll)(async ()=>{
                try {
                    if (!filter) try {
                        filter = await (0, _createPendingTransactionFilterJs.createPendingTransactionFilter)(client);
                        return;
                    } catch (err) {
                        unwatch();
                        throw err;
                    }
                    const hashes = await (0, _getFilterChangesJs.getFilterChanges)(client, {
                        filter
                    });
                    if (hashes.length === 0) return;
                    if (batch) emit.onTransactions(hashes);
                    else hashes.forEach((hash)=>emit.onTransactions([
                            hash
                        ]));
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval
            });
            return async ()=>{
                if (filter) await (0, _uninstallFilterJs.uninstallFilter)(client, {
                    filter
                });
                unwatch();
            };
        });
    };
    const subscribePendingTransactions = ()=>{
        let active = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: [
                        "newPendingTransactions"
                    ],
                    onData (data) {
                        if (!active) return;
                        const transaction = data.result;
                        onTransactions([
                            transaction
                        ]);
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return unsubscribe;
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

},{"../../utils/observe.js":"5tvm0","../../utils/poll.js":"akoxB","../../utils/stringify.js":"e0Ibk","./createPendingTransactionFilter.js":"1bmuf","./getFilterChanges.js":"1gr1F","./uninstallFilter.js":"3qnsl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fHnsm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "walletActions", ()=>walletActions);
var _getChainIdJs = require("../../actions/public/getChainId.js");
var _addChainJs = require("../../actions/wallet/addChain.js");
var _deployContractJs = require("../../actions/wallet/deployContract.js");
var _getAddressesJs = require("../../actions/wallet/getAddresses.js");
var _getPermissionsJs = require("../../actions/wallet/getPermissions.js");
var _requestAddressesJs = require("../../actions/wallet/requestAddresses.js");
var _requestPermissionsJs = require("../../actions/wallet/requestPermissions.js");
var _sendTransactionJs = require("../../actions/wallet/sendTransaction.js");
var _signMessageJs = require("../../actions/wallet/signMessage.js");
var _signTypedDataJs = require("../../actions/wallet/signTypedData.js");
var _switchChainJs = require("../../actions/wallet/switchChain.js");
var _watchAssetJs = require("../../actions/wallet/watchAsset.js");
var _writeContractJs = require("../../actions/wallet/writeContract.js");
const walletActions = (client)=>({
        addChain: (args)=>(0, _addChainJs.addChain)(client, args),
        deployContract: (args)=>(0, _deployContractJs.deployContract)(client, args),
        getAddresses: ()=>(0, _getAddressesJs.getAddresses)(client),
        getChainId: ()=>(0, _getChainIdJs.getChainId)(client),
        getPermissions: ()=>(0, _getPermissionsJs.getPermissions)(client),
        requestAddresses: ()=>(0, _requestAddressesJs.requestAddresses)(client),
        requestPermissions: (args)=>(0, _requestPermissionsJs.requestPermissions)(client, args),
        sendTransaction: (args)=>(0, _sendTransactionJs.sendTransaction)(client, args),
        signMessage: (args)=>(0, _signMessageJs.signMessage)(client, args),
        signTypedData: (args)=>(0, _signTypedDataJs.signTypedData)(client, args),
        switchChain: (args)=>(0, _switchChainJs.switchChain)(client, args),
        watchAsset: (args)=>(0, _watchAssetJs.watchAsset)(client, args),
        writeContract: (args)=>(0, _writeContractJs.writeContract)(client, args)
    });

},{"../../actions/public/getChainId.js":"gyNal","../../actions/wallet/addChain.js":"a5HPl","../../actions/wallet/deployContract.js":"gPWCK","../../actions/wallet/getAddresses.js":"8XlPs","../../actions/wallet/getPermissions.js":"5KvEh","../../actions/wallet/requestAddresses.js":"izn4t","../../actions/wallet/requestPermissions.js":"2OZKN","../../actions/wallet/sendTransaction.js":"c6D87","../../actions/wallet/signMessage.js":"gFyZI","../../actions/wallet/signTypedData.js":"4moTr","../../actions/wallet/switchChain.js":"gEbcp","../../actions/wallet/watchAsset.js":"gUcMZ","../../actions/wallet/writeContract.js":"6s57Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gPWCK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Deploys a contract to the network, given bytecode and constructor arguments.
 *
 * - Docs: https://viem.sh/docs/contract/deployContract.html
 * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts
 *
 * @param client - Client to use
 * @param parameters - {@link DeployContractParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link DeployContractReturnType}
 *
 * @example
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { deployContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x…'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await deployContract(client, {
 *   abi: [],
 *   account: '0x…,
 *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
 * })
 */ parcelHelpers.export(exports, "deployContract", ()=>deployContract);
var _encodeDeployDataJs = require("../../utils/abi/encodeDeployData.js");
var _sendTransactionJs = require("./sendTransaction.js");
function deployContract(walletClient, { abi, args, bytecode, ...request }) {
    const calldata = (0, _encodeDeployDataJs.encodeDeployData)({
        abi,
        args,
        bytecode
    });
    return (0, _sendTransactionJs.sendTransaction)(walletClient, {
        ...request,
        data: calldata
    });
}

},{"../../utils/abi/encodeDeployData.js":"1fOog","./sendTransaction.js":"c6D87","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XlPs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of account addresses owned by the wallet or client.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getAddresses.html
 * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
 *
 * @param client - Client to use
 * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await getAddresses(client)
 */ parcelHelpers.export(exports, "getAddresses", ()=>getAddresses);
var _getAddressJs = require("../../utils/address/getAddress.js");
async function getAddresses(client) {
    const addresses = await client.request({
        method: "eth_accounts"
    });
    return addresses.map((address)=>(0, _getAddressJs.checksumAddress)(address));
}

},{"../../utils/address/getAddress.js":"1Wg1M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KvEh":[function(require,module,exports) {
/**
 * Gets the wallets current permissions.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getPermissions.html
 * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @returns The wallet permissions. {@link GetPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await getPermissions(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getPermissions", ()=>getPermissions);
async function getPermissions(client) {
    const permissions = await client.request({
        method: "wallet_getPermissions"
    });
    return permissions;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"izn4t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Requests a list of accounts managed by a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses.html
 * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
 *
 * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).
 *
 * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.
 *
 * @param client - Client to use
 * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await requestAddresses(client)
 */ parcelHelpers.export(exports, "requestAddresses", ()=>requestAddresses);
var _getAddressJs = require("../../utils/address/getAddress.js");
async function requestAddresses(client) {
    const addresses = await client.request({
        method: "eth_requestAccounts"
    });
    return addresses.map((address)=>(0, _getAddressJs.getAddress)(address));
}

},{"../../utils/address/getAddress.js":"1Wg1M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2OZKN":[function(require,module,exports) {
/**
 * Requests permissions for a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions.html
 * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @param parameters - {@link RequestPermissionsParameters}
 * @returns The wallet permissions. {@link RequestPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await requestPermissions(client, {
 *   eth_accounts: {}
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestPermissions", ()=>requestPermissions);
async function requestPermissions(client, permissions) {
    return client.request({
        method: "wallet_requestPermissions",
        params: [
            permissions
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gFyZI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * With the calculated signature, you can:
 * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,
 * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.
 *
 * @param client - Client to use
 * @param parameters - {@link SignMessageParameters}
 * @returns The signed message. {@link SignMessageReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   message: 'hello world',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x…'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   message: 'hello world',
 * })
 */ parcelHelpers.export(exports, "signMessage", ()=>signMessage);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: "/docs/actions/wallet/signMessage"
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    if (account.type === "local") return account.signMessage({
        message
    });
    const message_ = (()=>{
        if (typeof message === "string") return (0, _toHexJs.stringToHex)(message);
        if (message.raw instanceof Uint8Array) return (0, _toHexJs.toHex)(message.raw);
        return message.raw;
    })();
    return client.request({
        method: "personal_sign",
        params: [
            message_,
            account.address
        ]
    });
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../errors/account.js":"8zVdX","../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4moTr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param client - Client to use
 * @param parameters - {@link SignTypedDataParameters}
 * @returns The signed data. {@link SignTypedDataReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTypedData(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x…'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signTypedData(client, {
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 */ parcelHelpers.export(exports, "signTypedData", ()=>signTypedData);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _isHexJs = require("../../utils/data/isHex.js");
var _stringifyJs = require("../../utils/stringify.js");
var _typedDataJs = require("../../utils/typedData.js");
async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: "/docs/actions/wallet/signTypedData"
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    const types = {
        EIP712Domain: [
            typeof domain?.name === "string" && {
                name: "name",
                type: "string"
            },
            domain?.version && {
                name: "version",
                type: "string"
            },
            typeof domain?.chainId === "number" && {
                name: "chainId",
                type: "uint256"
            },
            domain?.verifyingContract && {
                name: "verifyingContract",
                type: "address"
            },
            domain?.salt && {
                name: "salt",
                type: "bytes32"
            }
        ].filter(Boolean),
        ...types_
    };
    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
    // as we can't statically check this with TypeScript.
    (0, _typedDataJs.validateTypedData)({
        domain,
        message,
        primaryType,
        types
    });
    if (account.type === "local") return account.signTypedData({
        domain,
        primaryType,
        types,
        message
    });
    const typedData = (0, _stringifyJs.stringify)({
        domain: domain ?? {},
        primaryType,
        types,
        message
    }, (_, value)=>(0, _isHexJs.isHex)(value) ? value.toLowerCase() : value);
    return client.request({
        method: "eth_signTypedData_v4",
        params: [
            account.address,
            typedData
        ]
    });
}

},{"../../accounts/utils/parseAccount.js":"6mF64","../../errors/account.js":"8zVdX","../../utils/data/isHex.js":"gOtuZ","../../utils/stringify.js":"e0Ibk","../../utils/typedData.js":"hwT9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gEbcp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Switch the target chain in a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/switchChain.html
 * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
 *
 * @param client - Client to use
 * @param parameters - {@link SwitchChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet, optimism } from 'viem/chains'
 * import { switchChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * await switchChain(client, { id: optimism.id })
 */ parcelHelpers.export(exports, "switchChain", ()=>switchChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function switchChain(client, { id }) {
    await client.request({
        method: "wallet_switchEthereumChain",
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id)
            }
        ]
    });
}

},{"../../utils/encoding/toHex.js":"67sRi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gUcMZ":[function(require,module,exports) {
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/watchAsset.html
 * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)
 *
 * @param client - Client to use
 * @param parameters - {@link WatchAssetParameters}
 * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchAsset } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const success = await watchAsset(client, {
 *   type: 'ERC20',
 *   options: {
 *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *     decimals: 18,
 *     symbol: 'WETH',
 *   },
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "watchAsset", ()=>watchAsset);
async function watchAsset(client, params) {
    const added = await client.request({
        method: "wallet_watchAsset",
        params
    });
    return added;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fX3TA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Wallet Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).
 *
 * - Docs: https://viem.sh/docs/clients/wallet.html
 *
 * A Wallet Client is an interface to interact with [Ethereum Account(s)](https://ethereum.org/en/glossary/#account) and provides the ability to retrieve accounts, execute transactions, sign messages, etc. through [Wallet Actions](https://viem.sh/docs/actions/wallet/introduction.html).
 *
 * The Wallet Client supports signing over:
 * - [JSON-RPC Accounts](https://viem.sh/docs/clients/wallet.html#json-rpc-accounts) (e.g. Browser Extension Wallets, WalletConnect, etc).
 * - [Local Accounts](https://viem.sh/docs/clients/wallet.html#local-accounts-private-key-mnemonic-etc) (e.g. private key/mnemonic wallets).
 *
 * @param config - {@link WalletClientConfig}
 * @returns A Wallet Client. {@link WalletClient}
 *
 * @example
 * // JSON-RPC Account
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * @example
 * // Local Account
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x…')
 *   chain: mainnet,
 *   transport: http(),
 * })
 */ parcelHelpers.export(exports, "createWalletClient", ()=>createWalletClient);
var _createClientJs = require("./createClient.js");
var _walletJs = require("./decorators/wallet.js");
function createWalletClient({ account, chain, transport, key = "wallet", name = "Wallet Client", pollingInterval }) {
    return (0, _createClientJs.createClient)({
        account,
        chain,
        key,
        name,
        pollingInterval,
        transport: (opts)=>transport({
                ...opts,
                retryCount: 0
            }),
        type: "walletClient"
    }).extend((0, _walletJs.walletActions));
}

},{"./createClient.js":"2JKGW","./decorators/wallet.js":"fHnsm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ZZ0i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a WebSocket transport that connects to a JSON-RPC API.
 */ parcelHelpers.export(exports, "webSocket", ()=>webSocket);
var _requestJs = require("../../errors/request.js");
var _transportJs = require("../../errors/transport.js");
var _rpcJs = require("../../utils/rpc.js");
var _createTransportJs = require("./createTransport.js");
function webSocket(/** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */ url, config = {}) {
    const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ })=>{
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_) throw new (0, _transportJs.UrlRequiredError)();
        return (0, _createTransportJs.createTransport)({
            key,
            name,
            async request ({ method, params }) {
                const body = {
                    method,
                    params
                };
                const socket = await (0, _rpcJs.getSocket)(url_);
                const { error, result } = await (0, _rpcJs.rpc).webSocketAsync(socket, {
                    body,
                    timeout
                });
                if (error) throw new (0, _requestJs.RpcRequestError)({
                    body,
                    error,
                    url: url_
                });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: "webSocket"
        }, {
            getSocket () {
                return (0, _rpcJs.getSocket)(url_);
            },
            async subscribe ({ params, onData, onError }) {
                const socket = await (0, _rpcJs.getSocket)(url_);
                const { result: subscriptionId } = await new Promise((resolve, reject)=>(0, _rpcJs.rpc).webSocket(socket, {
                        body: {
                            method: "eth_subscribe",
                            params
                        },
                        onResponse (response) {
                            if (response.error) {
                                reject(response.error);
                                onError?.(response.error);
                                return;
                            }
                            if (typeof response.id === "number") {
                                resolve(response);
                                return;
                            }
                            if (response.method !== "eth_subscription") return;
                            onData(response.params);
                        }
                    }));
                return {
                    subscriptionId,
                    async unsubscribe () {
                        return new Promise((resolve)=>(0, _rpcJs.rpc).webSocket(socket, {
                                body: {
                                    method: "eth_unsubscribe",
                                    params: [
                                        subscriptionId
                                    ]
                                },
                                onResponse: resolve
                            }));
                    }
                };
            }
        });
    };
}

},{"../../errors/request.js":"vUxFy","../../errors/transport.js":"gCkTf","../../utils/rpc.js":"72uRz","./createTransport.js":"cUQ8K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"D4WL4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__privateGet", ()=>__privateGet);
parcelHelpers.export(exports, "__privateAdd", ()=>__privateAdd);
parcelHelpers.export(exports, "__privateSet", ()=>__privateSet);
parcelHelpers.export(exports, "__privateMethod", ()=>__privateMethod);
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
};
var __privateMethod = (obj, member, method)=>{
    __accessCheck(obj, member, "access private method");
    return method;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFkBW":[function(require,module,exports) {
"use strict";
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
var reduxImpl = function reduxImpl(reducer, initial) {
    return function(set, _get, api) {
        api.dispatch = function(action) {
            set(function(state) {
                return reducer(state, action);
            }, false, action);
            return action;
        };
        api.dispatchFromDevtools = true;
        return _extends({
            dispatch: function dispatch() {
                var _ref;
                return (_ref = api).dispatch.apply(_ref, arguments);
            }
        }, initial);
    };
};
var redux = reduxImpl;
var _excluded = [
    "enabled",
    "anonymousActionType",
    "store"
], _excluded2 = [
    "connection"
];
var trackedConnections = new Map();
var getTrackedConnectionState = function getTrackedConnectionState(name) {
    var api = trackedConnections.get(name);
    if (!api) return {};
    return Object.fromEntries(Object.entries(api.stores).map(function(_ref) {
        var key = _ref[0], api = _ref[1];
        return [
            key,
            api.getState()
        ];
    }));
};
var extractConnectionInformation = function extractConnectionInformation(store, extensionConnector, options) {
    if (store === undefined) return {
        type: "untracked",
        connection: extensionConnector.connect(options)
    };
    var existingConnection = trackedConnections.get(options.name);
    if (existingConnection) return _extends({
        type: "tracked",
        store: store
    }, existingConnection);
    var newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
    };
    trackedConnections.set(options.name, newConnection);
    return _extends({
        type: "tracked",
        store: store
    }, newConnection);
};
var devtoolsImpl = function devtoolsImpl(fn, devtoolsOptions) {
    if (devtoolsOptions === void 0) devtoolsOptions = {};
    return function(set, get, api) {
        var _devtoolsOptions = devtoolsOptions, enabled = _devtoolsOptions.enabled, anonymousActionType = _devtoolsOptions.anonymousActionType, store = _devtoolsOptions.store, options = _objectWithoutPropertiesLoose(_devtoolsOptions, _excluded);
        var extensionConnector;
        try {
            extensionConnector = (enabled != null ? enabled : true) && window.__REDUX_DEVTOOLS_EXTENSION__;
        } catch (e) {}
        if (!extensionConnector) {
            if (enabled) console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
            return fn(set, get, api);
        }
        var _extractConnectionInf = extractConnectionInformation(store, extensionConnector, options), connection = _extractConnectionInf.connection, connectionInformation = _objectWithoutPropertiesLoose(_extractConnectionInf, _excluded2);
        var isRecording = true;
        api.setState = function(state, replace, nameOrAction) {
            var _extends2;
            var r = set(state, replace);
            if (!isRecording) return r;
            var action = nameOrAction === undefined ? {
                type: anonymousActionType || "anonymous"
            } : typeof nameOrAction === "string" ? {
                type: nameOrAction
            } : nameOrAction;
            if (store === undefined) {
                connection == null || connection.send(action, get());
                return r;
            }
            connection == null || connection.send(_extends({}, action, {
                type: store + "/" + action.type
            }), _extends({}, getTrackedConnectionState(options.name), (_extends2 = {}, _extends2[store] = api.getState(), _extends2)));
            return r;
        };
        var setStateFromDevtools = function setStateFromDevtools() {
            var originalIsRecording = isRecording;
            isRecording = false;
            set.apply(void 0, arguments);
            isRecording = originalIsRecording;
        };
        var initialState = fn(api.setState, get, api);
        if (connectionInformation.type === "untracked") connection == null || connection.init(initialState);
        else {
            connectionInformation.stores[connectionInformation.store] = api;
            connection == null || connection.init(Object.fromEntries(Object.entries(connectionInformation.stores).map(function(_ref2) {
                var key = _ref2[0], store = _ref2[1];
                return [
                    key,
                    key === connectionInformation.store ? initialState : store.getState()
                ];
            })));
        }
        if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
            var didWarnAboutReservedActionType = false;
            var originalDispatch = api.dispatch;
            api.dispatch = function() {
                for(var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++)a[_key] = arguments[_key];
                if (a[0].type === "__setState" && !didWarnAboutReservedActionType) {
                    console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
                    didWarnAboutReservedActionType = true;
                }
                originalDispatch.apply(void 0, a);
            };
        }
        connection.subscribe(function(message) {
            switch(message.type){
                case "ACTION":
                    if (typeof message.payload !== "string") {
                        console.error("[zustand devtools middleware] Unsupported action format");
                        return;
                    }
                    return parseJsonThen(message.payload, function(action) {
                        if (action.type === "__setState") {
                            if (store === undefined) {
                                setStateFromDevtools(action.state);
                                return;
                            }
                            if (Object.keys(action.state).length !== 1) console.error('\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using \'store\' option in devtools(), the \'state\' should have only one key, which is a value of \'store\' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }\n                    ');
                            var stateFromDevtools = action.state[store];
                            if (stateFromDevtools === undefined || stateFromDevtools === null) return;
                            if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) setStateFromDevtools(stateFromDevtools);
                            return;
                        }
                        if (!api.dispatchFromDevtools) return;
                        if (typeof api.dispatch !== "function") return;
                        api.dispatch(action);
                    });
                case "DISPATCH":
                    switch(message.payload.type){
                        case "RESET":
                            setStateFromDevtools(initialState);
                            if (store === undefined) return connection == null ? void 0 : connection.init(api.getState());
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "COMMIT":
                            if (store === undefined) {
                                connection == null || connection.init(api.getState());
                                return;
                            }
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "ROLLBACK":
                            return parseJsonThen(message.state, function(state) {
                                if (store === undefined) {
                                    setStateFromDevtools(state);
                                    connection == null || connection.init(api.getState());
                                    return;
                                }
                                setStateFromDevtools(state[store]);
                                connection == null || connection.init(getTrackedConnectionState(options.name));
                            });
                        case "JUMP_TO_STATE":
                        case "JUMP_TO_ACTION":
                            return parseJsonThen(message.state, function(state) {
                                if (store === undefined) {
                                    setStateFromDevtools(state);
                                    return;
                                }
                                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) setStateFromDevtools(state[store]);
                            });
                        case "IMPORT_STATE":
                            var _nextLiftedState$comp;
                            var nextLiftedState = message.payload.nextLiftedState;
                            var lastComputedState = (_nextLiftedState$comp = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _nextLiftedState$comp.state;
                            if (!lastComputedState) return;
                            if (store === undefined) setStateFromDevtools(lastComputedState);
                            else setStateFromDevtools(lastComputedState[store]);
                            connection == null || connection.send(null, nextLiftedState);
                            return;
                        case "PAUSE_RECORDING":
                            return isRecording = !isRecording;
                    }
                    return;
            }
        });
        return initialState;
    };
};
var devtools = devtoolsImpl;
var parseJsonThen = function parseJsonThen(stringified, f) {
    var parsed;
    try {
        parsed = JSON.parse(stringified);
    } catch (e) {
        console.error("[zustand devtools middleware] Could not parse the received json", e);
    }
    if (parsed !== undefined) f(parsed);
};
var subscribeWithSelectorImpl = function subscribeWithSelectorImpl(fn) {
    return function(set, get, api) {
        var origSubscribe = api.subscribe;
        api.subscribe = function(selector, optListener, options) {
            var listener = selector;
            if (optListener) {
                var equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
                var currentSlice = selector(api.getState());
                listener = function listener(state) {
                    var nextSlice = selector(state);
                    if (!equalityFn(currentSlice, nextSlice)) {
                        var previousSlice = currentSlice;
                        optListener(currentSlice = nextSlice, previousSlice);
                    }
                };
                if (options != null && options.fireImmediately) optListener(currentSlice, currentSlice);
            }
            return origSubscribe(listener);
        };
        var initialState = fn(set, get, api);
        return initialState;
    };
};
var subscribeWithSelector = subscribeWithSelectorImpl;
var combine = function combine(initialState, create) {
    return function() {
        return Object.assign({}, initialState, create.apply(void 0, arguments));
    };
};
function createJSONStorage(getStorage, options) {
    var storage;
    try {
        storage = getStorage();
    } catch (e) {
        return;
    }
    var persistStorage = {
        getItem: function getItem(name) {
            var _getItem;
            var parse = function parse(str) {
                if (str === null) return null;
                return JSON.parse(str, options == null ? void 0 : options.reviver);
            };
            var str = (_getItem = storage.getItem(name)) != null ? _getItem : null;
            if (str instanceof Promise) return str.then(parse);
            return parse(str);
        },
        setItem: function setItem(name, newValue) {
            return storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer));
        },
        removeItem: function removeItem(name) {
            return storage.removeItem(name);
        }
    };
    return persistStorage;
}
var toThenable = function toThenable(fn) {
    return function(input) {
        try {
            var result = fn(input);
            if (result instanceof Promise) return result;
            return {
                then: function then(onFulfilled) {
                    return toThenable(onFulfilled)(result);
                },
                catch: function _catch(_onRejected) {
                    return this;
                }
            };
        } catch (e) {
            return {
                then: function then(_onFulfilled) {
                    return this;
                },
                catch: function _catch(onRejected) {
                    return toThenable(onRejected)(e);
                }
            };
        }
    };
};
var oldImpl = function oldImpl(config, baseOptions) {
    return function(set, get, api) {
        var options = _extends({
            getStorage: function getStorage() {
                return localStorage;
            },
            serialize: JSON.stringify,
            deserialize: JSON.parse,
            partialize: function partialize(state) {
                return state;
            },
            version: 0,
            merge: function merge(persistedState, currentState) {
                return _extends({}, currentState, persistedState);
            }
        }, baseOptions);
        var _hasHydrated = false;
        var hydrationListeners = new Set();
        var finishHydrationListeners = new Set();
        var storage;
        try {
            storage = options.getStorage();
        } catch (e) {}
        if (!storage) return config(function() {
            console.warn("[zustand persist middleware] Unable to update item '" + options.name + "', the given storage is currently unavailable.");
            set.apply(void 0, arguments);
        }, get, api);
        var thenableSerialize = toThenable(options.serialize);
        var setItem = function setItem() {
            var state = options.partialize(_extends({}, get()));
            var errorInSync;
            var thenable = thenableSerialize({
                state: state,
                version: options.version
            }).then(function(serializedValue) {
                return storage.setItem(options.name, serializedValue);
            }).catch(function(e) {
                errorInSync = e;
            });
            if (errorInSync) throw errorInSync;
            return thenable;
        };
        var savedSetState = api.setState;
        api.setState = function(state, replace) {
            savedSetState(state, replace);
            setItem();
        };
        var configResult = config(function() {
            set.apply(void 0, arguments);
            setItem();
        }, get, api);
        var stateFromStorage;
        var hydrate = function hydrate() {
            if (!storage) return;
            _hasHydrated = false;
            hydrationListeners.forEach(function(cb) {
                return cb(get());
            });
            var postRehydrationCallback = (options.onRehydrateStorage == null ? void 0 : options.onRehydrateStorage(get())) || undefined;
            return toThenable(storage.getItem.bind(storage))(options.name).then(function(storageValue) {
                if (storageValue) return options.deserialize(storageValue);
            }).then(function(deserializedStorageValue) {
                if (deserializedStorageValue) {
                    if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
                        if (options.migrate) return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
                        console.error("State loaded from storage couldn't be migrated since no migrate function was provided");
                    } else return deserializedStorageValue.state;
                }
            }).then(function(migratedState) {
                var _get;
                stateFromStorage = options.merge(migratedState, (_get = get()) != null ? _get : configResult);
                set(stateFromStorage, true);
                return setItem();
            }).then(function() {
                postRehydrationCallback == null || postRehydrationCallback(stateFromStorage, undefined);
                _hasHydrated = true;
                finishHydrationListeners.forEach(function(cb) {
                    return cb(stateFromStorage);
                });
            }).catch(function(e) {
                postRehydrationCallback == null || postRehydrationCallback(undefined, e);
            });
        };
        api.persist = {
            setOptions: function setOptions(newOptions) {
                options = _extends({}, options, newOptions);
                if (newOptions.getStorage) storage = newOptions.getStorage();
            },
            clearStorage: function clearStorage() {
                var _storage;
                (_storage = storage) == null || _storage.removeItem(options.name);
            },
            getOptions: function getOptions() {
                return options;
            },
            rehydrate: function rehydrate() {
                return hydrate();
            },
            hasHydrated: function hasHydrated() {
                return _hasHydrated;
            },
            onHydrate: function onHydrate(cb) {
                hydrationListeners.add(cb);
                return function() {
                    hydrationListeners.delete(cb);
                };
            },
            onFinishHydration: function onFinishHydration(cb) {
                finishHydrationListeners.add(cb);
                return function() {
                    finishHydrationListeners.delete(cb);
                };
            }
        };
        hydrate();
        return stateFromStorage || configResult;
    };
};
var newImpl = function newImpl(config, baseOptions) {
    return function(set, get, api) {
        var options = _extends({
            storage: createJSONStorage(function() {
                return localStorage;
            }),
            partialize: function partialize(state) {
                return state;
            },
            version: 0,
            merge: function merge(persistedState, currentState) {
                return _extends({}, currentState, persistedState);
            }
        }, baseOptions);
        var _hasHydrated2 = false;
        var hydrationListeners = new Set();
        var finishHydrationListeners = new Set();
        var storage = options.storage;
        if (!storage) return config(function() {
            console.warn("[zustand persist middleware] Unable to update item '" + options.name + "', the given storage is currently unavailable.");
            set.apply(void 0, arguments);
        }, get, api);
        var setItem = function setItem() {
            var state = options.partialize(_extends({}, get()));
            return storage.setItem(options.name, {
                state: state,
                version: options.version
            });
        };
        var savedSetState = api.setState;
        api.setState = function(state, replace) {
            savedSetState(state, replace);
            setItem();
        };
        var configResult = config(function() {
            set.apply(void 0, arguments);
            setItem();
        }, get, api);
        var stateFromStorage;
        var hydrate = function hydrate() {
            var _get3;
            if (!storage) return;
            _hasHydrated2 = false;
            hydrationListeners.forEach(function(cb) {
                var _get2;
                return cb((_get2 = get()) != null ? _get2 : configResult);
            });
            var postRehydrationCallback = (options.onRehydrateStorage == null ? void 0 : options.onRehydrateStorage((_get3 = get()) != null ? _get3 : configResult)) || undefined;
            return toThenable(storage.getItem.bind(storage))(options.name).then(function(deserializedStorageValue) {
                if (deserializedStorageValue) {
                    if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
                        if (options.migrate) return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
                        console.error("State loaded from storage couldn't be migrated since no migrate function was provided");
                    } else return deserializedStorageValue.state;
                }
            }).then(function(migratedState) {
                var _get4;
                stateFromStorage = options.merge(migratedState, (_get4 = get()) != null ? _get4 : configResult);
                set(stateFromStorage, true);
                return setItem();
            }).then(function() {
                postRehydrationCallback == null || postRehydrationCallback(stateFromStorage, undefined);
                stateFromStorage = get();
                _hasHydrated2 = true;
                finishHydrationListeners.forEach(function(cb) {
                    return cb(stateFromStorage);
                });
            }).catch(function(e) {
                postRehydrationCallback == null || postRehydrationCallback(undefined, e);
            });
        };
        api.persist = {
            setOptions: function setOptions(newOptions) {
                options = _extends({}, options, newOptions);
                if (newOptions.storage) storage = newOptions.storage;
            },
            clearStorage: function clearStorage() {
                var _storage2;
                (_storage2 = storage) == null || _storage2.removeItem(options.name);
            },
            getOptions: function getOptions() {
                return options;
            },
            rehydrate: function rehydrate() {
                return hydrate();
            },
            hasHydrated: function hasHydrated() {
                return _hasHydrated2;
            },
            onHydrate: function onHydrate(cb) {
                hydrationListeners.add(cb);
                return function() {
                    hydrationListeners.delete(cb);
                };
            },
            onFinishHydration: function onFinishHydration(cb) {
                finishHydrationListeners.add(cb);
                return function() {
                    finishHydrationListeners.delete(cb);
                };
            }
        };
        if (!options.skipHydration) hydrate();
        return stateFromStorage || configResult;
    };
};
var persistImpl = function persistImpl(config, baseOptions) {
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.");
        return oldImpl(config, baseOptions);
    }
    return newImpl(config, baseOptions);
};
var persist = persistImpl;
exports.combine = combine;
exports.createJSONStorage = createJSONStorage;
exports.devtools = devtools;
exports.persist = persist;
exports.redux = redux;
exports.subscribeWithSelector = subscribeWithSelector;

},{}],"2SLIN":[function(require,module,exports) {
"use strict";
var createStoreImpl = function createStoreImpl(createState) {
    var state;
    var listeners = new Set();
    var setState = function setState(partial, replace) {
        var nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
            var _previousState = state;
            state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
            listeners.forEach(function(listener) {
                return listener(state, _previousState);
            });
        }
    };
    var getState = function getState() {
        return state;
    };
    var subscribe = function subscribe(listener) {
        listeners.add(listener);
        return function() {
            return listeners.delete(listener);
        };
    };
    var destroy = function destroy() {
        console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.");
        listeners.clear();
    };
    var api = {
        setState: setState,
        getState: getState,
        subscribe: subscribe,
        destroy: destroy
    };
    state = createState(setState, getState, api);
    return api;
};
var createStore = function createStore(createState) {
    return createState ? createStoreImpl(createState) : createStoreImpl;
};
var vanilla = function(createState) {
    console.warn("[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.");
    return createStore(createState);
};
exports.createStore = createStore;
exports.default = vanilla;
module.exports = vanilla;
module.exports.createStore = createStore;
exports.default = module.exports;

},{}],"4DTir":[function(require,module,exports) {
"use strict";
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function shallow(objA, objB) {
    if (Object.is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return false;
    if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for(var _iterator = _createForOfIteratorHelperLoose(objA), _step; !(_step = _iterator()).done;){
            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
            if (!Object.is(value, objB.get(key))) return false;
        }
        return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for(var _iterator2 = _createForOfIteratorHelperLoose(objA), _step2; !(_step2 = _iterator2()).done;){
            var _value = _step2.value;
            if (!objB.has(_value)) return false;
        }
        return true;
    }
    var keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) return false;
    for(var i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) return false;
    }
    return true;
}
var shallow$1 = function(objA, objB) {
    console.warn("[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.");
    return shallow(objA, objB);
};
exports.default = shallow$1;
exports.shallow = shallow;
module.exports = shallow$1;
module.exports.shallow = shallow;
exports.default = module.exports;

},{}],"fsqhn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalize", ()=>(0, _normalizeJs.normalize));
parcelHelpers.export(exports, "getEnsAddress", ()=>(0, _getEnsAddressJs.getEnsAddress));
parcelHelpers.export(exports, "getEnsAvatar", ()=>(0, _getEnsAvatarJs.getEnsAvatar));
parcelHelpers.export(exports, "getEnsName", ()=>(0, _getEnsNameJs.getEnsName));
parcelHelpers.export(exports, "getEnsResolver", ()=>(0, _getEnsResolverJs.getEnsResolver));
parcelHelpers.export(exports, "getEnsText", ()=>(0, _getEnsTextJs.getEnsText));
parcelHelpers.export(exports, "labelhash", ()=>(0, _labelhashJs.labelhash));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehashJs.namehash));
var _normalizeJs = require("./utils/ens/normalize.js");
var _getEnsAddressJs = require("./actions/ens/getEnsAddress.js");
var _getEnsAvatarJs = require("./actions/ens/getEnsAvatar.js");
var _getEnsNameJs = require("./actions/ens/getEnsName.js");
var _getEnsResolverJs = require("./actions/ens/getEnsResolver.js");
var _getEnsTextJs = require("./actions/ens/getEnsText.js");
var _labelhashJs = require("./utils/ens/labelhash.js");
var _namehashJs = require("./utils/ens/namehash.js");

},{"./utils/ens/normalize.js":"k1p65","./actions/ens/getEnsAddress.js":false,"./actions/ens/getEnsAvatar.js":false,"./actions/ens/getEnsName.js":false,"./actions/ens/getEnsResolver.js":false,"./actions/ens/getEnsText.js":false,"./utils/ens/labelhash.js":false,"./utils/ens/namehash.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1p65":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Normalizes ENS name according to ENSIP-15.
 *
 * @example
 * normalize('wagmi-dev.eth')
 * 'wagmi-dev.eth'
 *
 * @see https://docs.ens.domains/contract-api-reference/name-processing#normalising-names
 * @see https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md
 */ parcelHelpers.export(exports, "normalize", ()=>normalize);
var _ensNormalize = require("@adraffy/ens-normalize");
function normalize(name) {
    return (0, _ensNormalize.ens_normalize)(name);
}

},{"@adraffy/ens-normalize":"6qMVC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qMVC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ens_beautify", ()=>ens_beautify);
parcelHelpers.export(exports, "ens_emoji", ()=>ens_emoji);
parcelHelpers.export(exports, "ens_normalize", ()=>ens_normalize);
parcelHelpers.export(exports, "ens_normalize_fragment", ()=>ens_normalize_fragment);
parcelHelpers.export(exports, "ens_split", ()=>ens_split);
parcelHelpers.export(exports, "ens_tokenize", ()=>ens_tokenize);
parcelHelpers.export(exports, "is_combining_mark", ()=>is_combining_mark);
parcelHelpers.export(exports, "nfc", ()=>nfc);
parcelHelpers.export(exports, "nfd", ()=>nfd);
parcelHelpers.export(exports, "safe_str_from_cps", ()=>safe_str_from_cps);
parcelHelpers.export(exports, "should_escape", ()=>should_escape);
function decode_arithmetic(bytes) {
    let pos = 0;
    function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
    }
    // decode the frequency table
    let symbol_count = u16();
    let total = 1;
    let acc = [
        0,
        1
    ]; // first symbol has frequency 1
    for(let i = 1; i < symbol_count; i++)acc.push(total += u16());
    // skip the sized-payload that the last 3 symbols index into
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = read_buffer << 8 | bytes[pos++];
            read_width = 8;
        }
        return read_buffer >> --read_width & 1;
    }
    const N = 31;
    const FULL = 2 ** N;
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    // fill register
    let register = 0;
    for(let i = 0; i < N; i++)register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL; // treat like a float
    while(true){
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while(end - start > 1){
            let mid = start + end >>> 1;
            if (value < acc[mid]) end = mid;
            else start = mid;
        }
        if (start == 0) break; // first symbol is end mark
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while(((a ^ b) & HALF) == 0){
            register = register << 1 & MASK | read_bit();
            a = a << 1 & MASK;
            b = b << 1 & MASK | 1;
        }
        while(a & ~b & QRTR){
            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
            a = a << 1 ^ HALF;
            b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    let offset = symbol_count - 4;
    return symbols.map((x)=>{
        switch(x - offset){
            case 3:
                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 2:
                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 1:
                return offset + bytes[pos_payload++];
            default:
                return x - 1;
        }
    });
}
// returns an iterator which returns the next symbol
function read_payload(v) {
    let pos = 0;
    return ()=>v[pos++];
}
function read_compressed_payload(s) {
    return read_payload(decode_arithmetic(unsafe_atob(s)));
}
// unsafe in the sense:
// expected well-formed Base64 w/o padding 
function unsafe_atob(s) {
    let lookup = [];
    [
        ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);
    let n = s.length;
    let ret = new Uint8Array(6 * n >> 3);
    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){
        carry = carry << 6 | lookup[s.charCodeAt(i)];
        width += 6;
        if (width >= 8) ret[pos++] = carry >> (width -= 8);
    }
    return ret;
}
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next) {
    let v = Array(n);
    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());
    return v;
}
// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next, prev = 0) {
    let ret = [];
    while(true){
        let x = next();
        let n = next();
        if (!n) break;
        prev += x;
        for(let i = 0; i < n; i++)ret.push(prev + i);
        prev += n + 1;
    }
    return ret;
}
function read_sorted_arrays(next) {
    return read_array_while(()=>{
        let v = read_sorted(next);
        if (v.length) return v;
    });
}
// returns map of x => ys
function read_mapped(next) {
    let ret = [];
    while(true){
        let w = next();
        if (w == 0) break;
        ret.push(read_linear_table(w, next));
    }
    while(true){
        let w = next() - 1;
        if (w < 0) break;
        ret.push(read_replacement_table(w, next));
    }
    return ret.flat();
}
// read until next is falsy
// return array of read values
function read_array_while(next) {
    let v = [];
    while(true){
        let x = next(v.length);
        if (!x) break;
        v.push(x);
    }
    return v;
}
// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
    let m = Array(n).fill().map(()=>[]);
    for(let i = 0; i < w; i++)read_deltas(n, next).forEach((x, j)=>m[j].push(x));
    return m;
}
// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_array_while(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return m.flatMap((v, i)=>{
        let [x, ...ys] = v;
        return Array(vN[i]).fill().map((_, j)=>{
            let j_dy = j * dy;
            return [
                x + j * dx,
                ys.map((y)=>y + j_dy)
            ];
        });
    });
}
// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) {
    let n = 1 + next();
    let m = read_transposed(n, 1 + w, next);
    return m.map((v)=>[
            v[0],
            v.slice(1)
        ]);
}
// created 2023-02-21T09:18:13.549Z
var r$1 = read_compressed_payload("AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE");
const FENCED = new Map([
    [
        8217,
        "apostrophe"
    ],
    [
        8260,
        "fraction slash"
    ],
    [
        12539,
        "middle dot"
    ]
]);
const NSM_MAX = 4;
function hex_cp(cp) {
    return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
    return `{${hex_cp(cp)}}`; // raffy convention: like "\u{X}" w/o the "\u"
}
/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/ function explode_cp(s) {
    let cps = [];
    for(let pos = 0, len = s.length; pos < len;){
        let cp = s.codePointAt(pos);
        pos += cp < 0x10000 ? 1 : 2;
        cps.push(cp);
    }
    return cps;
}
function str_from_cps(cps) {
    const chunk = 4096;
    let len = cps.length;
    if (len < chunk) return String.fromCodePoint(...cps);
    let buf = [];
    for(let i = 0; i < len;)buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
    return buf.join("");
}
function compare_arrays(a, b) {
    let n = a.length;
    let c = n - b.length;
    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];
    return c;
}
// created 2023-02-21T09:18:13.549Z
var r = read_compressed_payload("AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g");
// https://unicode.org/reports/tr15/
function unpack_cc(packed) {
    return packed >> 24 & 0xFF;
}
function unpack_cp(packed) {
    return packed & 0xFFFFFF;
}
const SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[
            x,
            i + 1 << 24
        ]))); // pre-shifted
const EXCLUSIONS = new Set(read_sorted(r));
const DECOMP = new Map();
const RECOMP = new Map();
for (let [cp, cps] of read_mapped(r)){
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        let [a, b] = cps;
        let bucket = RECOMP.get(a);
        if (!bucket) {
            bucket = new Map();
            RECOMP.set(a, bucket);
        }
        bucket.set(b, cp);
    }
    DECOMP.set(cp, cps.reverse()); // stored reversed
}
// algorithmic hangul
// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
const S0 = 0xAC00;
const L0 = 0x1100;
const V0 = 0x1161;
const T0 = 0x11A7;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;
function is_hangul(cp) {
    return cp >= S0 && cp < S1;
}
function compose_pair(a, b) {
    if (a >= L0 && a < L1 && b >= V0 && b < V1) return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
    else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) return a + (b - T0);
    else {
        let recomp = RECOMP.get(a);
        if (recomp) {
            recomp = recomp.get(b);
            if (recomp) return recomp;
        }
        return -1;
    }
}
function decomposed(cps) {
    let ret = [];
    let buf = [];
    let check_order = false;
    function add(cp) {
        let cc = SHIFTED_RANK.get(cp);
        if (cc) {
            check_order = true;
            cp |= cc;
        }
        ret.push(cp);
    }
    for (let cp of cps)while(true){
        if (cp < 0x80) ret.push(cp);
        else if (is_hangul(cp)) {
            let s_index = cp - S0;
            let l_index = s_index / N_COUNT | 0;
            let v_index = s_index % N_COUNT / T_COUNT | 0;
            let t_index = s_index % T_COUNT;
            add(L0 + l_index);
            add(V0 + v_index);
            if (t_index > 0) add(T0 + t_index);
        } else {
            let mapped = DECOMP.get(cp);
            if (mapped) buf.push(...mapped);
            else add(cp);
        }
        if (!buf.length) break;
        cp = buf.pop();
    }
    if (check_order && ret.length > 1) {
        let prev_cc = unpack_cc(ret[0]);
        for(let i = 1; i < ret.length; i++){
            let cc = unpack_cc(ret[i]);
            if (cc == 0 || prev_cc <= cc) {
                prev_cc = cc;
                continue;
            }
            let j = i - 1;
            while(true){
                let tmp = ret[j + 1];
                ret[j + 1] = ret[j];
                ret[j] = tmp;
                if (!j) break;
                prev_cc = unpack_cc(ret[--j]);
                if (prev_cc <= cc) break;
            }
            prev_cc = unpack_cc(ret[i]);
        }
    }
    return ret;
}
function composed_from_decomposed(v) {
    let ret = [];
    let stack = [];
    let prev_cp = -1;
    let prev_cc = 0;
    for (let packed of v){
        let cc = unpack_cc(packed);
        let cp = unpack_cp(packed);
        if (prev_cp == -1) {
            if (cc == 0) prev_cp = cp;
            else ret.push(cp);
        } else if (prev_cc > 0 && prev_cc >= cc) {
            if (cc == 0) {
                ret.push(prev_cp, ...stack);
                stack.length = 0;
                prev_cp = cp;
            } else stack.push(cp);
            prev_cc = cc;
        } else {
            let composed = compose_pair(prev_cp, cp);
            if (composed >= 0) prev_cp = composed;
            else if (prev_cc == 0 && cc == 0) {
                ret.push(prev_cp);
                prev_cp = cp;
            } else {
                stack.push(cp);
                prev_cc = cc;
            }
        }
    }
    if (prev_cp >= 0) ret.push(prev_cp, ...stack);
    return ret;
}
// note: cps can be iterable
function nfd(cps) {
    return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
    return composed_from_decomposed(decomposed(cps));
}
//const t0 = performance.now();
const STOP = 0x2E;
const FE0F = 0xFE0F;
const STOP_CH = ".";
const UNIQUE_PH = 1;
const HYPHEN = 0x2D;
function read_set() {
    return new Set(read_sorted(r$1));
}
const MAPPED = new Map(read_mapped(r$1));
const IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints
/*
// direct include from payload is smaller that the decompression code
const FENCED = new Map(read_array_while(() => {
	let cp = r();
	if (cp) return [cp, read_str(r())];
}));
*/ // 20230217: we still need all CM for proper error formatting
// but norm only needs NSM subset that are potentially-valid
const CM = read_set();
const NSM = new Set(read_sorted(r$1).map(function(i) {
    return this[i];
}, [
    ...CM
]));
/*
const CM_SORTED = read_sorted(r);
const NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));
const CM = new Set(CM_SORTED);
*/ const ESCAPE = read_set(); // characters that should not be printed
const NFC_CHECK = read_set();
const CHUNKS = read_sorted_arrays(r$1);
function read_chunked() {
    // deduplicated sets + uniques
    return new Set([
        read_sorted(r$1).map((i)=>CHUNKS[i]),
        read_sorted(r$1)
    ].flat(2));
}
const UNRESTRICTED = r$1();
const GROUPS = read_array_while((i)=>{
    // minifier property mangling seems unsafe
    // so these are manually renamed to single chars
    let N = read_array_while(r$1).map((x)=>x + 0x60);
    if (N.length) {
        let R = i >= UNRESTRICTED; // first arent restricted
        N[0] -= 32; // capitalize
        N = str_from_cps(N);
        if (R) N = `Restricted[${N}]`;
        let P = read_chunked(); // primary
        let Q = read_chunked(); // secondary
        let V = [
            ...P,
            ...Q
        ].sort((a, b)=>a - b); // derive: sorted valid
        //let M = r()-1; // combining mark
        let M = !r$1(); // not-whitelisted, check for NSM
        // code currently isn't needed
        /*if (M < 0) { // whitelisted
			M = new Map(read_array_while(() => {
				let i = r();
				if (i) return [V[i-1], read_array_while(() => {
					let v = read_array_while(r);
					if (v.length) return v.map(x => x-1);
				})];
			}));
		}*/ return {
            N,
            P,
            M,
            R,
            V: new Set(V)
        };
    }
});
const WHOLE_VALID = read_set();
const WHOLE_MAP = new Map();
// decode compressed wholes
[
    ...WHOLE_VALID,
    ...read_set()
].sort((a, b)=>a - b).map((cp, i, v)=>{
    let d = r$1();
    let w = v[i] = d ? v[i - d] : {
        V: [],
        M: new Map()
    };
    w.V.push(cp); // add to member set
    if (!WHOLE_VALID.has(cp)) WHOLE_MAP.set(cp, w); // register with whole map
});
// compute confusable-extent complements
for (let { V, M } of new Set(WHOLE_MAP.values())){
    // connect all groups that have each whole character
    let recs = [];
    for (let cp of V){
        let gs = GROUPS.filter((g)=>g.V.has(cp));
        let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));
        if (!rec) {
            rec = {
                G: new Set(),
                V: []
            };
            recs.push(rec);
        }
        rec.V.push(cp);
        gs.forEach((g)=>rec.G.add(g));
    }
    // per character cache groups which are not a member of the extent
    let union = recs.flatMap(({ G })=>[
            ...G
        ]);
    for (let { G, V } of recs){
        let complement = new Set(union.filter((g)=>!G.has(g)));
        for (let cp of V)M.set(cp, complement);
    }
}
let union = new Set(); // exists in 1+ groups
let multi = new Set(); // exists in 2+ groups
for (let g of GROUPS)for (let cp of g.V)(union.has(cp) ? multi : union).add(cp);
// dual purpose WHOLE_MAP: return placeholder if unique non-confusable
for (let cp of union)if (!WHOLE_MAP.has(cp) && !multi.has(cp)) WHOLE_MAP.set(cp, UNIQUE_PH);
const VALID = new Set([
    ...union,
    ...nfd(union)
]); // possibly valid
// decode emoji
const EMOJI_SORTED = read_sorted(r$1); // temporary
//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed
const EMOJI_ROOT = read_emoji_trie([]);
function read_emoji_trie(cps) {
    let B = read_array_while(()=>{
        let keys = read_sorted(r$1).map((i)=>EMOJI_SORTED[i]);
        if (keys.length) return read_emoji_trie(keys);
    }).sort((a, b)=>b.Q.size - a.Q.size); // sort by likelihood
    let temp = r$1();
    let V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)
    temp = temp / 3 | 0;
    let F = temp & 1; // allow FE0F
    temp >>= 1;
    let S = temp & 1; // save
    let C = temp & 2; // check
    return {
        B,
        V,
        F,
        S,
        C,
        Q: new Set(cps)
    };
}
//console.log(performance.now() - t0);
// free tagging system
class Emoji extends Array {
    get is_emoji() {
        return true;
    }
}
// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps, quoter = quote_cp) {
    //if (Number.isInteger(cps)) cps = [cps];
    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
    let buf = [];
    if (is_combining_mark(cps[0])) buf.push("◌");
    let prev = 0;
    let n = cps.length;
    for(let i = 0; i < n; i++){
        let cp = cps[i];
        if (should_escape(cp)) {
            buf.push(str_from_cps(cps.slice(prev, i)));
            buf.push(quoter(cp));
            prev = i + 1;
        }
    }
    buf.push(str_from_cps(cps.slice(prev, n)));
    return buf.join("");
}
// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
    return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([
        cp
    ]))} `) + quote_cp(cp);
}
// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
    return `"${s}"\u200E`; // strong LTR
}
function check_label_extension(cps) {
    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) throw new Error("invalid label extension");
}
function check_leading_underscore(cps) {
    const UNDERSCORE = 0x5F;
    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){
        if (cps[--i] !== UNDERSCORE) throw new Error("underscore allowed only at start");
    }
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
    let cp = cps[0];
    let prev = FENCED.get(cp);
    if (prev) throw error_placement(`leading ${prev}`);
    let n = cps.length;
    let last = -1; // prevents trailing from throwing
    for(let i = 1; i < n; i++){
        cp = cps[i];
        let match = FENCED.get(cp);
        if (match) {
            // since cps[0] isn't fenced, cps[1] cannot throw
            if (last == i) throw error_placement(`${prev} + ${match}`);
            last = i + 1;
            prev = match;
        }
    }
    if (last == n) throw error_placement(`trailing ${prev}`);
}
// note: set(s) cannot be exposed because they can be modified
function is_combining_mark(cp) {
    return CM.has(cp);
}
function should_escape(cp) {
    return ESCAPE.has(cp);
}
function ens_normalize_fragment(frag, decompose) {
    let nf = decompose ? nfd : nfc;
    return frag.split(STOP_CH).map((label)=>str_from_cps(process(explode_cp(label), nf).flatMap((x)=>x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);
}
function ens_normalize(name) {
    return flatten(ens_split(name));
}
function ens_beautify(name) {
    let split = ens_split(name, true);
    // this is experimental
    for (let { type, output, error } of split){
        if (error) continue;
        // replace leading/trailing hyphen
        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
        // not exactly the same in every font, but very similar: "-" vs "‐"
        /*
		const UNICODE_HYPHEN = 0x2010;
		// maybe this should replace all for visual consistancy?
		// `node tools/reg-count.js regex ^-\{2,\}` => 592
		//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
		if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
		let end = output.length-1;
		if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
		*/ // 20230123: WHATWG URL uses "CheckHyphens" false
        // https://url.spec.whatwg.org/#idna
        // update ethereum symbol
        // ξ => Ξ if not greek
        if (type !== "Greek") {
            let prev = 0;
            while(true){
                let next = output.indexOf(0x3BE, prev);
                if (next < 0) break;
                output[next] = 0x39E;
                prev = next + 1;
            }
        }
    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
    // could be fixed with special case for: 2D (.) + 200E (LTR)
    //output.splice(0, 0, 0x200E);
    }
    return flatten(split);
}
function ens_split(name, preserve_emoji) {
    let offset = 0;
    // https://unicode.org/reports/tr46/#Validity_Criteria
    // 4.) "The label must not contain a U+002E ( . ) FULL STOP."
    return name.split(STOP_CH).map((label)=>{
        let input = explode_cp(label);
        let info = {
            input,
            offset
        };
        offset += input.length + 1; // + stop
        let norm;
        try {
            // 1.) "The label must be in Unicode Normalization Form NFC"
            let tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]
            let token_count = tokens.length;
            let type;
            if (!token_count) // 20230120: change to strict
            // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
            //norm = [];
            //type = 'None'; // use this instead of next match, "ASCII"
            throw new Error(`empty label`);
            else {
                let chars = tokens[0];
                let emoji = token_count > 1 || chars.is_emoji;
                if (!emoji && chars.every((cp)=>cp < 0x80)) {
                    norm = chars;
                    check_leading_underscore(norm);
                    // only needed for ascii
                    // 20230123: matches matches WHATWG, see note 3.3
                    check_label_extension(norm);
                    // cant have fenced
                    // cant have cm
                    // cant have wholes
                    // see derive: "Fastpath ASCII"
                    type = "ASCII";
                } else {
                    if (emoji) {
                        info.emoji = true;
                        chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together
                    }
                    norm = tokens.flatMap((x)=>!preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);
                    check_leading_underscore(norm);
                    if (!chars.length) type = "Emoji";
                    else {
                        // 5. "The label must not begin with a combining mark, that is: General_Category=Mark."
                        if (CM.has(norm[0])) throw error_placement("leading combining mark");
                        for(let i = 1; i < token_count; i++){
                            let cps = tokens[i];
                            if (!cps.is_emoji && CM.has(cps[0])) // bidi_qq() not needed since emoji is LTR and cps is a CM
                            throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([
                                cps[0]
                            ])}"`);
                        }
                        check_fenced(norm);
                        let unique = [
                            ...new Set(chars)
                        ];
                        let [g] = determine_group(unique); // take the first match
                        // see derive: "Matching Groups have Same CM Style"
                        // alternative: could form a hybrid type: Latin/Japanese/...	
                        check_group(g, chars); // need text in order
                        check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
                        type = g.N;
                    // 20230121: consider exposing restricted flag
                    // it's simpler to just check for 'Restricted'
                    // or even better: type.endsWith(']')
                    //if (g.R) info.restricted = true;
                    }
                }
            }
            info.type = type;
        } catch (err) {
            info.error = err; // use full error object
        }
        info.output = norm;
        return info;
    });
}
function check_whole(group, unique) {
    let maker;
    let shared = []; // TODO: can this be avoided?
    for (let cp of unique){
        let whole = WHOLE_MAP.get(cp);
        if (whole === UNIQUE_PH) return; // unique, non-confusable
        if (whole) {
            let set = whole.M.get(cp); // groups which have a character that look-like this character
            maker = maker ? maker.filter((g)=>set.has(g)) : [
                ...set
            ];
            if (!maker.length) return; // confusable intersection is empty
        } else shared.push(cp);
    }
    if (maker) // we have 1+ confusable
    // check if any of the remaning groups
    // contain the shared characters too
    for (let g of maker){
        if (shared.every((cp)=>g.V.has(cp))) throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
    }
}
// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
    let groups = GROUPS;
    for (let cp of unique){
        // note: we need to dodge CM that are whitelisted
        // but that code isn't currently necessary
        let gs = groups.filter((g)=>g.V.has(cp));
        if (!gs.length) {
            if (groups === GROUPS) // the character was composed of valid parts
            // but it's NFC form is invalid
            throw error_disallowed(cp); // this should be rare
            else // there is no group that contains all these characters
            // throw using the highest priority group that matched
            // https://www.unicode.org/reports/tr39/#mixed_script_confusables
            throw error_group_member(groups[0], cp);
        }
        groups = gs;
        if (gs.length == 1) break; // there is only one group left
    }
    // there are at least 1 group(s) with all of these characters
    return groups;
}
// throw on first error
function flatten(split) {
    return split.map(({ input, error, output })=>{
        if (error) {
            // don't print label again if just a single label
            let msg = error.message;
            // bidi_qq() only necessary if msg is digits
            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
        }
        return str_from_cps(output);
    }).join(STOP_CH);
}
function error_disallowed(cp) {
    // TODO: add cp to error?
    return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
    let quoted = quoted_cp(cp);
    let gg = GROUPS.find((g)=>g.P.has(cp));
    if (gg) quoted = `${gg.N} ${quoted}`;
    return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
    return new Error(`illegal placement: ${where}`);
}
// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
    let { V, M } = g;
    for (let cp of cps){
        if (!V.has(cp)) // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
        // at the moment, it's unnecessary to introduce an extra error type
        // until there exists a whitelisted multi-character
        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }
        // there are 3 cases:
        //   1. illegal cm for wrong group => mixture error
        //   2. illegal cm for same group => cm error
        //       requires set of whitelist cm per group: 
        //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))
        //   3. wrong group => mixture error
        throw error_group_member(g, cp);
    }
    //if (M >= 0) { // we have a known fixed cm count
    if (M) {
        let decomposed = nfd(cps);
        for(let i = 1, e = decomposed.length; i < e; i++)// 20230210: bugfix: using cps instead of decomposed h/t Carbon225
        /*
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
				}
				i = j;
			}
			*/ // 20230217: switch to NSM counting
        // https://www.unicode.org/reports/tr39/#Optional_Detection
        if (NSM.has(decomposed[i])) {
            let j = i + 1;
            for(let cp; j < e && NSM.has(cp = decomposed[j]); j++)// a. Forbid sequences of the same nonspacing mark.
            for(let k = i; k < j; k++){
                if (decomposed[k] == cp) throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);
            }
            // parse to end so we have full nsm count
            // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
            if (j - i > NSM_MAX) // note: this slice starts with a base char or spacing-mark cm
            throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
            i = j;
        }
    }
// *** this code currently isn't needed ***
/*
	let cm_whitelist = M instanceof Map;
	for (let i = 0, e = cps.length; i < e; ) {
		let cp = cps[i++];
		let seqs = cm_whitelist && M.get(cp);
		if (seqs) { 
			// list of codepoints that can follow
			// if this exists, this will always be 1+
			let j = i;
			while (j < e && CM.has(cps[j])) j++;
			let cms = cps.slice(i, j);
			let match = seqs.find(seq => !compare_arrays(seq, cms));
			if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
			i = j;
		} else if (!V.has(cp)) {
			// https://www.unicode.org/reports/tr39/#mixed_script_confusables
			let quoted = quoted_cp(cp);
			for (let cp of cps) {
				let u = UNIQUE.get(cp);
				if (u && u !== g) {
					// if both scripts are restricted this error is confusing
					// because we don't differentiate RestrictedA from RestrictedB 
					if (!u.R) quoted = `${quoted} is ${u.N}`;
					break;
				}
			}
			throw new Error(`disallowed ${g.N} character: ${quoted}`);
			//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
			//throw new Error(`${g.N} does not allow: ${quoted}`);
		}
	}
	if (!cm_whitelist) {
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
				}
				i = j;
			}
		}
	}
	*/ }
// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abc💩d") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
function process(input, nf) {
    let ret = [];
    let chars = [];
    input = input.slice().reverse(); // flip so we can pop
    while(input.length){
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
            if (chars.length) {
                ret.push(nf(chars));
                chars = [];
            }
            ret.push(emoji);
        } else {
            let cp = input.pop();
            if (VALID.has(cp)) chars.push(cp);
            else {
                let cps = MAPPED.get(cp);
                if (cps) chars.push(...cps);
                else if (!IGNORED.has(cp)) throw error_disallowed(cp);
            }
        }
    }
    if (chars.length) ret.push(nf(chars));
    return ret;
}
function filter_fe0f(cps) {
    return cps.filter((cp)=>cp != FE0F);
}
// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// allows optional FE0F
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
    let node = EMOJI_ROOT;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten) eaten.length = 0; // clear input buffer (if needed)
    while(pos){
        let cp = cps[--pos];
        node = node.B.find((x)=>x.Q.has(cp));
        if (!node) break;
        if (node.S) saved = cp;
        else if (node.C) {
            if (cp === saved) break;
        }
        stack.push(cp);
        if (node.F) {
            stack.push(FE0F);
            if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F
        }
        if (node.V) {
            emoji = conform_emoji_copy(stack, node);
            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)
            cps.length = pos; // truncate
        }
    }
    /*
	// *** this code currently isn't needed ***
	if (!emoji) {
		let cp = cps[cps.length-1];
		if (EMOJI_SOLO.has(cp)) {
			if (eaten) eaten.push(cp);
			emoji = Emoji.of(cp);
			cps.pop();
		}
	}
	*/ return emoji;
}
// create a copy and fix any unicode quirks
function conform_emoji_copy(cps, node) {
    let copy = Emoji.from(cps); // copy stack
    if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)
    return copy;
}
// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
    // *** this code currently isn't needed ***
    //let ret = [...EMOJI_SOLO].map(x => [x]);
    let ret = [];
    build(EMOJI_ROOT, []);
    return ret.sort(compare_arrays);
    function build(node, cps, saved) {
        if (node.S) saved = cps[cps.length - 1];
        else if (node.C) {
            if (saved === cps[cps.length - 1]) return;
        }
        if (node.F) cps.push(FE0F);
        if (node.V) ret.push(conform_emoji_copy(cps, node));
        for (let br of node.B)for (let cp of br.Q)build(br, [
            ...cps,
            cp
        ], saved);
    }
}
// ************************************************************
// tokenizer 
const TY_VALID = "valid";
const TY_MAPPED = "mapped";
const TY_IGNORED = "ignored";
const TY_DISALLOWED = "disallowed";
const TY_EMOJI = "emoji";
const TY_NFC = "nfc";
const TY_STOP = "stop";
function ens_tokenize(name, { nf = true } = {}) {
    let input = explode_cp(name).reverse();
    let eaten = [];
    let tokens = [];
    while(input.length){
        let emoji = consume_emoji_reversed(input, eaten);
        if (emoji) tokens.push({
            type: TY_EMOJI,
            emoji,
            input: eaten.slice(),
            cps: filter_fe0f(emoji)
        });
        else {
            let cp = input.pop();
            if (cp == STOP) tokens.push({
                type: TY_STOP,
                cp
            });
            else if (VALID.has(cp)) tokens.push({
                type: TY_VALID,
                cps: [
                    cp
                ]
            });
            else if (IGNORED.has(cp)) tokens.push({
                type: TY_IGNORED,
                cp
            });
            else {
                let cps = MAPPED.get(cp);
                if (cps) tokens.push({
                    type: TY_MAPPED,
                    cp,
                    cps: cps.slice()
                });
                else tokens.push({
                    type: TY_DISALLOWED,
                    cp
                });
            }
        }
    }
    if (nf) for(let i = 0, start = -1; i < tokens.length; i++){
        let token = tokens[i];
        if (is_valid_or_mapped(token.type)) {
            if (requires_check(token.cps)) {
                let end = i + 1;
                for(let pos = end; pos < tokens.length; pos++){
                    let { type, cps } = tokens[pos];
                    if (is_valid_or_mapped(type)) {
                        if (!requires_check(cps)) break;
                        end = pos + 1;
                    } else if (type !== TY_IGNORED) break;
                }
                if (start < 0) start = i;
                let slice = tokens.slice(start, end);
                let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens
                let cps = nfc(cps0);
                if (compare_arrays(cps, cps0)) {
                    tokens.splice(start, end - start, {
                        type: TY_NFC,
                        input: cps0,
                        cps,
                        tokens0: collapse_valid_tokens(slice),
                        tokens: ens_tokenize(str_from_cps(cps), {
                            nf: false
                        })
                    });
                    i = start;
                } else i = end - 1; // skip to end of slice
                start = -1; // reset
            } else start = i; // remember last
        } else if (token.type !== TY_IGNORED) start = -1; // reset
    }
    return collapse_valid_tokens(tokens);
}
function is_valid_or_mapped(type) {
    return type == TY_VALID || type == TY_MAPPED;
}
function requires_check(cps) {
    return cps.some((cp)=>NFC_CHECK.has(cp));
}
function collapse_valid_tokens(tokens) {
    for(let i = 0; i < tokens.length; i++)if (tokens[i].type == TY_VALID) {
        let j = i + 1;
        while(j < tokens.length && tokens[j].type == TY_VALID)j++;
        tokens.splice(i, j - i, {
            type: TY_VALID,
            cps: tokens.slice(i, j).flatMap((x)=>x.cps)
        });
    }
    return tokens;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3eevR":[function(require,module,exports) {
// src/chains.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>(0, _chains.arbitrum));
parcelHelpers.export(exports, "arbitrumGoerli", ()=>(0, _chains.arbitrumGoerli));
parcelHelpers.export(exports, "aurora", ()=>(0, _chains.aurora));
parcelHelpers.export(exports, "auroraTestnet", ()=>(0, _chains.auroraTestnet));
parcelHelpers.export(exports, "avalanche", ()=>(0, _chains.avalanche));
parcelHelpers.export(exports, "avalancheFuji", ()=>(0, _chains.avalancheFuji));
parcelHelpers.export(exports, "baseGoerli", ()=>(0, _chains.baseGoerli));
parcelHelpers.export(exports, "boba", ()=>(0, _chains.boba));
parcelHelpers.export(exports, "bronos", ()=>(0, _chains.bronos));
parcelHelpers.export(exports, "bronosTestnet", ()=>(0, _chains.bronosTestnet));
parcelHelpers.export(exports, "bsc", ()=>(0, _chains.bsc));
parcelHelpers.export(exports, "bscTestnet", ()=>(0, _chains.bscTestnet));
parcelHelpers.export(exports, "bxn", ()=>(0, _chains.bxn));
parcelHelpers.export(exports, "bxnTestnet", ()=>(0, _chains.bxnTestnet));
parcelHelpers.export(exports, "canto", ()=>(0, _chains.canto));
parcelHelpers.export(exports, "celo", ()=>(0, _chains.celo));
parcelHelpers.export(exports, "celoAlfajores", ()=>(0, _chains.celoAlfajores));
parcelHelpers.export(exports, "celoCannoli", ()=>(0, _chains.celoCannoli));
parcelHelpers.export(exports, "cronos", ()=>(0, _chains.cronos));
parcelHelpers.export(exports, "cronosTestnet", ()=>(0, _chains.cronosTestnet));
parcelHelpers.export(exports, "crossbell", ()=>(0, _chains.crossbell));
parcelHelpers.export(exports, "dfk", ()=>(0, _chains.dfk));
parcelHelpers.export(exports, "dogechain", ()=>(0, _chains.dogechain));
parcelHelpers.export(exports, "edgeware", ()=>(0, _chains.edgeware));
parcelHelpers.export(exports, "edgewareTestnet", ()=>(0, _chains.edgewareTestnet));
parcelHelpers.export(exports, "evmos", ()=>(0, _chains.evmos));
parcelHelpers.export(exports, "evmosTestnet", ()=>(0, _chains.evmosTestnet));
parcelHelpers.export(exports, "fantom", ()=>(0, _chains.fantom));
parcelHelpers.export(exports, "fantomTestnet", ()=>(0, _chains.fantomTestnet));
parcelHelpers.export(exports, "fibo", ()=>(0, _chains.fibo));
parcelHelpers.export(exports, "filecoin", ()=>(0, _chains.filecoin));
parcelHelpers.export(exports, "filecoinCalibration", ()=>(0, _chains.filecoinCalibration));
parcelHelpers.export(exports, "filecoinHyperspace", ()=>(0, _chains.filecoinHyperspace));
parcelHelpers.export(exports, "flare", ()=>(0, _chains.flare));
parcelHelpers.export(exports, "flareTestnet", ()=>(0, _chains.flareTestnet));
parcelHelpers.export(exports, "foundry", ()=>(0, _chains.foundry));
parcelHelpers.export(exports, "iotex", ()=>(0, _chains.iotex));
parcelHelpers.export(exports, "iotexTestnet", ()=>(0, _chains.iotexTestnet));
parcelHelpers.export(exports, "goerli", ()=>(0, _chains.goerli));
parcelHelpers.export(exports, "gnosis", ()=>(0, _chains.gnosis));
parcelHelpers.export(exports, "gnosisChiado", ()=>(0, _chains.gnosisChiado));
parcelHelpers.export(exports, "haqqMainnet", ()=>(0, _chains.haqqMainnet));
parcelHelpers.export(exports, "haqqTestedge2", ()=>(0, _chains.haqqTestedge2));
parcelHelpers.export(exports, "hardhat", ()=>(0, _chains.hardhat));
parcelHelpers.export(exports, "harmonyOne", ()=>(0, _chains.harmonyOne));
parcelHelpers.export(exports, "klaytn", ()=>(0, _chains.klaytn));
parcelHelpers.export(exports, "lineaTestnet", ()=>(0, _chains.lineaTestnet));
parcelHelpers.export(exports, "localhost", ()=>(0, _chains.localhost));
parcelHelpers.export(exports, "mainnet", ()=>(0, _chains.mainnet));
parcelHelpers.export(exports, "metis", ()=>(0, _chains.metis));
parcelHelpers.export(exports, "metisGoerli", ()=>(0, _chains.metisGoerli));
parcelHelpers.export(exports, "moonbaseAlpha", ()=>(0, _chains.moonbaseAlpha));
parcelHelpers.export(exports, "moonbeam", ()=>(0, _chains.moonbeam));
parcelHelpers.export(exports, "moonriver", ()=>(0, _chains.moonriver));
parcelHelpers.export(exports, "nexi", ()=>(0, _chains.nexi));
parcelHelpers.export(exports, "okc", ()=>(0, _chains.okc));
parcelHelpers.export(exports, "optimism", ()=>(0, _chains.optimism));
parcelHelpers.export(exports, "optimismGoerli", ()=>(0, _chains.optimismGoerli));
parcelHelpers.export(exports, "polygon", ()=>(0, _chains.polygon));
parcelHelpers.export(exports, "polygonMumbai", ()=>(0, _chains.polygonMumbai));
parcelHelpers.export(exports, "polygonZkEvm", ()=>(0, _chains.polygonZkEvm));
parcelHelpers.export(exports, "polygonZkEvmTestnet", ()=>(0, _chains.polygonZkEvmTestnet));
parcelHelpers.export(exports, "pulsechain", ()=>(0, _chains.pulsechain));
parcelHelpers.export(exports, "pulsechainV4", ()=>(0, _chains.pulsechainV4));
parcelHelpers.export(exports, "scrollTestnet", ()=>(0, _chains.scrollTestnet));
parcelHelpers.export(exports, "sepolia", ()=>(0, _chains.sepolia));
parcelHelpers.export(exports, "skaleBlockBrawlers", ()=>(0, _chains.skaleBlockBrawlers));
parcelHelpers.export(exports, "skaleCalypso", ()=>(0, _chains.skaleCalypso));
parcelHelpers.export(exports, "skaleCalypsoTestnet", ()=>(0, _chains.skaleCalypsoTestnet));
parcelHelpers.export(exports, "skaleChaosTestnet", ()=>(0, _chains.skaleChaosTestnet));
parcelHelpers.export(exports, "skaleCryptoBlades", ()=>(0, _chains.skaleCryptoBlades));
parcelHelpers.export(exports, "skaleCryptoColosseum", ()=>(0, _chains.skaleCryptoColosseum));
parcelHelpers.export(exports, "skaleEuropa", ()=>(0, _chains.skaleEuropa));
parcelHelpers.export(exports, "skaleEuropaTestnet", ()=>(0, _chains.skaleEuropaTestnet));
parcelHelpers.export(exports, "skaleExorde", ()=>(0, _chains.skaleExorde));
parcelHelpers.export(exports, "skaleHumanProtocol", ()=>(0, _chains.skaleHumanProtocol));
parcelHelpers.export(exports, "skaleNebula", ()=>(0, _chains.skaleNebula));
parcelHelpers.export(exports, "skaleNebulaTestnet", ()=>(0, _chains.skaleNebulaTestnet));
parcelHelpers.export(exports, "skaleRazor", ()=>(0, _chains.skaleRazor));
parcelHelpers.export(exports, "skaleTitan", ()=>(0, _chains.skaleTitan));
parcelHelpers.export(exports, "skaleTitanTestnet", ()=>(0, _chains.skaleTitanTestnet));
parcelHelpers.export(exports, "songbird", ()=>(0, _chains.songbird));
parcelHelpers.export(exports, "songbirdTestnet", ()=>(0, _chains.songbirdTestnet));
parcelHelpers.export(exports, "shardeumSphinx", ()=>(0, _chains.shardeumSphinx));
parcelHelpers.export(exports, "syscoin", ()=>(0, _chains.syscoin));
parcelHelpers.export(exports, "taraxa", ()=>(0, _chains.taraxa));
parcelHelpers.export(exports, "taraxaTestnet", ()=>(0, _chains.taraxaTestnet));
parcelHelpers.export(exports, "telos", ()=>(0, _chains.telos));
parcelHelpers.export(exports, "telosTestnet", ()=>(0, _chains.telosTestnet));
parcelHelpers.export(exports, "thunderTestnet", ()=>(0, _chains.thunderTestnet));
parcelHelpers.export(exports, "wanchain", ()=>(0, _chains.wanchain));
parcelHelpers.export(exports, "wanchainTestnet", ()=>(0, _chains.wanchainTestnet));
parcelHelpers.export(exports, "xdc", ()=>(0, _chains.xdc));
parcelHelpers.export(exports, "xdcTestnet", ()=>(0, _chains.xdcTestnet));
parcelHelpers.export(exports, "zhejiang", ()=>(0, _chains.zhejiang));
parcelHelpers.export(exports, "zkSync", ()=>(0, _chains.zkSync));
parcelHelpers.export(exports, "zkSyncTestnet", ()=>(0, _chains.zkSyncTestnet));
parcelHelpers.export(exports, "zora", ()=>(0, _chains.zora));
parcelHelpers.export(exports, "zoraTestnet", ()=>(0, _chains.zoraTestnet));
var _chains = require("@wagmi/chains");

},{"@wagmi/chains":"01nY7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01nY7":[function(require,module,exports) {
// src/arbitrum.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>arbitrum);
parcelHelpers.export(exports, "arbitrumGoerli", ()=>arbitrumGoerli);
parcelHelpers.export(exports, "arbitrumNova", ()=>arbitrumNova);
parcelHelpers.export(exports, "aurora", ()=>aurora);
parcelHelpers.export(exports, "auroraTestnet", ()=>auroraTestnet);
parcelHelpers.export(exports, "avalanche", ()=>avalanche);
parcelHelpers.export(exports, "avalancheFuji", ()=>avalancheFuji);
parcelHelpers.export(exports, "baseGoerli", ()=>baseGoerli);
parcelHelpers.export(exports, "bearNetworkChainMainnet", ()=>bearNetworkChainMainnet);
parcelHelpers.export(exports, "bearNetworkChainTestnet", ()=>bearNetworkChainTestnet);
parcelHelpers.export(exports, "boba", ()=>boba);
parcelHelpers.export(exports, "bronos", ()=>bronos);
parcelHelpers.export(exports, "bronosTestnet", ()=>bronosTestnet);
parcelHelpers.export(exports, "bsc", ()=>bsc);
parcelHelpers.export(exports, "bscTestnet", ()=>bscTestnet);
parcelHelpers.export(exports, "bxn", ()=>bxn);
parcelHelpers.export(exports, "bxnTestnet", ()=>bxnTestnet);
parcelHelpers.export(exports, "canto", ()=>canto);
parcelHelpers.export(exports, "celo", ()=>celo);
parcelHelpers.export(exports, "celoAlfajores", ()=>celoAlfajores);
parcelHelpers.export(exports, "celoCannoli", ()=>celoCannoli);
parcelHelpers.export(exports, "confluxESpace", ()=>confluxESpace);
parcelHelpers.export(exports, "cronos", ()=>cronos);
parcelHelpers.export(exports, "cronosTestnet", ()=>cronosTestnet);
parcelHelpers.export(exports, "crossbell", ()=>crossbell);
parcelHelpers.export(exports, "dfk", ()=>dfk);
parcelHelpers.export(exports, "dogechain", ()=>dogechain);
parcelHelpers.export(exports, "edgeware", ()=>edgeware);
parcelHelpers.export(exports, "edgewareTestnet", ()=>edgewareTestnet);
parcelHelpers.export(exports, "ekta", ()=>ekta);
parcelHelpers.export(exports, "ektaTestnet", ()=>ektaTestnet);
parcelHelpers.export(exports, "evmos", ()=>evmos);
parcelHelpers.export(exports, "evmosTestnet", ()=>evmosTestnet);
parcelHelpers.export(exports, "fantom", ()=>fantom);
parcelHelpers.export(exports, "fantomTestnet", ()=>fantomTestnet);
parcelHelpers.export(exports, "fibo", ()=>fibo);
parcelHelpers.export(exports, "filecoin", ()=>filecoin);
parcelHelpers.export(exports, "filecoinCalibration", ()=>filecoinCalibration);
parcelHelpers.export(exports, "filecoinHyperspace", ()=>filecoinHyperspace);
parcelHelpers.export(exports, "flare", ()=>flare);
parcelHelpers.export(exports, "flareTestnet", ()=>flareTestnet);
parcelHelpers.export(exports, "foundry", ()=>foundry);
parcelHelpers.export(exports, "fuse", ()=>fuse);
parcelHelpers.export(exports, "gnosis", ()=>gnosis);
parcelHelpers.export(exports, "gnosisChiado", ()=>gnosisChiado);
parcelHelpers.export(exports, "goerli", ()=>goerli);
parcelHelpers.export(exports, "haqqMainnet", ()=>haqqMainnet);
parcelHelpers.export(exports, "haqqTestedge2", ()=>haqqTestedge2);
parcelHelpers.export(exports, "hardhat", ()=>hardhat);
parcelHelpers.export(exports, "harmonyOne", ()=>harmonyOne);
parcelHelpers.export(exports, "iotex", ()=>iotex);
parcelHelpers.export(exports, "iotexTestnet", ()=>iotexTestnet);
parcelHelpers.export(exports, "klaytn", ()=>klaytn);
parcelHelpers.export(exports, "lineaTestnet", ()=>lineaTestnet);
parcelHelpers.export(exports, "localhost", ()=>localhost);
parcelHelpers.export(exports, "mainnet", ()=>mainnet);
parcelHelpers.export(exports, "metis", ()=>metis);
parcelHelpers.export(exports, "metisGoerli", ()=>metisGoerli);
parcelHelpers.export(exports, "moonbaseAlpha", ()=>moonbaseAlpha);
parcelHelpers.export(exports, "moonbeam", ()=>moonbeam);
parcelHelpers.export(exports, "moonriver", ()=>moonriver);
parcelHelpers.export(exports, "neonDevnet", ()=>neonDevnet);
parcelHelpers.export(exports, "nexi", ()=>nexi);
parcelHelpers.export(exports, "oasys", ()=>oasys);
parcelHelpers.export(exports, "okc", ()=>okc);
parcelHelpers.export(exports, "optimism", ()=>optimism);
parcelHelpers.export(exports, "optimismGoerli", ()=>optimismGoerli);
parcelHelpers.export(exports, "polygon", ()=>polygon);
parcelHelpers.export(exports, "polygonMumbai", ()=>polygonMumbai);
parcelHelpers.export(exports, "polygonZkEvm", ()=>polygonZkEvm);
parcelHelpers.export(exports, "polygonZkEvmTestnet", ()=>polygonZkEvmTestnet);
parcelHelpers.export(exports, "pulsechain", ()=>pulsechain);
parcelHelpers.export(exports, "pulsechainV4", ()=>pulsechainV4);
parcelHelpers.export(exports, "scrollTestnet", ()=>scrollTestnet);
parcelHelpers.export(exports, "sepolia", ()=>sepolia);
parcelHelpers.export(exports, "shardeumSphinx", ()=>shardeumSphinx);
parcelHelpers.export(exports, "skaleBlockBrawlers", ()=>skaleBlockBrawlers);
parcelHelpers.export(exports, "skaleCalypso", ()=>skaleCalypso);
parcelHelpers.export(exports, "skaleCalypsoTestnet", ()=>skaleCalypsoTestnet);
parcelHelpers.export(exports, "skaleChaosTestnet", ()=>skaleChaosTestnet);
parcelHelpers.export(exports, "skaleCryptoBlades", ()=>skaleCryptoBlades);
parcelHelpers.export(exports, "skaleCryptoColosseum", ()=>skaleCryptoColosseum);
parcelHelpers.export(exports, "skaleEuropa", ()=>skaleEuropa);
parcelHelpers.export(exports, "skaleEuropaTestnet", ()=>skaleEuropaTestnet);
parcelHelpers.export(exports, "skaleExorde", ()=>skaleExorde);
parcelHelpers.export(exports, "skaleHumanProtocol", ()=>skaleHumanProtocol);
parcelHelpers.export(exports, "skaleNebula", ()=>skaleNebula);
parcelHelpers.export(exports, "skaleNebulaTestnet", ()=>skaleNebulaTestnet);
parcelHelpers.export(exports, "skaleRazor", ()=>skaleRazor);
parcelHelpers.export(exports, "skaleTitan", ()=>skaleTitan);
parcelHelpers.export(exports, "skaleTitanTestnet", ()=>skaleTitanTestnet);
parcelHelpers.export(exports, "songbird", ()=>songbird);
parcelHelpers.export(exports, "songbirdTestnet", ()=>songbirdTestnet);
parcelHelpers.export(exports, "syscoin", ()=>syscoin);
parcelHelpers.export(exports, "taraxa", ()=>taraxa);
parcelHelpers.export(exports, "taraxaTestnet", ()=>taraxaTestnet);
parcelHelpers.export(exports, "telos", ()=>telos);
parcelHelpers.export(exports, "telosTestnet", ()=>telosTestnet);
parcelHelpers.export(exports, "thunderTestnet", ()=>thunderTestnet);
parcelHelpers.export(exports, "wanchain", ()=>wanchain);
parcelHelpers.export(exports, "wanchainTestnet", ()=>wanchainTestnet);
parcelHelpers.export(exports, "xdc", ()=>xdc);
parcelHelpers.export(exports, "xdcTestnet", ()=>xdcTestnet);
parcelHelpers.export(exports, "zhejiang", ()=>zhejiang);
parcelHelpers.export(exports, "zkSync", ()=>zkSync);
parcelHelpers.export(exports, "zkSyncTestnet", ()=>zkSyncTestnet);
parcelHelpers.export(exports, "zora", ()=>zora);
parcelHelpers.export(exports, "zoraTestnet", ()=>zoraTestnet);
var arbitrum = {
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://arb-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://arb-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://arbitrum-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://arbitrum-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        },
        default: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7654707
        }
    }
};
// src/arbitrumGoerli.ts
var arbitrumGoerli = {
    id: 421613,
    name: "Arbitrum Goerli",
    network: "arbitrum-goerli",
    nativeCurrency: {
        name: "Arbitrum Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://arb-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://arb-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://arbitrum-goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://arbitrum-goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://goerli-rollup.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://goerli-rollup.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://goerli.arbiscan.io/"
        },
        default: {
            name: "Arbiscan",
            url: "https://goerli.arbiscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 88114
        }
    },
    testnet: true
};
// src/arbitrumNova.ts
var arbitrumNova = {
    id: 42170,
    name: "Arbitrum Nova",
    network: "arbitrum-nova",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        blast: {
            http: [
                "https://arbitrum-nova.public.blastapi.io"
            ],
            webSocket: [
                "wss://arbitrum-nova.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://nova.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://nova.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://nova.arbiscan.io"
        },
        blockScout: {
            name: "BlockScout",
            url: "https://nova-explorer.arbitrum.io/"
        },
        default: {
            name: "Arbiscan",
            url: "https://nova.arbiscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1746963
        }
    }
};
// src/aurora.ts
var aurora = {
    id: 1313161554,
    name: "Aurora",
    network: "aurora",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        infura: {
            http: [
                "https://aurora-mainnet.infura.io/v3"
            ]
        },
        default: {
            http: [
                "https://mainnet.aurora.dev"
            ]
        },
        public: {
            http: [
                "https://mainnet.aurora.dev"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Aurorascan",
            url: "https://aurorascan.dev"
        },
        default: {
            name: "Aurorascan",
            url: "https://aurorascan.dev"
        }
    }
};
// src/auroraTestnet.ts
var auroraTestnet = {
    id: 1313161555,
    name: "Aurora Testnet",
    network: "aurora-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        infura: {
            http: [
                "https://aurora-testnet.infura.io/v3"
            ]
        },
        default: {
            http: [
                "https://testnet.aurora.dev"
            ]
        },
        public: {
            http: [
                "https://testnet.aurora.dev"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Aurorascan",
            url: "https://testnet.aurorascan.dev"
        },
        default: {
            name: "Aurorascan",
            url: "https://testnet.aurorascan.dev"
        }
    },
    testnet: true
};
// src/avalanche.ts
var avalanche = {
    id: 43114,
    name: "Avalanche",
    network: "avalanche",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 11907934
        }
    }
};
// src/avalancheFuji.ts
var avalancheFuji = {
    id: 43113,
    name: "Avalanche Fuji",
    network: "avalanche-fuji",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7096959
        }
    },
    testnet: true
};
// src/baseGoerli.ts
var baseGoerli = {
    id: 84531,
    network: "base-goerli",
    name: "Base Goerli",
    nativeCurrency: {
        name: "Base Goerli",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://goerli.base.org"
            ]
        },
        public: {
            http: [
                "https://goerli.base.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Basescan",
            url: "https://goerli.basescan.org"
        },
        default: {
            name: "Basescan",
            url: "https://goerli.basescan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1376988
        }
    },
    testnet: true
};
// src/bearNetworkChainMainnet.ts
var bearNetworkChainMainnet = {
    id: 641230,
    name: "Bear Network Chain Mainnet",
    network: "BearNetworkChainMainnet",
    nativeCurrency: {
        decimals: 18,
        name: "BearNetworkChain",
        symbol: "BRNKC"
    },
    rpcUrls: {
        public: {
            http: [
                "https://brnkc-mainnet.bearnetwork.net"
            ]
        },
        default: {
            http: [
                "https://brnkc-mainnet.bearnetwork.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BrnkScan",
            url: "https://brnkscan.bearnetwork.net"
        }
    }
};
// src/bearNetworkChainTestnet.ts
var bearNetworkChainTestnet = {
    id: 751230,
    name: "Bear Network Chain Testnet",
    network: "BearNetworkChainTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "tBRNKC",
        symbol: "tBRNKC"
    },
    rpcUrls: {
        public: {
            http: [
                "https://brnkc-test.bearnetwork.net"
            ]
        },
        default: {
            http: [
                "https://brnkc-test.bearnetwork.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BrnkTestScan",
            url: "https://brnktest-scan.bearnetwork.net"
        }
    },
    testnet: true
};
// src/boba.ts
var boba = {
    id: 288,
    name: "Boba Network",
    network: "boba",
    nativeCurrency: {
        decimals: 18,
        name: "Boba",
        symbol: "BOBA"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.boba.network"
            ]
        },
        public: {
            http: [
                "https://mainnet.boba.network"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BOBAScan",
            url: "https://bobascan.com"
        },
        default: {
            name: "BOBAScan",
            url: "https://bobascan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 446859
        }
    }
};
// src/bronos.ts
var bronos = {
    id: 1039,
    name: "Bronos",
    network: "bronos",
    nativeCurrency: {
        decimals: 18,
        name: "BRO",
        symbol: "BRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm.bronos.org"
            ]
        },
        public: {
            http: [
                "https://evm.bronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BronoScan",
            url: "https://broscan.bronos.org"
        }
    }
};
// src/bronosTestnet.ts
var bronosTestnet = {
    id: 1038,
    name: "Bronos Testnet",
    network: "bronos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Bronos Coin",
        symbol: "tBRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm-testnet.bronos.org"
            ]
        },
        public: {
            http: [
                "https://evm-testnet.bronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BronoScan",
            url: "https://tbroscan.bronos.org"
        }
    },
    testnet: true
};
// src/bsc.ts
var bsc = {
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.ankr.com/bsc"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/bsc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BscScan",
            url: "https://bscscan.com"
        },
        default: {
            name: "BscScan",
            url: "https://bscscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 15921452
        }
    }
};
// src/bscTestnet.ts
var bscTestnet = {
    id: 97,
    name: "Binance Smart Chain Testnet",
    network: "bsc-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "tBNB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://data-seed-prebsc-1-s1.binance.org:8545"
            ]
        },
        public: {
            http: [
                "https://data-seed-prebsc-1-s1.binance.org:8545"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BscScan",
            url: "https://testnet.bscscan.com"
        },
        default: {
            name: "BscScan",
            url: "https://testnet.bscscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 17422483
        }
    },
    testnet: true
};
// src/bxn.ts
var bxn = {
    id: 4999,
    name: "BlackFort Exchange Network",
    network: "bxn",
    nativeCurrency: {
        name: "BlackFort Token",
        symbol: "BXN",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.blackfort.network/rpc"
            ]
        },
        public: {
            http: [
                "https://mainnet.blackfort.network/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://explorer.blackfort.network"
        }
    }
};
// src/bxnTestnet.ts
var bxnTestnet = {
    id: 4777,
    name: "BlackFort Exchange Network Testnet",
    network: "bxnTestnet",
    nativeCurrency: {
        name: "BlackFort Testnet Token",
        symbol: "TBXN",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.blackfort.network/rpc"
            ]
        },
        public: {
            http: [
                "https://testnet.blackfort.network/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://testnet-explorer.blackfort.network"
        }
    }
};
// src/canto.ts
var canto = {
    id: 7700,
    name: "Canto",
    network: "canto",
    nativeCurrency: {
        decimals: 18,
        name: "Canto",
        symbol: "CANTO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://canto.slingshot.finance"
            ]
        },
        public: {
            http: [
                "https://canto.slingshot.finance"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Canto EVM Explorer (Blockscout)",
            url: "https://evm.explorer.canto.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 2905789
        }
    }
};
// src/celo.ts
var celo = {
    id: 42220,
    name: "Celo",
    network: "celo",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://forno.celo.org"
            ]
        },
        infura: {
            http: [
                "https://celo-mainnet.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://forno.celo.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/mainnet"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://celoscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 13112599
        }
    },
    testnet: false
};
// src/celoAlfajores.ts
var celoAlfajores = {
    id: 44787,
    name: "Alfajores",
    network: "celo-alfajores",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "A-CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        },
        infura: {
            http: [
                "https://celo-alfajores.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/alfajores"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://alfajores.celoscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 14569001
        }
    },
    testnet: true
};
// src/celoCannoli.ts
var celoCannoli = {
    id: 17323,
    name: "Cannoli",
    network: "celo-cannoli",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "C-CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://forno.cannoli.celo-testnet.org"
            ]
        },
        public: {
            http: [
                "https://forno.cannoli.celo-testnet.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/cannoli"
        }
    },
    contracts: {
        multicall3: {
            address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
            blockCreated: 87429
        }
    },
    testnet: true
};
// src/confluxESpace.ts
var confluxESpace = {
    id: 1030,
    name: "Conflux eSpace",
    network: "cfx-espace",
    nativeCurrency: {
        name: "Conflux",
        symbol: "CFX",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm.confluxrpc.org"
            ]
        },
        public: {
            http: [
                "https://evm.confluxrpc.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "ConfluxScan",
            url: "https://evm.confluxscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
            blockCreated: 68602935
        }
    }
};
// src/cronos.ts
var cronos = {
    id: 25,
    name: "Cronos",
    network: "cronos",
    nativeCurrency: {
        decimals: 18,
        name: "Cronos",
        symbol: "CRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://node.croswap.com/rpc"
            ]
        },
        public: {
            http: [
                "https://node.croswap.com/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "CronosScan",
            url: "https://cronoscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1963112
        }
    }
};
// src/cronosTestnet.ts
var cronosTestnet = {
    id: 338,
    name: "Cronos Testnet",
    network: "cronos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "CRO",
        symbol: "tCRO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://evm-t3.cronos.org"
            ]
        },
        public: {
            http: [
                "https://evm-t3.cronos.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Cronos Explorer",
            url: "https://cronos.org/explorer/testnet3"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 10191251
        }
    },
    testnet: true
};
// src/crossbell.ts
var crossbell = {
    id: 3737,
    network: "crossbell",
    name: "Crossbell",
    nativeCurrency: {
        decimals: 18,
        name: "CSB",
        symbol: "CSB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.crossbell.io"
            ]
        },
        public: {
            http: [
                "https://rpc.crossbell.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "CrossScan",
            url: "https://scan.crossbell.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
            blockCreated: 23499787
        }
    }
};
// src/dfk.ts
var dfk = {
    id: 53935,
    name: "DFK Chain",
    network: "dfk",
    nativeCurrency: {
        decimals: 18,
        name: "Jewel",
        symbol: "JEWEL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"
            ]
        },
        public: {
            http: [
                "https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "DFKSubnetScan",
            url: "https://subnets.avax.network/defi-kingdoms"
        },
        default: {
            name: "DFKSubnetScan",
            url: "https://subnets.avax.network/defi-kingdoms"
        }
    }
};
// src/dogechain.ts
var dogechain = {
    id: 2e3,
    name: "Dogechain",
    network: "dogechain",
    nativeCurrency: {
        decimals: 18,
        name: "Dogechain",
        symbol: "DC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.dogechain.dog"
            ]
        },
        public: {
            http: [
                "https://rpc.dogechain.dog"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "DogeChainExplorer",
            url: "https://explorer.dogechain.dog"
        },
        default: {
            name: "DogeChainExplorer",
            url: "https://explorer.dogechain.dog"
        }
    }
};
// src/edgeware.ts
var edgeware = {
    id: 2021,
    name: "Edgeware EdgeEVM Mainnet",
    network: "edgeware",
    nativeCurrency: {
        decimals: 18,
        name: "Edgeware",
        symbol: "EDG"
    },
    rpcUrls: {
        default: {
            http: [
                "https://edgeware-evm.jelliedowl.net"
            ]
        },
        public: {
            http: [
                "https://edgeware-evm.jelliedowl.net"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Edgscan by Bharathcoorg",
            url: "https://edgscan.live"
        },
        default: {
            name: "Edgscan by Bharathcoorg",
            url: "https://edgscan.live"
        }
    },
    contracts: {
        multicall3: {
            address: "0xDDF47eEB4e5FF4AA60e063E0Ec4f7C35B47Ed445",
            blockCreated: 17126780
        }
    }
};
// src/edgewareTestnet.ts
var edgewareTestnet = {
    id: 2022,
    name: "Beresheet BereEVM Testnet",
    network: "edgewareTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "Testnet EDG",
        symbol: "tEDG"
    },
    rpcUrls: {
        default: {
            http: [
                "https://beresheet-evm.jelliedowl.net"
            ]
        },
        public: {
            http: [
                "https://beresheet-evm.jelliedowl.net"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Edgscan by Bharathcoorg",
            url: "https://testnet.edgscan.live"
        },
        default: {
            name: "Edgscan by Bharathcoorg",
            url: "https://testnet.edgscan.live"
        }
    }
};
// src/evmos.ts
var evmos = {
    id: 9001,
    name: "Evmos",
    network: "evmos",
    nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://eth.bd.evmos.org:8545"
            ]
        },
        public: {
            http: [
                "https://eth.bd.evmos.org:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Evmos Block Explorer",
            url: "https://escan.live"
        }
    }
};
// src/evmosTestnet.ts
var evmosTestnet = {
    id: 9e3,
    name: "Evmos Testnet",
    network: "evmos-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://eth.bd.evmos.dev:8545"
            ]
        },
        public: {
            http: [
                "https://eth.bd.evmos.dev:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Evmos Testnet Block Explorer",
            url: "https://evm.evmos.dev/"
        }
    }
};
// src/ekta.ts
var ekta = {
    id: 1994,
    name: "Ekta",
    network: "ekta",
    nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
    },
    rpcUrls: {
        public: {
            http: [
                "https://main.ekta.io"
            ]
        },
        default: {
            http: [
                "https://main.ekta.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Ektascan",
            url: "https://ektascan.io"
        }
    }
};
// src/ektaTestnet.ts
var ektaTestnet = {
    id: 1004,
    name: "Ekta Testnet",
    network: "ekta-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
    },
    rpcUrls: {
        public: {
            http: [
                "https://test.ekta.io:8545"
            ]
        },
        default: {
            http: [
                "https://test.ekta.io:8545"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Test Ektascan",
            url: "https://test.ektascan.io"
        }
    },
    testnet: true
};
// src/fantom.ts
var fantom = {
    id: 250,
    name: "Fantom",
    network: "fantom",
    nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.ankr.com/fantom"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/fantom"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "FTMScan",
            url: "https://ftmscan.com"
        },
        default: {
            name: "FTMScan",
            url: "https://ftmscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 33001987
        }
    }
};
// src/fantomTestnet.ts
var fantomTestnet = {
    id: 4002,
    name: "Fantom Testnet",
    network: "fantom-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.testnet.fantom.network"
            ]
        },
        public: {
            http: [
                "https://rpc.testnet.fantom.network"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "FTMScan",
            url: "https://testnet.ftmscan.com"
        },
        default: {
            name: "FTMScan",
            url: "https://testnet.ftmscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 8328688
        }
    }
};
// src/fibo.ts
var fibo = {
    id: 12306,
    name: "Fibo Chain",
    network: "fibochain",
    nativeCurrency: {
        decimals: 18,
        name: "fibo",
        symbol: "FIBO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://network.hzroc.art"
            ]
        },
        public: {
            http: [
                "https://network.hzroc.art"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "FiboScan",
            url: "https://scan.fibochain.org"
        }
    }
};
// src/filecoin.ts
var filecoin = {
    id: 314,
    name: "Filecoin Mainnet",
    network: "filecoin-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filfox",
            url: "https://filfox.info/en"
        },
        filscan: {
            name: "Filscan",
            url: "https://filscan.io"
        },
        filscout: {
            name: "Filscout",
            url: "https://filscout.io/en"
        },
        glif: {
            name: "Glif",
            url: "https://explorer.glif.io"
        }
    }
};
// src/filecoinCalibration.ts
var filecoinCalibration = {
    id: 314159,
    name: "Filecoin Calibration",
    network: "filecoin-calibration",
    nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filscan",
            url: "https://calibration.filscan.io"
        }
    }
};
// src/filecoinHyperspace.ts
var filecoinHyperspace = {
    id: 3141,
    name: "Filecoin Hyperspace",
    network: "filecoin-hyperspace",
    nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.hyperspace.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.hyperspace.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filfox",
            url: "https://hyperspace.filfox.info/en"
        },
        filscan: {
            name: "Filscan",
            url: "https://hyperspace.filscan.io"
        }
    }
};
// src/flare.ts
var flare = {
    id: 14,
    name: "Flare Mainnet",
    network: "flare-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "flare",
        symbol: "FLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://flare-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://flare-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Flare Explorer",
            url: "https://flare-explorer.flare.network"
        }
    }
};
// src/flareTestnet.ts
var flareTestnet = {
    id: 114,
    name: "Coston2",
    network: "coston2",
    nativeCurrency: {
        decimals: 18,
        name: "coston2flare",
        symbol: "C2FLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://coston2-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://coston2-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Coston2 Explorer",
            url: "https://coston2-explorer.flare.network"
        }
    },
    testnet: true
};
// src/foundry.ts
var foundry = {
    id: 31337,
    name: "Foundry",
    network: "foundry",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ],
            webSocket: [
                "ws://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ],
            webSocket: [
                "ws://127.0.0.1:8545"
            ]
        }
    }
};
// src/fuse.ts
var fuse = {
    id: 122,
    name: "Fuse",
    network: "fuse",
    nativeCurrency: {
        name: "Fuse",
        symbol: "FUSE",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.fuse.io"
            ]
        },
        public: {
            http: [
                "https://fuse-mainnet.chainstacklabs.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Fuse Explorer",
            url: "https://explorer.fuse.io"
        }
    }
};
// src/iotex.ts
var iotex = {
    id: 4689,
    name: "IoTeX",
    network: "iotex",
    nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://babel-api.mainnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.mainnet.iotex.io"
            ]
        },
        public: {
            http: [
                "https://babel-api.mainnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.mainnet.iotex.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "IoTeXScan",
            url: "https://iotexscan.io"
        }
    }
};
// src/iotexTestnet.ts
var iotexTestnet = {
    id: 4690,
    name: "IoTeX Testnet",
    network: "iotex-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://babel-api.testnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.testnet.iotex.io"
            ]
        },
        public: {
            http: [
                "https://babel-api.testnet.iotex.io"
            ],
            webSocket: [
                "wss://babel-api.testnet.iotex.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "IoTeXScan",
            url: "https://testnet.iotexscan.io"
        }
    }
};
// src/goerli.ts
var goerli = {
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: {
        name: "Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.ankr.com/eth_goerli"
            ]
        },
        public: {
            http: [
                "https://rpc.ankr.com/eth_goerli"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0x56522D00C410a43BFfDF00a9A569489297385790",
            blockCreated: 8765204
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
        }
    },
    testnet: true
};
// src/gnosis.ts
var gnosis = {
    id: 100,
    name: "Gnosis",
    network: "gnosis",
    nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.gnosischain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.gnosischain.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Gnosisscan",
            url: "https://gnosisscan.io/"
        },
        default: {
            name: "Gnosis Chain Explorer",
            url: "https://blockscout.com/xdai/mainnet/"
        }
    }
};
// src/gnosisChiado.ts
var gnosisChiado = {
    id: 10200,
    name: "Gnosis Chiado",
    network: "chiado",
    nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.chiadochain.net"
            ]
        },
        public: {
            http: [
                "https://rpc.chiadochain.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://blockscout.chiadochain.net"
        }
    }
};
// src/hardhat.ts
var hardhat = {
    id: 31337,
    name: "Hardhat",
    network: "hardhat",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ]
        }
    }
};
// src/harmonyOne.ts
var harmonyOne = {
    id: 16666e5,
    name: "Harmony One",
    network: "harmony",
    nativeCurrency: {
        name: "Harmony",
        symbol: "ONE",
        decimals: 18
    },
    rpcUrls: {
        public: {
            http: [
                "https://rpc.ankr.com/harmony"
            ]
        },
        default: {
            http: [
                "https://rpc.ankr.com/harmony"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Harmony Explorer",
            url: "https://explorer.harmony.one"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 24185753
        }
    }
};
// src/haqqMainnet.ts
var haqqMainnet = {
    id: 11235,
    name: "HAQQ Mainnet",
    network: "haqq-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLM"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.eth.haqq.network"
            ]
        },
        public: {
            http: [
                "https://rpc.eth.haqq.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "HAQQ Explorer",
            url: "https://explorer.haqq.network"
        }
    }
};
// src/haqqTestedge2.ts
var haqqTestedge2 = {
    id: 54211,
    name: "HAQQ Testedge 2",
    network: "haqq-testedge-2",
    nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLMT"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.eth.testedge2.haqq.network"
            ]
        },
        public: {
            http: [
                "https://rpc.eth.testedge2.haqq.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "HAQQ Explorer",
            url: "https://explorer.testedge2.haqq.network"
        }
    }
};
// src/klaytn.ts
var klaytn = {
    id: 8217,
    name: "Klaytn",
    network: "klaytn",
    nativeCurrency: {
        decimals: 18,
        name: "Klaytn",
        symbol: "KLAY"
    },
    rpcUrls: {
        default: {
            http: [
                "https://cypress.fautor.app/archive"
            ]
        },
        public: {
            http: [
                "https://cypress.fautor.app/archive"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "KlaytnScope",
            url: "https://scope.klaytn.com"
        },
        default: {
            name: "KlaytnScope",
            url: "https://scope.klaytn.com"
        }
    }
};
// src/lineaTestnet.ts
var lineaTestnet = {
    id: 59140,
    name: "Linea Goerli Testnet",
    network: "linea-testnet",
    nativeCurrency: {
        name: "Linea Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        infura: {
            http: [
                "https://consensys-zkevm-goerli-prealpha.infura.io/v3"
            ],
            webSocket: [
                "wss://consensys-zkevm-goerli-prealpha.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        },
        public: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "BlockScout",
            url: "https://explorer.goerli.linea.build"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 498623
        }
    },
    testnet: true
};
// src/localhost.ts
var localhost = {
    id: 1337,
    name: "Localhost",
    network: "localhost",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "http://127.0.0.1:8545"
            ]
        },
        public: {
            http: [
                "http://127.0.0.1:8545"
            ]
        }
    }
};
// src/mainnet.ts
var mainnet = {
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://cloudflare-eth.com"
            ]
        },
        public: {
            http: [
                "https://cloudflare-eth.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
            blockCreated: 16966585
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/metis.ts
var metis = {
    id: 1088,
    name: "Metis",
    network: "andromeda",
    nativeCurrency: {
        decimals: 18,
        name: "Metis",
        symbol: "METIS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://andromeda.metis.io/?owner=1088"
            ]
        },
        public: {
            http: [
                "https://andromeda.metis.io/?owner=1088"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Andromeda Explorer",
            url: "https://andromeda-explorer.metis.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 2338552
        }
    }
};
// src/metisGoerli.ts
var metisGoerli = {
    id: 599,
    name: "Metis Goerli",
    network: "metis-goerli",
    nativeCurrency: {
        decimals: 18,
        name: "Metis Goerli",
        symbol: "METIS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://goerli.gateway.metisdevops.link"
            ]
        },
        public: {
            http: [
                "https://goerli.gateway.metisdevops.link"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Metis Goerli Explorer",
            url: "https://goerli.explorer.metisdevops.link"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1006207
        }
    }
};
// src/moonbaseAlpha.ts
var moonbaseAlpha = {
    id: 1287,
    name: "Moonbase Alpha",
    network: "moonbase-alpha",
    nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.api.moonbase.moonbeam.network"
            ],
            webSocket: [
                "wss://wss.api.moonbase.moonbeam.network"
            ]
        },
        public: {
            http: [
                "https://rpc.api.moonbase.moonbeam.network"
            ],
            webSocket: [
                "wss://wss.api.moonbase.moonbeam.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonbase.moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonbase.moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1850686
        }
    },
    testnet: true
};
// src/moonbeam.ts
var moonbeam = {
    id: 1284,
    name: "Moonbeam",
    network: "moonbeam",
    nativeCurrency: {
        decimals: 18,
        name: "GLMR",
        symbol: "GLMR"
    },
    rpcUrls: {
        public: {
            http: [
                "https://moonbeam.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonbeam.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://moonbeam.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonbeam.public.blastapi.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 609002
        }
    },
    testnet: false
};
// src/moonriver.ts
var moonriver = {
    id: 1285,
    name: "Moonriver",
    network: "moonriver",
    nativeCurrency: {
        decimals: 18,
        name: "MOVR",
        symbol: "MOVR"
    },
    rpcUrls: {
        public: {
            http: [
                "https://moonriver.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonriver.public.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://moonriver.public.blastapi.io"
            ],
            webSocket: [
                "wss://moonriver.public.blastapi.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Moonscan",
            url: "https://moonriver.moonscan.io"
        },
        etherscan: {
            name: "Moonscan",
            url: "https://moonriver.moonscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 1597904
        }
    },
    testnet: false
};
// src/neonDevnet.ts
var neonDevnet = {
    id: 245022926,
    network: "neonDevnet",
    name: "Neon EVM DevNet",
    nativeCurrency: {
        name: "NEON",
        symbol: "NEON",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://devnet.neonevm.org"
            ]
        },
        public: {
            http: [
                "https://devnet.neonevm.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Neonscan",
            url: "https://neonscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 205206112
        }
    },
    testnet: true
};
// src/nexi.ts
var nexi = {
    id: 4242,
    name: "Nexi",
    network: "nexi",
    nativeCurrency: {
        name: "Nexi",
        symbol: "NEXI",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.chain.nexi.technology"
            ]
        },
        public: {
            http: [
                "https://rpc.chain.nexi.technology"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "NexiScan",
            url: "https://www.nexiscan.com"
        },
        default: {
            name: "NexiScan",
            url: "https://www.nexiscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
            blockCreated: 25770160
        }
    }
};
// src/oasys.ts
var oasys = {
    id: 248,
    name: "Oasys",
    network: "oasys",
    nativeCurrency: {
        name: "Oasys",
        symbol: "OAS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.mainnet.oasys.games"
            ]
        },
        public: {
            http: [
                "https://rpc.mainnet.oasys.games"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "OasysScan",
            url: "https://scan.oasys.games"
        }
    }
};
// src/okc.ts
var okc = {
    id: 66,
    name: "OKC",
    network: "okc",
    nativeCurrency: {
        decimals: 18,
        name: "OKT",
        symbol: "OKT"
    },
    rpcUrls: {
        default: {
            http: [
                "https://exchainrpc.okex.org"
            ]
        },
        public: {
            http: [
                "https://exchainrpc.okex.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "oklink",
            url: "https://www.oklink.com/okc"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 10364792
        }
    }
};
// src/optimism.ts
var optimism = {
    id: 10,
    name: "Optimism",
    network: "optimism",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://opt-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://opt-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://optimism-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://optimism-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://mainnet.optimism.io"
            ]
        },
        public: {
            http: [
                "https://mainnet.optimism.io"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://optimistic.etherscan.io"
        },
        default: {
            name: "Optimism Explorer",
            url: "https://explorer.optimism.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 4286263
        }
    }
};
// src/optimismGoerli.ts
var optimismGoerli = {
    id: 420,
    name: "Optimism Goerli",
    network: "optimism-goerli",
    nativeCurrency: {
        name: "Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://opt-goerli.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://opt-goerli.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://optimism-goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://optimism-goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://goerli.optimism.io"
            ]
        },
        public: {
            http: [
                "https://goerli.optimism.io"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://goerli-optimism.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://goerli-optimism.etherscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 49461
        }
    },
    testnet: true
};
// src/polygon.ts
var polygon = {
    id: 137,
    name: "Polygon",
    network: "matic",
    nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://polygon-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://polygon-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://polygon-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://polygon-rpc.com"
            ]
        },
        public: {
            http: [
                "https://polygon-rpc.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        },
        default: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 25770160
        }
    }
};
// src/polygonMumbai.ts
var polygonMumbai = {
    id: 80001,
    name: "Polygon Mumbai",
    network: "maticmum",
    nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://polygon-mumbai.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://polygon-mumbai.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://polygon-mumbai.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-mumbai.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://matic-mumbai.chainstacklabs.com"
            ]
        },
        public: {
            http: [
                "https://matic-mumbai.chainstacklabs.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "PolygonScan",
            url: "https://mumbai.polygonscan.com"
        },
        default: {
            name: "PolygonScan",
            url: "https://mumbai.polygonscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 25770160
        }
    },
    testnet: true
};
// src/polygonZkEvmTestnet.ts
var polygonZkEvmTestnet = {
    id: 1442,
    name: "Polygon zkEVM Testnet",
    network: "polygon-zkevm-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.public.zkevm-test.net"
            ]
        },
        public: {
            http: [
                "https://rpc.public.zkevm-test.net"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://explorer.public.zkevm-test.net"
        }
    },
    testnet: true
};
// src/polygonZkEvm.ts
var polygonZkEvm = {
    id: 1101,
    name: "Polygon zkEVM",
    network: "polygon-zkevm",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://zkevm-rpc.com"
            ]
        },
        public: {
            http: [
                "https://zkevm-rpc.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "PolygonScan",
            url: "https://zkevm.polygonscan.com"
        }
    }
};
// src/pulsechain.ts
var pulsechain = {
    id: 369,
    network: "pulsechain",
    name: "Pulsechain",
    nativeCurrency: {
        name: "Pulse",
        symbol: "PLS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.pulsechain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.pulsechain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Etherscan",
            url: "https://scan.pulsechain.com"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/pulsechainV4.ts
var pulsechainV4 = {
    id: 943,
    network: "pulsechainV4",
    name: "Pulsechain V4",
    testnet: true,
    nativeCurrency: {
        name: "Pulse",
        symbol: "PLS",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.v4.testnet.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.v4.testnet.pulsechain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.v4.testnet.pulsechain.com"
            ],
            webSocket: [
                "wss://ws.v4.testnet.pulsechain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://scan.v4.testnet.pulsechain.com"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
};
// src/scrollTestnet.ts
var scrollTestnet = {
    id: 534353,
    name: "Scroll Testnet",
    network: "scroll-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://alpha-rpc.scroll.io/l2"
            ],
            webSocket: [
                "wss://alpha-rpc.scroll.io/l2/ws"
            ]
        },
        public: {
            http: [
                "https://alpha-rpc.scroll.io/l2"
            ],
            webSocket: [
                "wss://alpha-rpc.scroll.io/l2/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://blockscout.scroll.io"
        }
    },
    testnet: true
};
// src/sepolia.ts
var sepolia = {
    id: 11155111,
    network: "sepolia",
    name: "Sepolia",
    nativeCurrency: {
        name: "Sepolia Ether",
        symbol: "SEP",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: [
                "https://eth-sepolia.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-sepolia.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://sepolia.infura.io/v3"
            ],
            webSocket: [
                "wss://sepolia.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.sepolia.org"
            ]
        },
        public: {
            http: [
                "https://rpc.sepolia.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
        }
    },
    testnet: true
};
// src/skale/brawl.ts
var skaleBlockBrawlers = {
    id: 391845894,
    name: "SKALE | Block Brawlers",
    network: "skale-brawl",
    nativeCurrency: {
        name: "BRAWL",
        symbol: "BRAWL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/frayed-decent-antares"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/frayed-decent-antares"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/calypso.ts
var skaleCalypso = {
    id: 1564830818,
    name: "SKALE | Calypso NFT Hub",
    network: "skale-calypso",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/calypsoTestnet.ts
var skaleCalypsoTestnet = {
    id: 344106930,
    name: "SKALE | Calypso NFT Hub Testnet",
    network: "skale-calypso-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/chaosTestnet.ts
var skaleChaosTestnet = {
    id: 1351057110,
    name: "SKALE | Chaos Testnet",
    network: "skale-chaos-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/cryptoBlades.ts
var skaleCryptoBlades = {
    id: 1026062157,
    name: "SKALE | CryptoBlades",
    network: "skale-cryptoblades",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/cryptoColosseum.ts
var skaleCryptoColosseum = {
    id: 2046399126,
    name: "SKALE | Crypto Colosseum",
    network: "skale-crypto-coloseeum",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/europa.ts
var skaleEuropa = {
    id: 2046399126,
    name: "SKALE | Europa Liquidity Hub",
    network: "skale-europa",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/elated-tan-skat"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/elated-tan-skat"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/europaTestnet.ts
var skaleEuropaTestnet = {
    id: 476158412,
    name: "SKALE | Europa Liquidity Hub Testnet",
    network: "skale-europa-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/exorde.ts
var skaleExorde = {
    id: 2139927552,
    name: "SKALE | Exorde",
    network: "skale-exorde",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/light-vast-diphda"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/light-vast-diphda"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/humanProtocol.ts
var skaleHumanProtocol = {
    id: 1273227453,
    name: "SKALE | Human Protocol",
    network: "skale-human-protocol",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/wan-red-ain"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/wan-red-ain"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/nebula.ts
var skaleNebula = {
    id: 1482601649,
    name: "SKALE | Nebula Gaming Hub",
    network: "skale-nebula",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/green-giddy-denebola"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/green-giddy-denebola"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/nebulaTestnet.ts
var skaleNebulaTestnet = {
    id: 503129905,
    name: "SKALE | Nebula Gaming Hub Testnet",
    network: "skale-nebula-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/skale/razor.ts
var skaleRazor = {
    id: 278611351,
    name: "SKALE | Razor Network",
    network: "skale-razor",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/titan.ts
var skaleTitan = {
    id: 1350216234,
    name: "SKALE | Titan Community Hub",
    network: "skale-titan",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.skalenodes.com/v1/parallel-stormy-spica"
            ]
        },
        public: {
            http: [
                "https://mainnet.skalenodes.com/v1/parallel-stormy-spica"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        }
    },
    contracts: {}
};
// src/skale/titanTestnet.ts
var skaleTitanTestnet = {
    id: 1517929550,
    name: "SKALE | Titan Community Hub Testnet",
    network: "skale-titan-testnet",
    nativeCurrency: {
        name: "sFUEL",
        symbol: "sFUEL",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
            ]
        },
        public: {
            http: [
                "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SKALE Explorer",
            url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        },
        default: {
            name: "SKALE Explorer",
            url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        }
    },
    contracts: {},
    testnet: true
};
// src/songbird.ts
var songbird = {
    id: 19,
    name: "Songbird Mainnet",
    network: "songbird-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "songbird",
        symbol: "SGB"
    },
    rpcUrls: {
        default: {
            http: [
                "https://songbird-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://songbird-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Songbird Explorer",
            url: "https://songbird-explorer.flare.network"
        }
    }
};
// src/songbirdTestnet.ts
var songbirdTestnet = {
    id: 16,
    name: "Coston",
    network: "coston",
    nativeCurrency: {
        decimals: 18,
        name: "costonflare",
        symbol: "CFLR"
    },
    rpcUrls: {
        default: {
            http: [
                "https://coston-api.flare.network/ext/C/rpc"
            ]
        },
        public: {
            http: [
                "https://coston-api.flare.network/ext/C/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Coston Explorer",
            url: "https://coston-explorer.flare.network"
        }
    },
    testnet: true
};
// src/shardeumSphinx.ts
var shardeumSphinx = {
    id: 8082,
    name: "Shardeum Sphinx",
    network: "shmSphinx",
    nativeCurrency: {
        name: "SHARDEUM",
        symbol: "SHM",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://sphinx.shardeum.org"
            ]
        },
        public: {
            http: [
                "https://sphinx.shardeum.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Shardeum Explorer",
            url: "https://explorer-sphinx.shardeum.org"
        }
    },
    testnet: true
};
// src/syscoin.ts
var syscoin = {
    id: 57,
    name: "Syscoin Mainnet",
    network: "syscoin",
    nativeCurrency: {
        decimals: 8,
        name: "Syscoin",
        symbol: "SYS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.syscoin.org"
            ]
        },
        public: {
            http: [
                "https://rpc.syscoin.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "SyscoinExplorer",
            url: "https://explorer.syscoin.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0x000562033783B1136159E10d976B519C929cdE8e",
            blockCreated: 80637
        }
    }
};
// src/taraxa.ts
var taraxa = {
    id: 841,
    name: "Taraxa Mainnet",
    network: "taraxa",
    nativeCurrency: {
        name: "Tara",
        symbol: "TARA",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.mainnet.taraxa.io"
            ]
        },
        public: {
            http: [
                "https://rpc.mainnet.taraxa.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Taraxa Explorer",
            url: "https://explorer.mainnet.taraxa.io"
        }
    }
};
// src/taraxaTestnet.ts
var taraxaTestnet = {
    id: 842,
    name: "Taraxa Testnet",
    network: "taraxa-testnet",
    nativeCurrency: {
        name: "Tara",
        symbol: "TARA",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.testnet.taraxa.io"
            ]
        },
        public: {
            http: [
                "https://rpc.testnet.taraxa.io"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Taraxa Explorer",
            url: "https://explorer.testnet.taraxa.io"
        }
    },
    testnet: true
};
// src/telos.ts
var telos = {
    id: 40,
    name: "Telos",
    network: "telos",
    nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.telos.net/evm"
            ]
        },
        public: {
            http: [
                "https://mainnet.telos.net/evm"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Teloscan",
            url: "https://www.teloscan.io/"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 246530709
        }
    }
};
// src/telosTestnet.ts
var telosTestnet = {
    id: 41,
    name: "Telos",
    network: "telosTestnet",
    nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.telos.net/evm"
            ]
        },
        public: {
            http: [
                "https://testnet.telos.net/evm"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Teloscan (testnet)",
            url: "https://testnet.teloscan.io/"
        }
    },
    testnet: true
};
// src/thunderTestnet.ts
var thunderTestnet = {
    id: 997,
    name: "5ireChain Thunder Testnet",
    network: "5ireChain",
    nativeCurrency: {
        name: "5ire Token",
        symbol: "5IRE",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc-testnet.5ire.network"
            ]
        },
        public: {
            http: [
                "https://rpc-testnet.5ire.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "5ireChain Explorer",
            url: "https://explorer.5ire.network"
        }
    },
    testnet: true
};
// src/wanchain.ts
var wanchain = {
    id: 888,
    name: "Wanchain",
    network: "wanchain",
    nativeCurrency: {
        name: "WANCHAIN",
        symbol: "WAN",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://gwan-ssl.wandevs.org:56891",
                "https://gwan2-ssl.wandevs.org"
            ]
        },
        public: {
            http: [
                "https://gwan-ssl.wandevs.org:56891",
                "https://gwan2-ssl.wandevs.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "WanScan",
            url: "https://wanscan.org"
        },
        default: {
            name: "WanScan",
            url: "https://wanscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
            blockCreated: 25312390
        }
    }
};
// src/wanchainTestnet.ts
var wanchainTestnet = {
    id: 999,
    name: "Wanchain Testnet",
    network: "wanchainTestnet",
    nativeCurrency: {
        name: "WANCHAIN",
        symbol: "WANt",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://gwan-ssl.wandevs.org:46891"
            ]
        },
        public: {
            http: [
                "https://gwan-ssl.wandevs.org:46891"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "WanScanTest",
            url: "https://wanscan.org"
        },
        default: {
            name: "WanScanTest",
            url: "https://wanscan.org"
        }
    },
    contracts: {
        multicall3: {
            address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
            blockCreated: 24743448
        }
    },
    testnet: true
};
// src/xdc.ts
var xdc = {
    id: 50,
    name: "XinFin Network",
    network: "xdc",
    nativeCurrency: {
        decimals: 18,
        name: "XDC",
        symbol: "XDC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.xinfin.network"
            ]
        },
        public: {
            http: [
                "https://rpc.xinfin.network"
            ]
        }
    },
    blockExplorers: {
        xinfin: {
            name: "XinFin",
            url: "https://explorer.xinfin.network"
        },
        default: {
            name: "Blocksscan",
            url: "https://xdc.blocksscan.io"
        }
    }
};
// src/xdcTestnet.ts
var xdcTestnet = {
    id: 51,
    name: "Apothem Network",
    network: "xdc-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "TXDC",
        symbol: "TXDC"
    },
    rpcUrls: {
        default: {
            http: [
                "https://erpc.apothem.network"
            ]
        },
        public: {
            http: [
                "https://erpc.apothem.network"
            ]
        }
    },
    blockExplorers: {
        xinfin: {
            name: "XinFin",
            url: "https://explorer.apothem.network"
        },
        default: {
            name: "Blocksscan",
            url: "https://apothem.blocksscan.io"
        }
    }
};
// src/zhejiang.ts
var zhejiang = {
    id: 1337803,
    network: "zhejiang",
    name: "Zhejiang",
    nativeCurrency: {
        name: "Zhejiang Ether",
        symbol: "ZhejETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.zhejiang.ethpandaops.io"
            ]
        },
        public: {
            http: [
                "https://rpc.zhejiang.ethpandaops.io"
            ]
        }
    },
    blockExplorers: {
        beaconchain: {
            name: "Etherscan",
            url: "https://zhejiang.beaconcha.in"
        },
        blockscout: {
            name: "Blockscout",
            url: "https://blockscout.com/eth/zhejiang-testnet"
        },
        default: {
            name: "Beaconchain",
            url: "https://zhejiang.beaconcha.in"
        }
    },
    testnet: true
};
// src/zkSync.ts
var zkSync = {
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://mainnet.era.zksync.io"
            ],
            webSocket: [
                "wss://mainnet.era.zksync.io/ws"
            ]
        },
        public: {
            http: [
                "https://mainnet.era.zksync.io"
            ],
            webSocket: [
                "wss://mainnet.era.zksync.io/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "zkExplorer",
            url: "https://explorer.zksync.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
    }
};
// src/zkSyncTestnet.ts
var zkSyncTestnet = {
    id: 280,
    name: "zkSync Era Testnet",
    network: "zksync-era-testnet",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.era.zksync.dev"
            ],
            webSocket: [
                "wss://testnet.era.zksync.dev/ws"
            ]
        },
        public: {
            http: [
                "https://testnet.era.zksync.dev"
            ],
            webSocket: [
                "wss://testnet.era.zksync.dev/ws"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "zkExplorer",
            url: "https://goerli.explorer.zksync.io"
        }
    },
    contracts: {
        multicall3: {
            address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
    },
    testnet: true
};
// src/zora.ts
var zora = {
    id: 7777777,
    name: "ZORA",
    network: "zora",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.zora.co"
            ],
            webSocket: [
                "wss://rpc.zora.co"
            ]
        },
        public: {
            http: [
                "https://rpc.zora.co"
            ],
            webSocket: [
                "wss://rpc.zora.co"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "ZORA",
            url: "https://explorer.zora.co"
        },
        default: {
            name: "ZORA",
            url: "https://explorer.zora.co"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 5882
        }
    }
};
// src/zoraTestnet.ts
var zoraTestnet = {
    id: 999,
    name: "ZORA Goerli Testnet",
    network: "zora-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "ZORA Goerli",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.rpc.zora.co"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.co"
            ]
        },
        public: {
            http: [
                "https://testnet.rpc.zora.co"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.co"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "ZORA",
            url: "https://testnet.explorer.zora.co"
        },
        default: {
            name: "ZORA",
            url: "https://testnet.explorer.zora.co"
        }
    },
    contracts: {
        multicall3: {
            address: "0xcA11bde05977b3631167028862bE2a173976CA11",
            blockCreated: 189123
        }
    },
    testnet: true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7G1WP":[function(require,module,exports) {
// src/connectors/injected.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InjectedConnector", ()=>(0, _injected.InjectedConnector));
var _injected = require("@wagmi/connectors/injected");

},{"@wagmi/connectors/injected":"54xJw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lY5Qi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WalletConnectConnector", ()=>(0, _walletConnect.WalletConnectConnector));
var _chunkMQXBDTVKJs = require("../chunk-MQXBDTVK.js");
// src/connectors/walletConnect.ts
var _walletConnect = require("@wagmi/connectors/walletConnect");

},{"../chunk-MQXBDTVK.js":"D4WL4","@wagmi/connectors/walletConnect":"6Ue5j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Ue5j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WalletConnectConnector", ()=>WalletConnectConnector);
var _chunkQYMCVNHTJs = require("./chunk-QYMCVNHT.js");
// src/walletConnect.ts
var _viem = require("viem");
var NAMESPACE = "eip155";
var STORE_KEY = "store";
var REQUESTED_CHAINS_KEY = "requestedChains";
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var _provider, _initProviderPromise, _createProvider, createProvider_fn, _initProvider, initProvider_fn, _isChainsStale, isChainsStale_fn, _setupListeners, setupListeners_fn, _removeListeners, removeListeners_fn, _setRequestedChainsIds, setRequestedChainsIds_fn, _getRequestedChainsIds, getRequestedChainsIds_fn, _getNamespaceChainsIds, getNamespaceChainsIds_fn, _getNamespaceMethods, getNamespaceMethods_fn;
var WalletConnectConnector = class extends (0, _chunkQYMCVNHTJs.Connector) {
    constructor(config){
        super({
            ...config,
            options: {
                isNewChainsStale: true,
                ...config.options
            }
        });
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _createProvider);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _initProvider);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _isChainsStale);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _setupListeners);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _removeListeners);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _setRequestedChainsIds);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _getRequestedChainsIds);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _getNamespaceChainsIds);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _getNamespaceMethods);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "id", "walletConnect");
        (0, _chunkQYMCVNHTJs.__publicField)(this, "name", "WalletConnect");
        (0, _chunkQYMCVNHTJs.__publicField)(this, "ready", true);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _provider, void 0);
        (0, _chunkQYMCVNHTJs.__privateAdd)(this, _initProviderPromise, void 0);
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onAccountsChanged", (accounts)=>{
            if (accounts.length === 0) this.emit("disconnect");
            else this.emit("change", {
                account: (0, _viem.getAddress)(accounts[0])
            });
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onChainChanged", (chainId)=>{
            const id = Number(chainId);
            const unsupported = this.isChainUnsupported(id);
            this.emit("change", {
                chain: {
                    id,
                    unsupported
                }
            });
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onDisconnect", ()=>{
            (0, _chunkQYMCVNHTJs.__privateMethod)(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
            this.emit("disconnect");
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onDisplayUri", (uri)=>{
            this.emit("message", {
                type: "display_uri",
                data: uri
            });
        });
        (0, _chunkQYMCVNHTJs.__publicField)(this, "onConnect", ()=>{
            this.emit("connect", {});
        });
        (0, _chunkQYMCVNHTJs.__privateMethod)(this, _createProvider, createProvider_fn).call(this);
    }
    async connect({ chainId, pairingTopic } = {}) {
        try {
            let targetChainId = chainId;
            if (!targetChainId) {
                const store = this.storage?.getItem(STORE_KEY);
                const lastUsedChainId = store?.state?.data?.chain?.id;
                if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;
                else targetChainId = this.chains[0]?.id;
            }
            if (!targetChainId) throw new Error("No chains found on connector.");
            const provider = await this.getProvider();
            (0, _chunkQYMCVNHTJs.__privateMethod)(this, _setupListeners, setupListeners_fn).call(this);
            const isChainsStale = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _isChainsStale, isChainsStale_fn).call(this);
            if (provider.session && isChainsStale) await provider.disconnect();
            if (!provider.session || isChainsStale) {
                const optionalChains = this.chains.filter((chain)=>chain.id !== targetChainId).map((optionalChain)=>optionalChain.id);
                this.emit("message", {
                    type: "connecting"
                });
                await provider.connect({
                    pairingTopic,
                    chains: [
                        targetChainId
                    ],
                    optionalChains
                });
                (0, _chunkQYMCVNHTJs.__privateMethod)(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({ id: id2 })=>id2));
            }
            const accounts = await provider.enable();
            const account = (0, _viem.getAddress)(accounts[0]);
            const id = await this.getChainId();
            const unsupported = this.isChainUnsupported(id);
            return {
                account,
                chain: {
                    id,
                    unsupported
                }
            };
        } catch (error) {
            if (/user rejected/i.test(error?.message)) throw new (0, _viem.UserRejectedRequestError)(error);
            throw error;
        }
    }
    async disconnect() {
        const provider = await this.getProvider();
        try {
            await provider.disconnect();
        } catch (error) {
            if (!/No matching key/i.test(error.message)) throw error;
        } finally{
            (0, _chunkQYMCVNHTJs.__privateMethod)(this, _removeListeners, removeListeners_fn).call(this);
            (0, _chunkQYMCVNHTJs.__privateMethod)(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
        }
    }
    async getAccount() {
        const { accounts } = await this.getProvider();
        return (0, _viem.getAddress)(accounts[0]);
    }
    async getChainId() {
        const { chainId } = await this.getProvider();
        return chainId;
    }
    async getProvider({ chainId } = {}) {
        if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _provider)) await (0, _chunkQYMCVNHTJs.__privateMethod)(this, _createProvider, createProvider_fn).call(this);
        if (chainId) await this.switchChain(chainId);
        return (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider);
    }
    async getWalletClient({ chainId } = {}) {
        const [provider, account] = await Promise.all([
            this.getProvider({
                chainId
            }),
            this.getAccount()
        ]);
        const chain = this.chains.find((x)=>x.id === chainId);
        if (!provider) throw new Error("provider is required.");
        return (0, _viem.createWalletClient)({
            account,
            chain,
            transport: (0, _viem.custom)(provider)
        });
    }
    async isAuthorized() {
        try {
            const [account, provider] = await Promise.all([
                this.getAccount(),
                this.getProvider()
            ]);
            const isChainsStale = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _isChainsStale, isChainsStale_fn).call(this);
            if (!account) return false;
            if (isChainsStale && provider.session) {
                try {
                    await provider.disconnect();
                } catch  {}
                return false;
            }
            return true;
        } catch  {
            return false;
        }
    }
    async switchChain(chainId) {
        const chain = this.chains.find((chain2)=>chain2.id === chainId);
        if (!chain) throw new (0, _viem.SwitchChainError)(new Error("chain not found on connector."));
        try {
            const provider = await this.getProvider();
            const namespaceChains = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
            const namespaceMethods = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
            const isChainApproved = namespaceChains.includes(chainId);
            if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
                await provider.request({
                    method: ADD_ETH_CHAIN_METHOD,
                    params: [
                        {
                            chainId: (0, _viem.numberToHex)(chain.id),
                            blockExplorerUrls: [
                                chain.blockExplorers?.default?.url
                            ],
                            chainName: chain.name,
                            nativeCurrency: chain.nativeCurrency,
                            rpcUrls: [
                                ...chain.rpcUrls.default.http
                            ]
                        }
                    ]
                });
                const requestedChains = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
                requestedChains.push(chainId);
                (0, _chunkQYMCVNHTJs.__privateMethod)(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);
            }
            await provider.request({
                method: "wallet_switchEthereumChain",
                params: [
                    {
                        chainId: (0, _viem.numberToHex)(chainId)
                    }
                ]
            });
            return chain;
        } catch (error) {
            const message = typeof error === "string" ? error : error?.message;
            if (/user rejected request/i.test(message)) throw new (0, _viem.UserRejectedRequestError)(error);
            throw new (0, _viem.SwitchChainError)(error);
        }
    }
};
_provider = new WeakMap();
_initProviderPromise = new WeakMap();
_createProvider = new WeakSet();
createProvider_fn = async function() {
    if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _initProviderPromise) && typeof window !== "undefined") (0, _chunkQYMCVNHTJs.__privateSet)(this, _initProviderPromise, (0, _chunkQYMCVNHTJs.__privateMethod)(this, _initProvider, initProvider_fn).call(this));
    return (0, _chunkQYMCVNHTJs.__privateGet)(this, _initProviderPromise);
};
_initProvider = new WeakSet();
initProvider_fn = async function() {
    const { default: EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await require("9a41ab595bb303bb");
    const [defaultChain, ...optionalChains] = this.chains.map(({ id })=>id);
    if (defaultChain) {
        const { projectId, showQrModal = true, qrModalOptions, metadata } = this.options;
        (0, _chunkQYMCVNHTJs.__privateSet)(this, _provider, await EthereumProvider.init({
            showQrModal,
            qrModalOptions,
            projectId,
            optionalMethods: OPTIONAL_METHODS,
            optionalEvents: OPTIONAL_EVENTS,
            chains: [
                defaultChain
            ],
            optionalChains,
            rpcMap: Object.fromEntries(this.chains.map((chain)=>[
                    chain.id,
                    chain.rpcUrls.default.http[0]
                ])),
            metadata
        }));
    }
};
_isChainsStale = new WeakSet();
isChainsStale_fn = function() {
    const namespaceMethods = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
    if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) return false;
    if (!this.options.isNewChainsStale) return false;
    const requestedChains = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
    const connectorChains = this.chains.map(({ id })=>id);
    const namespaceChains = (0, _chunkQYMCVNHTJs.__privateMethod)(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
    if (namespaceChains.length && !namespaceChains.some((id)=>connectorChains.includes(id))) return false;
    return !connectorChains.every((id)=>requestedChains.includes(id));
};
_setupListeners = new WeakSet();
setupListeners_fn = function() {
    if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _provider)) return;
    (0, _chunkQYMCVNHTJs.__privateMethod)(this, _removeListeners, removeListeners_fn).call(this);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("accountsChanged", this.onAccountsChanged);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("chainChanged", this.onChainChanged);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("disconnect", this.onDisconnect);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("session_delete", this.onDisconnect);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("display_uri", this.onDisplayUri);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).on("connect", this.onConnect);
};
_removeListeners = new WeakSet();
removeListeners_fn = function() {
    if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _provider)) return;
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("accountsChanged", this.onAccountsChanged);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("chainChanged", this.onChainChanged);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("disconnect", this.onDisconnect);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("session_delete", this.onDisconnect);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("display_uri", this.onDisplayUri);
    (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).removeListener("connect", this.onConnect);
};
_setRequestedChainsIds = new WeakSet();
setRequestedChainsIds_fn = function(chains) {
    this.storage?.setItem(REQUESTED_CHAINS_KEY, chains);
};
_getRequestedChainsIds = new WeakSet();
getRequestedChainsIds_fn = function() {
    return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? [];
};
_getNamespaceChainsIds = new WeakSet();
getNamespaceChainsIds_fn = function() {
    if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _provider)) return [];
    const chainIds = (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).session?.namespaces[NAMESPACE]?.chains?.map((chain)=>parseInt(chain.split(":")[1] || ""));
    return chainIds ?? [];
};
_getNamespaceMethods = new WeakSet();
getNamespaceMethods_fn = function() {
    if (!(0, _chunkQYMCVNHTJs.__privateGet)(this, _provider)) return [];
    const methods = (0, _chunkQYMCVNHTJs.__privateGet)(this, _provider).session?.namespaces[NAMESPACE]?.methods;
    return methods ?? [];
};

},{"./chunk-QYMCVNHT.js":"h5K6b","viem":"eKtik","9a41ab595bb303bb":"1r7gp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1r7gp":[function(require,module,exports) {
module.exports = require("7879f3d484fbf30")(require("e704b7fecf754dae").getBundleURL("UckoE") + "index.es.d679753d.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("6MFRU"));

},{"7879f3d484fbf30":"61B45","e704b7fecf754dae":"lgJ39"}],"kEHWO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonRpcProvider", ()=>jsonRpcProvider);
var _chunkMQXBDTVKJs = require("../chunk-MQXBDTVK.js");
// src/providers/jsonRpc.ts
function jsonRpcProvider({ rpc }) {
    return function(chain) {
        const rpcConfig = rpc(chain);
        if (!rpcConfig || rpcConfig.http === "") return null;
        return {
            chain: {
                ...chain,
                rpcUrls: {
                    ...chain.rpcUrls,
                    default: {
                        http: [
                            rpcConfig.http
                        ]
                    }
                }
            },
            rpcUrls: {
                http: [
                    rpcConfig.http
                ],
                webSocket: rpcConfig.webSocket ? [
                    rpcConfig.webSocket
                ] : void 0
            }
        };
    };
}

},{"../chunk-MQXBDTVK.js":"D4WL4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Skid":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Web3Modal", ()=>c);
var _core = require("@web3modal/core");
class c {
    constructor(e, o){
        this.openModal = (0, _core.ModalCtrl).open, this.closeModal = (0, _core.ModalCtrl).close, this.subscribeModal = (0, _core.ModalCtrl).subscribe, this.setTheme = (0, _core.ThemeCtrl).setThemeConfig, this.setDefaultChain = (0, _core.OptionsCtrl).setSelectedChain, this.subscribeEvents = (0, _core.EventsCtrl).subscribe, (0, _core.ThemeCtrl).setThemeConfig(e), (0, _core.ClientCtrl).setEthereumClient(o), (0, _core.ConfigCtrl).setConfig(e), this.initUi();
    }
    async initUi() {
        if (typeof window < "u") {
            await require("fd357b106249294e");
            const e = document.createElement("w3m-modal");
            document.body.insertAdjacentElement("beforeend", e), (0, _core.OptionsCtrl).setIsUiLoaded(!0);
        }
    }
}

},{"@web3modal/core":"7c76x","fd357b106249294e":"2MWYC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7c76x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountCtrl", ()=>H);
parcelHelpers.export(exports, "ClientCtrl", ()=>m);
parcelHelpers.export(exports, "ConfigCtrl", ()=>I);
parcelHelpers.export(exports, "CoreUtil", ()=>r);
parcelHelpers.export(exports, "EventsCtrl", ()=>V);
parcelHelpers.export(exports, "ExplorerCtrl", ()=>te);
parcelHelpers.export(exports, "ModalCtrl", ()=>ne);
parcelHelpers.export(exports, "OptionsCtrl", ()=>v);
parcelHelpers.export(exports, "RouterCtrl", ()=>L);
parcelHelpers.export(exports, "ThemeCtrl", ()=>se);
parcelHelpers.export(exports, "ToastCtrl", ()=>oe);
parcelHelpers.export(exports, "WcConnectionCtrl", ()=>k);
var _vanilla = require("valtio/vanilla");
var _buffer = require("buffer");
let D;
const m = {
    ethereumClient: void 0,
    setEthereumClient (e) {
        D = e;
    },
    client () {
        if (D) return D;
        throw new Error("ClientCtrl has no client set");
    }
}, i = (0, _vanilla.proxy)({
    history: [
        "ConnectWallet"
    ],
    view: "ConnectWallet",
    data: void 0
}), L = {
    state: i,
    subscribe (e) {
        return (0, _vanilla.subscribe)(i, ()=>e(i));
    },
    push (e, t) {
        e !== i.view && (i.view = e, t && (i.data = t), i.history.push(e));
    },
    reset (e) {
        i.view = e, i.history = [
            e
        ];
    },
    replace (e) {
        i.history.length > 1 && (i.history[i.history.length - 1] = e, i.view = e);
    },
    goBack () {
        if (i.history.length > 1) {
            i.history.pop();
            const [e] = i.history.slice(-1);
            i.view = e;
        }
    },
    setData (e) {
        i.data = e;
    }
}, r = {
    WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    W3M_VERSION: "W3M_VERSION",
    W3M_PREFER_INJECTED_URL_FLAG: "w3mPreferInjected",
    RECOMMENDED_WALLET_AMOUNT: 9,
    isMobile () {
        return typeof window < "u" ? Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
    },
    isAndroid () {
        return r.isMobile() && navigator.userAgent.toLowerCase().includes("android");
    },
    isIos () {
        const e = navigator.userAgent.toLowerCase();
        return r.isMobile() && (e.includes("iphone") || e.includes("ipad"));
    },
    isHttpUrl (e) {
        return e.startsWith("http://") || e.startsWith("https://");
    },
    isArray (e) {
        return Array.isArray(e) && e.length > 0;
    },
    formatNativeUrl (e, t, n) {
        if (r.isHttpUrl(e)) return this.formatUniversalUrl(e, t, n);
        let s = e;
        s.includes("://") || (s = e.replaceAll("/", "").replaceAll(":", ""), s = `${s}://`), s.endsWith("/") || (s = `${s}/`), this.setWalletConnectDeepLink(s, n);
        const a = encodeURIComponent(t);
        return `${s}wc?uri=${a}`;
    },
    formatUniversalUrl (e, t, n) {
        if (!r.isHttpUrl(e)) return this.formatNativeUrl(e, t, n);
        let s = e;
        s.endsWith("/") || (s = `${s}/`), this.setWalletConnectDeepLink(s, n);
        const a = encodeURIComponent(t);
        return `${s}wc?uri=${a}`;
    },
    async wait (e) {
        return new Promise((t)=>{
            setTimeout(t, e);
        });
    },
    openHref (e, t) {
        window.open(e, t, "noreferrer noopener");
    },
    setWalletConnectDeepLink (e, t) {
        try {
            localStorage.setItem(r.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: e,
                name: t
            }));
        } catch  {
            console.info("Unable to set WalletConnect deep link");
        }
    },
    setWalletConnectAndroidDeepLink (e) {
        try {
            const [t] = e.split("?");
            localStorage.setItem(r.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: t,
                name: "Android"
            }));
        } catch  {
            console.info("Unable to set WalletConnect android deep link");
        }
    },
    removeWalletConnectDeepLink () {
        try {
            localStorage.removeItem(r.WALLETCONNECT_DEEPLINK_CHOICE);
        } catch  {
            console.info("Unable to remove WalletConnect deep link");
        }
    },
    setWeb3ModalVersionInStorage () {
        try {
            typeof localStorage < "u" && localStorage.setItem(r.W3M_VERSION, "2.6.2");
        } catch  {
            console.info("Unable to set Web3Modal version in storage");
        }
    },
    getWalletRouterData () {
        var e;
        const t = (e = L.state.data) == null ? void 0 : e.Wallet;
        if (!t) throw new Error('Missing "Wallet" view data');
        return t;
    },
    getSwitchNetworkRouterData () {
        var e;
        const t = (e = L.state.data) == null ? void 0 : e.SwitchNetwork;
        if (!t) throw new Error('Missing "SwitchNetwork" view data');
        return t;
    },
    isPreferInjectedFlag () {
        return typeof location < "u" ? new URLSearchParams(location.search).has(r.W3M_PREFER_INJECTED_URL_FLAG) : !1;
    }
}, B = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), c = (0, _vanilla.proxy)({
    enabled: B,
    userSessionId: "",
    events: [],
    connectedWalletId: void 0
}), V = {
    state: c,
    subscribe (e) {
        return (0, _vanilla.subscribe)(c.events, ()=>e((0, _vanilla.snapshot)(c.events[c.events.length - 1])));
    },
    initialize () {
        c.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (c.userSessionId = crypto.randomUUID());
    },
    setConnectedWalletId (e) {
        c.connectedWalletId = e;
    },
    click (e) {
        if (c.enabled) {
            const t = {
                type: "CLICK",
                name: e.name,
                userSessionId: c.userSessionId,
                timestamp: Date.now(),
                data: e
            };
            c.events.push(t);
        }
    },
    track (e) {
        if (c.enabled) {
            const t = {
                type: "TRACK",
                name: e.name,
                userSessionId: c.userSessionId,
                timestamp: Date.now(),
                data: e
            };
            c.events.push(t);
        }
    },
    view (e) {
        if (c.enabled) {
            const t = {
                type: "VIEW",
                name: e.name,
                userSessionId: c.userSessionId,
                timestamp: Date.now(),
                data: e
            };
            c.events.push(t);
        }
    }
}, d = (0, _vanilla.proxy)({
    selectedChain: void 0,
    chains: void 0,
    isCustomDesktop: !1,
    isCustomMobile: !1,
    isDataLoaded: !1,
    isUiLoaded: !1,
    isPreferInjected: !1
}), v = {
    state: d,
    subscribe (e) {
        return (0, _vanilla.subscribe)(d, ()=>e(d));
    },
    setChains (e) {
        d.chains = e;
    },
    getSelectedChain () {
        const e = m.client().getNetwork().chain;
        return e && (d.selectedChain = e), d.selectedChain;
    },
    setSelectedChain (e) {
        d.selectedChain = e;
    },
    setIsCustomDesktop (e) {
        d.isCustomDesktop = e;
    },
    setIsCustomMobile (e) {
        d.isCustomMobile = e;
    },
    setIsDataLoaded (e) {
        d.isDataLoaded = e;
    },
    setIsUiLoaded (e) {
        d.isUiLoaded = e;
    },
    setIsPreferInjected (e) {
        d.isPreferInjected = e;
    }
}, j = (0, _vanilla.proxy)({
    projectId: "",
    mobileWallets: void 0,
    desktopWallets: void 0,
    walletImages: void 0,
    chainImages: void 0,
    tokenImages: void 0,
    tokenContracts: void 0,
    enableNetworkView: !1,
    enableAccountView: !0,
    enableExplorer: !0,
    defaultChain: void 0,
    explorerExcludedWalletIds: void 0,
    explorerRecommendedWalletIds: void 0,
    termsOfServiceUrl: void 0,
    privacyPolicyUrl: void 0
}), I = {
    state: j,
    subscribe (e) {
        return (0, _vanilla.subscribe)(j, ()=>e(j));
    },
    setConfig (e) {
        var t, n;
        V.initialize(), v.setIsCustomMobile(Boolean((t = e.mobileWallets) == null ? void 0 : t.length)), v.setIsCustomDesktop(Boolean((n = e.desktopWallets) == null ? void 0 : n.length)), v.setChains(m.client().chains), v.setIsPreferInjected(m.client().isInjectedProviderInstalled() && r.isPreferInjectedFlag()), e.defaultChain && v.setSelectedChain(e.defaultChain), r.setWeb3ModalVersionInStorage(), Object.assign(j, e);
    }
}, o = (0, _vanilla.proxy)({
    address: void 0,
    profileName: void 0,
    profileAvatar: void 0,
    profileLoading: !1,
    balanceLoading: !1,
    balance: void 0,
    isConnected: !1
}), H = {
    state: o,
    subscribe (e) {
        return (0, _vanilla.subscribe)(o, ()=>e(o));
    },
    getAccount () {
        const e = m.client().getAccount();
        o.address = e.address, o.isConnected = e.isConnected;
    },
    async fetchProfile (e, t) {
        var n;
        try {
            o.profileLoading = !0;
            const s = t ?? o.address, a = (n = v.state.chains) == null ? void 0 : n.find((l)=>l.id === 1);
            if (s && a) {
                const l = await m.client().fetchEnsName({
                    address: s,
                    chainId: 1
                });
                if (l) {
                    const p = await m.client().fetchEnsAvatar({
                        name: l,
                        chainId: 1
                    });
                    p && await e(p), o.profileAvatar = p;
                }
                o.profileName = l;
            }
        } finally{
            o.profileLoading = !1;
        }
    },
    async fetchBalance (e) {
        try {
            const { chain: t } = m.client().getNetwork(), { tokenContracts: n } = I.state;
            let s;
            t && n && (s = n[t.id]), o.balanceLoading = !0;
            const a = e ?? o.address;
            if (a) {
                const l = await m.client().fetchBalance({
                    address: a,
                    token: s
                });
                o.balance = {
                    amount: l.formatted,
                    symbol: l.symbol
                };
            }
        } finally{
            o.balanceLoading = !1;
        }
    },
    setAddress (e) {
        o.address = e;
    },
    setIsConnected (e) {
        o.isConnected = e;
    },
    resetBalance () {
        o.balance = void 0;
    },
    resetAccount () {
        o.address = void 0, o.isConnected = !1, o.profileName = void 0, o.profileAvatar = void 0, o.balance = void 0;
    }
}, M = "https://explorer-api.walletconnect.com";
async function O(e, t) {
    const n = new URL(e, M);
    return n.searchParams.append("projectId", I.state.projectId), Object.entries(t).forEach(([s, a])=>{
        a && n.searchParams.append(s, String(a));
    }), (await fetch(n)).json();
}
const h = {
    async getDesktopListings (e) {
        return O("/w3m/v1/getDesktopListings", e);
    },
    async getMobileListings (e) {
        return O("/w3m/v1/getMobileListings", e);
    },
    async getInjectedListings (e) {
        return O("/w3m/v1/getInjectedListings", e);
    },
    async getAllListings (e) {
        return O("/w3m/v1/getAllListings", e);
    },
    getWalletImageUrl (e) {
        return `${M}/w3m/v1/getWalletImage/${e}?projectId=${I.state.projectId}`;
    },
    getAssetImageUrl (e) {
        return `${M}/w3m/v1/getAssetImage/${e}?projectId=${I.state.projectId}`;
    }
};
var K = Object.defineProperty, P = Object.getOwnPropertySymbols, F = Object.prototype.hasOwnProperty, J = Object.prototype.propertyIsEnumerable, S = (e, t, n)=>t in e ? K(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n, z = (e, t)=>{
    for(var n in t || (t = {}))F.call(t, n) && S(e, n, t[n]);
    if (P) for (var n of P(t))J.call(t, n) && S(e, n, t[n]);
    return e;
};
const _ = r.isMobile(), u = (0, _vanilla.proxy)({
    wallets: {
        listings: [],
        total: 0,
        page: 1
    },
    injectedWallets: [],
    search: {
        listings: [],
        total: 0,
        page: 1
    },
    recomendedWallets: []
}), te = {
    state: u,
    async getRecomendedWallets () {
        const { explorerRecommendedWalletIds: e, explorerExcludedWalletIds: t } = I.state;
        if (e === "NONE" || t === "ALL" && !e) return u.recomendedWallets;
        if (r.isArray(e)) {
            const n = {
                recommendedIds: e.join(",")
            }, { listings: s } = await h.getAllListings(n), a = Object.values(s);
            a.sort((l, p)=>{
                const W = e.indexOf(l.id), C = e.indexOf(p.id);
                return W - C;
            }), u.recomendedWallets = a;
        } else {
            const n = r.isArray(t), s = {
                page: 1,
                entries: r.RECOMMENDED_WALLET_AMOUNT,
                version: 2,
                excludedIds: n ? t.join(",") : void 0
            }, { listings: a } = _ ? await h.getMobileListings(s) : await h.getDesktopListings(s);
            u.recomendedWallets = Object.values(a);
        }
        return u.recomendedWallets;
    },
    async getWallets (e) {
        const t = z({}, e), { explorerRecommendedWalletIds: n, explorerExcludedWalletIds: s } = I.state, { recomendedWallets: a } = u;
        if (s === "ALL") return u.wallets;
        a.length ? t.excludedIds = a.map((N)=>N.id).join(",") : r.isArray(n) && (t.excludedIds = n.join(",")), r.isArray(s) && (t.excludedIds = [
            t.excludedIds,
            s
        ].filter(Boolean).join(","));
        const { page: l, search: p } = e, { listings: W, total: C } = _ ? await h.getMobileListings(t) : await h.getDesktopListings(t), b = Object.values(W), A = p ? "search" : "wallets";
        return u[A] = {
            listings: [
                ...u[A].listings,
                ...b
            ],
            total: C,
            page: l ?? 1
        }, {
            listings: b,
            total: C
        };
    },
    async getInjectedWallets () {
        const { listings: e } = await h.getInjectedListings({}), t = Object.values(e);
        return u.injectedWallets = t, u.injectedWallets;
    },
    getWalletImageUrl (e) {
        return h.getWalletImageUrl(e);
    },
    getAssetImageUrl (e) {
        return h.getAssetImageUrl(e);
    },
    resetSearch () {
        u.search = {
            listings: [],
            total: 0,
            page: 1
        };
    }
}, y = (0, _vanilla.proxy)({
    pairingEnabled: !1,
    pairingUri: "",
    pairingError: !1
}), k = {
    state: y,
    subscribe (e) {
        return (0, _vanilla.subscribe)(y, ()=>e(y));
    },
    setPairingUri (e) {
        y.pairingUri = e;
    },
    setPairingError (e) {
        y.pairingError = e;
    },
    setPairingEnabled (e) {
        y.pairingEnabled = e;
    }
}, E = (0, _vanilla.proxy)({
    open: !1
}), ne = {
    state: E,
    subscribe (e) {
        return (0, _vanilla.subscribe)(E, ()=>e(E));
    },
    async open (e) {
        return new Promise((t)=>{
            const { isUiLoaded: n, isDataLoaded: s, isPreferInjected: a, selectedChain: l } = v.state, { isConnected: p } = H.state, { enableNetworkView: W } = I.state;
            if (k.setPairingEnabled(!0), e != null && e.route) L.reset(e.route);
            else if (p) L.reset("Account");
            else if (W) L.reset("SelectNetwork");
            else if (a) {
                m.client().connectConnector("injected", l?.id).catch((b)=>console.error(b)), t();
                return;
            } else L.reset("ConnectWallet");
            const { pairingUri: C } = k.state;
            if (n && s && (C || p)) E.open = !0, t();
            else {
                const b = setInterval(()=>{
                    const A = v.state, N = k.state;
                    A.isUiLoaded && A.isDataLoaded && (N.pairingUri || p) && (clearInterval(b), E.open = !0, t());
                }, 200);
            }
        });
    },
    close () {
        E.open = !1;
    }
};
var G = Object.defineProperty, x = Object.getOwnPropertySymbols, q = Object.prototype.hasOwnProperty, Q = Object.prototype.propertyIsEnumerable, R = (e, t, n)=>t in e ? G(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n, X = (e, t)=>{
    for(var n in t || (t = {}))q.call(t, n) && R(e, n, t[n]);
    if (x) for (var n of x(t))Q.call(t, n) && R(e, n, t[n]);
    return e;
};
function Y() {
    return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const U = (0, _vanilla.proxy)({
    themeMode: Y() ? "dark" : "light"
}), se = {
    state: U,
    subscribe (e) {
        return (0, _vanilla.subscribe)(U, ()=>e(U));
    },
    setThemeConfig (e) {
        const { themeMode: t, themeVariables: n } = e;
        t && (U.themeMode = t), n && (U.themeVariables = X({}, n));
    }
}, w = (0, _vanilla.proxy)({
    open: !1,
    message: "",
    variant: "success"
}), oe = {
    state: w,
    subscribe (e) {
        return (0, _vanilla.subscribe)(w, ()=>e(w));
    },
    openToast (e, t) {
        w.open = !0, w.message = e, w.variant = t;
    },
    closeToast () {
        w.open = !1;
    }
};
typeof window < "u" && (window.Buffer || (window.Buffer = (0, _buffer.Buffer)), window.global || (window.global = window), window.process || (window.process = {
    env: {}
}), window.global || (window.global = window));

},{"valtio/vanilla":"gyoEY","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gyoEY":[function(require,module,exports) {
"use strict";
var proxyCompare = require("d4fb8480fa3c5685");
var isObject = function isObject(x) {
    return typeof x === "object" && x !== null;
};
var proxyStateMap = new WeakMap();
var refSet = new WeakSet();
var buildProxyFunction = function buildProxyFunction(objectIs, newProxy, canProxy, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder, _proxyFunction) {
    if (objectIs === void 0) objectIs = Object.is;
    if (newProxy === void 0) newProxy = function newProxy(target, handler) {
        return new Proxy(target, handler);
    };
    if (canProxy === void 0) canProxy = function canProxy(x) {
        return isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
    };
    if (defaultHandlePromise === void 0) defaultHandlePromise = function defaultHandlePromise(promise) {
        switch(promise.status){
            case "fulfilled":
                return promise.value;
            case "rejected":
                throw promise.reason;
            default:
                throw promise;
        }
    };
    if (snapCache === void 0) snapCache = new WeakMap();
    if (createSnapshot === void 0) createSnapshot = function(_createSnapshot) {
        function createSnapshot(_x, _x2, _x3) {
            return _createSnapshot.apply(this, arguments);
        }
        createSnapshot.toString = function() {
            return _createSnapshot.toString();
        };
        return createSnapshot;
    }(function(target, version, handlePromise) {
        if (handlePromise === void 0) handlePromise = defaultHandlePromise;
        var cache = snapCache.get(target);
        if ((cache == null ? void 0 : cache[0]) === version) return cache[1];
        var snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
        proxyCompare.markToTrack(snap, true);
        snapCache.set(target, [
            version,
            snap
        ]);
        Reflect.ownKeys(target).forEach(function(key) {
            if (Object.getOwnPropertyDescriptor(snap, key)) return;
            var value = Reflect.get(target, key);
            var desc = {
                value: value,
                enumerable: true,
                configurable: true
            };
            if (refSet.has(value)) proxyCompare.markToTrack(value, false);
            else if (value instanceof Promise) {
                delete desc.value;
                desc.get = function() {
                    return handlePromise(value);
                };
            } else if (proxyStateMap.has(value)) {
                var _ref = proxyStateMap.get(value), _target = _ref[0], _ensureVersion = _ref[1];
                desc.value = createSnapshot(_target, _ensureVersion(), handlePromise);
            }
            Object.defineProperty(snap, key, desc);
        });
        return snap;
    });
    if (proxyCache === void 0) proxyCache = new WeakMap();
    if (versionHolder === void 0) versionHolder = [
        1,
        1
    ];
    if (_proxyFunction === void 0) _proxyFunction = function proxyFunction(initialObject) {
        if (!isObject(initialObject)) throw new Error("object required");
        var found = proxyCache.get(initialObject);
        if (found) return found;
        var version = versionHolder[0];
        var listeners = new Set();
        var notifyUpdate = function notifyUpdate(op, nextVersion) {
            if (nextVersion === void 0) nextVersion = ++versionHolder[0];
            if (version !== nextVersion) {
                version = nextVersion;
                listeners.forEach(function(listener) {
                    return listener(op, nextVersion);
                });
            }
        };
        var checkVersion = versionHolder[1];
        var ensureVersion = function ensureVersion(nextCheckVersion) {
            if (nextCheckVersion === void 0) nextCheckVersion = ++versionHolder[1];
            if (checkVersion !== nextCheckVersion && !listeners.size) {
                checkVersion = nextCheckVersion;
                propProxyStates.forEach(function(_ref2) {
                    var propProxyState = _ref2[0];
                    var propVersion = propProxyState[1](nextCheckVersion);
                    if (propVersion > version) version = propVersion;
                });
            }
            return version;
        };
        var createPropListener = function createPropListener(prop) {
            return function(op, nextVersion) {
                var newOp = [].concat(op);
                newOp[1] = [
                    prop
                ].concat(newOp[1]);
                notifyUpdate(newOp, nextVersion);
            };
        };
        var propProxyStates = new Map();
        var addPropListener = function addPropListener(prop, propProxyState) {
            if (propProxyStates.has(prop)) throw new Error("prop listener already exists");
            if (listeners.size) {
                var remove = propProxyState[3](createPropListener(prop));
                propProxyStates.set(prop, [
                    propProxyState,
                    remove
                ]);
            } else propProxyStates.set(prop, [
                propProxyState
            ]);
        };
        var removePropListener = function removePropListener(prop) {
            var entry = propProxyStates.get(prop);
            if (entry) {
                var _entry$;
                propProxyStates.delete(prop);
                (_entry$ = entry[1]) == null || _entry$.call(entry);
            }
        };
        var addListener = function addListener(listener) {
            listeners.add(listener);
            if (listeners.size === 1) propProxyStates.forEach(function(_ref3, prop) {
                var propProxyState = _ref3[0], prevRemove = _ref3[1];
                if (prevRemove) throw new Error("remove already exists");
                var remove = propProxyState[3](createPropListener(prop));
                propProxyStates.set(prop, [
                    propProxyState,
                    remove
                ]);
            });
            var removeListener = function removeListener() {
                listeners.delete(listener);
                if (listeners.size === 0) propProxyStates.forEach(function(_ref4, prop) {
                    var propProxyState = _ref4[0], remove = _ref4[1];
                    if (remove) {
                        remove();
                        propProxyStates.set(prop, [
                            propProxyState
                        ]);
                    }
                });
            };
            return removeListener;
        };
        var baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
        var handler = {
            deleteProperty: function deleteProperty(target, prop) {
                var prevValue = Reflect.get(target, prop);
                removePropListener(prop);
                var deleted = Reflect.deleteProperty(target, prop);
                if (deleted) notifyUpdate([
                    "delete",
                    [
                        prop
                    ],
                    prevValue
                ]);
                return deleted;
            },
            set: function set(target, prop, value, receiver) {
                var hasPrevValue = Reflect.has(target, prop);
                var prevValue = Reflect.get(target, prop, receiver);
                if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) return true;
                removePropListener(prop);
                if (isObject(value)) value = proxyCompare.getUntracked(value) || value;
                var nextValue = value;
                if (value instanceof Promise) value.then(function(v) {
                    value.status = "fulfilled";
                    value.value = v;
                    notifyUpdate([
                        "resolve",
                        [
                            prop
                        ],
                        v
                    ]);
                }).catch(function(e) {
                    value.status = "rejected";
                    value.reason = e;
                    notifyUpdate([
                        "reject",
                        [
                            prop
                        ],
                        e
                    ]);
                });
                else {
                    if (!proxyStateMap.has(value) && canProxy(value)) nextValue = _proxyFunction(value);
                    var childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
                    if (childProxyState) addPropListener(prop, childProxyState);
                }
                Reflect.set(target, prop, nextValue, receiver);
                notifyUpdate([
                    "set",
                    [
                        prop
                    ],
                    value,
                    prevValue
                ]);
                return true;
            }
        };
        var proxyObject = newProxy(baseObject, handler);
        proxyCache.set(initialObject, proxyObject);
        var proxyState = [
            baseObject,
            ensureVersion,
            createSnapshot,
            addListener
        ];
        proxyStateMap.set(proxyObject, proxyState);
        Reflect.ownKeys(initialObject).forEach(function(key) {
            var desc = Object.getOwnPropertyDescriptor(initialObject, key);
            if ("value" in desc) {
                proxyObject[key] = initialObject[key];
                delete desc.value;
                delete desc.writable;
            }
            Object.defineProperty(baseObject, key, desc);
        });
        return proxyObject;
    };
    return [
        _proxyFunction,
        proxyStateMap,
        refSet,
        objectIs,
        newProxy,
        canProxy,
        defaultHandlePromise,
        snapCache,
        createSnapshot,
        proxyCache,
        versionHolder
    ];
};
var _buildProxyFunction = buildProxyFunction(), defaultProxyFunction = _buildProxyFunction[0];
function proxy(initialObject) {
    if (initialObject === void 0) initialObject = {};
    return defaultProxyFunction(initialObject);
}
function getVersion(proxyObject) {
    var proxyState = proxyStateMap.get(proxyObject);
    return proxyState == null ? void 0 : proxyState[1]();
}
function subscribe(proxyObject, callback, notifyInSync) {
    var proxyState = proxyStateMap.get(proxyObject);
    if (!proxyState) console.warn("Please use proxy object");
    var promise;
    var ops = [];
    var addListener = proxyState[3];
    var isListenerActive = false;
    var listener = function listener(op) {
        ops.push(op);
        if (notifyInSync) {
            callback(ops.splice(0));
            return;
        }
        if (!promise) promise = Promise.resolve().then(function() {
            promise = undefined;
            if (isListenerActive) callback(ops.splice(0));
        });
    };
    var removeListener = addListener(listener);
    isListenerActive = true;
    return function() {
        isListenerActive = false;
        removeListener();
    };
}
function snapshot(proxyObject, handlePromise) {
    var proxyState = proxyStateMap.get(proxyObject);
    if (!proxyState) console.warn("Please use proxy object");
    var _ref5 = proxyState, target = _ref5[0], ensureVersion = _ref5[1], createSnapshot = _ref5[2];
    return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
    refSet.add(obj);
    return obj;
}
var unstable_buildProxyFunction = buildProxyFunction;
exports.getVersion = getVersion;
exports.proxy = proxy;
exports.ref = ref;
exports.snapshot = snapshot;
exports.subscribe = subscribe;
exports.unstable_buildProxyFunction = unstable_buildProxyFunction;

},{"d4fb8480fa3c5685":"d0ziJ"}],"d0ziJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "affectedToPathList", ()=>w);
parcelHelpers.export(exports, "createProxy", ()=>a);
parcelHelpers.export(exports, "getUntracked", ()=>y);
parcelHelpers.export(exports, "isChanged", ()=>p);
parcelHelpers.export(exports, "markToTrack", ()=>h);
parcelHelpers.export(exports, "replaceNewProxy", ()=>O);
parcelHelpers.export(exports, "trackMemo", ()=>g);
const e = Symbol(), t = Symbol(), r = "a", n = "w";
let o = (e, t)=>new Proxy(e, t);
const s = Object.getPrototypeOf, c = new WeakMap, l = (e)=>e && (c.has(e) ? c.get(e) : s(e) === Object.prototype || s(e) === Array.prototype), f = (e)=>"object" == typeof e && null !== e, i = (e)=>{
    if (Array.isArray(e)) return Array.from(e);
    const t = Object.getOwnPropertyDescriptors(e);
    return Object.values(t).forEach((e)=>{
        e.configurable = !0;
    }), Object.create(s(e), t);
}, u = (e)=>e[t] || e, a = (s, c, f, p)=>{
    if (!l(s)) return s;
    let g = p && p.get(s);
    if (!g) {
        const e = u(s);
        g = ((e)=>Object.values(Object.getOwnPropertyDescriptors(e)).some((e)=>!e.configurable && !e.writable))(e) ? [
            e,
            i(e)
        ] : [
            e
        ], null == p || p.set(s, g);
    }
    const [y, h] = g;
    let w = f && f.get(y);
    return w && w[1].f === !!h || (w = ((o, s)=>{
        const c = {
            f: s
        };
        let l = !1;
        const f = (e, t)=>{
            if (!l) {
                let s = c[r].get(o);
                if (s || (s = {}, c[r].set(o, s)), e === n) s[n] = !0;
                else {
                    let r = s[e];
                    r || (r = new Set, s[e] = r), r.add(t);
                }
            }
        }, i = {
            get: (e, n)=>n === t ? o : (f("k", n), a(Reflect.get(e, n), c[r], c.c, c.t)),
            has: (t, n)=>n === e ? (l = !0, c[r].delete(o), !0) : (f("h", n), Reflect.has(t, n)),
            getOwnPropertyDescriptor: (e, t)=>(f("o", t), Reflect.getOwnPropertyDescriptor(e, t)),
            ownKeys: (e)=>(f(n), Reflect.ownKeys(e))
        };
        return s && (i.set = i.deleteProperty = ()=>!1), [
            i,
            c
        ];
    })(y, !!h), w[1].p = o(h || y, w[0]), f && f.set(y, w)), w[1][r] = c, w[1].c = f, w[1].t = p, w[1].p;
}, p = (e, t, r, o)=>{
    if (Object.is(e, t)) return !1;
    if (!f(e) || !f(t)) return !0;
    const s = r.get(u(e));
    if (!s) return !0;
    if (o) {
        const r = o.get(e);
        if (r && r.n === t) return r.g;
        o.set(e, {
            n: t,
            g: !1
        });
    }
    let c = null;
    try {
        for (const r of s.h || [])if (c = Reflect.has(e, r) !== Reflect.has(t, r), c) return c;
        if (!0 === s[n]) {
            if (c = ((e, t)=>{
                const r = Reflect.ownKeys(e), n = Reflect.ownKeys(t);
                return r.length !== n.length || r.some((e, t)=>e !== n[t]);
            })(e, t), c) return c;
        } else for (const r of s.o || [])if (c = !!Reflect.getOwnPropertyDescriptor(e, r) != !!Reflect.getOwnPropertyDescriptor(t, r), c) return c;
        for (const n of s.k || [])if (c = p(e[n], t[n], r, o), c) return c;
        return null === c && (c = !0), c;
    } finally{
        o && o.set(e, {
            n: t,
            g: c
        });
    }
}, g = (t)=>!!l(t) && e in t, y = (e)=>l(e) && e[t] || null, h = (e, t = !0)=>{
    c.set(e, t);
}, w = (e, t, r)=>{
    const o = [], s = new WeakSet, c = (e, l)=>{
        if (s.has(e)) return;
        f(e) && s.add(e);
        const i = f(e) && t.get(u(e));
        if (i) {
            var a, p;
            if (null == (a = i.h) || a.forEach((e)=>{
                const t = `:has(${String(e)})`;
                o.push(l ? [
                    ...l,
                    t
                ] : [
                    t
                ]);
            }), !0 === i[n]) {
                const e = ":ownKeys";
                o.push(l ? [
                    ...l,
                    e
                ] : [
                    e
                ]);
            } else {
                var g;
                null == (g = i.o) || g.forEach((e)=>{
                    const t = `:hasOwn(${String(e)})`;
                    o.push(l ? [
                        ...l,
                        t
                    ] : [
                        t
                    ]);
                });
            }
            null == (p = i.k) || p.forEach((t)=>{
                r && !("value" in (Object.getOwnPropertyDescriptor(e, t) || {})) || c(e[t], l ? [
                    ...l,
                    t
                ] : [
                    t
                ]);
            });
        } else l && o.push(l);
    };
    return c(e), o;
}, O = (e)=>{
    o = e;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"2MWYC":[function(require,module,exports) {
module.exports = Promise.all([
    require("586a4d403262d85d")(require("312bd353832b3abd").getBundleURL("UckoE") + "dist.cfc2dba3.js" + "?" + Date.now()).catch((err)=>{
        delete module.bundle.cache[module.id];
        throw err;
    }),
    require("586a4d403262d85d")(require("312bd353832b3abd").getBundleURL("UckoE") + "dist.6909d6fe.js" + "?" + Date.now()).catch((err)=>{
        delete module.bundle.cache[module.id];
        throw err;
    })
]).then(()=>module.bundle.root("jCFDj"));

},{"586a4d403262d85d":"61B45","312bd353832b3abd":"lgJ39"}],"fjq96":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>(0, _chunkD7TYCC3TJs.arbitrum));
parcelHelpers.export(exports, "arbitrumGoerli", ()=>(0, _chunkD7TYCC3TJs.arbitrumGoerli));
parcelHelpers.export(exports, "aurora", ()=>(0, _chunkD7TYCC3TJs.aurora));
parcelHelpers.export(exports, "auroraTestnet", ()=>(0, _chunkD7TYCC3TJs.auroraTestnet));
parcelHelpers.export(exports, "avalanche", ()=>(0, _chunkD7TYCC3TJs.avalanche));
parcelHelpers.export(exports, "avalancheFuji", ()=>(0, _chunkD7TYCC3TJs.avalancheFuji));
parcelHelpers.export(exports, "baseGoerli", ()=>(0, _chunkD7TYCC3TJs.baseGoerli));
parcelHelpers.export(exports, "boba", ()=>(0, _chunkD7TYCC3TJs.boba));
parcelHelpers.export(exports, "bronos", ()=>(0, _chunkD7TYCC3TJs.bronos));
parcelHelpers.export(exports, "bronosTestnet", ()=>(0, _chunkD7TYCC3TJs.bronosTestnet));
parcelHelpers.export(exports, "bsc", ()=>(0, _chunkD7TYCC3TJs.bsc));
parcelHelpers.export(exports, "bscTestnet", ()=>(0, _chunkD7TYCC3TJs.bscTestnet));
parcelHelpers.export(exports, "bxn", ()=>(0, _chunkD7TYCC3TJs.bxn));
parcelHelpers.export(exports, "bxnTestnet", ()=>(0, _chunkD7TYCC3TJs.bxnTestnet));
parcelHelpers.export(exports, "canto", ()=>(0, _chunkD7TYCC3TJs.canto));
parcelHelpers.export(exports, "celo", ()=>(0, _chunkD7TYCC3TJs.celo));
parcelHelpers.export(exports, "celoAlfajores", ()=>(0, _chunkD7TYCC3TJs.celoAlfajores));
parcelHelpers.export(exports, "celoCannoli", ()=>(0, _chunkD7TYCC3TJs.celoCannoli));
parcelHelpers.export(exports, "cronos", ()=>(0, _chunkD7TYCC3TJs.cronos));
parcelHelpers.export(exports, "cronosTestnet", ()=>(0, _chunkD7TYCC3TJs.cronosTestnet));
parcelHelpers.export(exports, "crossbell", ()=>(0, _chunkD7TYCC3TJs.crossbell));
parcelHelpers.export(exports, "dfk", ()=>(0, _chunkD7TYCC3TJs.dfk));
parcelHelpers.export(exports, "dogechain", ()=>(0, _chunkD7TYCC3TJs.dogechain));
parcelHelpers.export(exports, "edgeware", ()=>(0, _chunkD7TYCC3TJs.edgeware));
parcelHelpers.export(exports, "edgewareTestnet", ()=>(0, _chunkD7TYCC3TJs.edgewareTestnet));
parcelHelpers.export(exports, "evmos", ()=>(0, _chunkD7TYCC3TJs.evmos));
parcelHelpers.export(exports, "evmosTestnet", ()=>(0, _chunkD7TYCC3TJs.evmosTestnet));
parcelHelpers.export(exports, "fantom", ()=>(0, _chunkD7TYCC3TJs.fantom));
parcelHelpers.export(exports, "fantomTestnet", ()=>(0, _chunkD7TYCC3TJs.fantomTestnet));
parcelHelpers.export(exports, "fibo", ()=>(0, _chunkD7TYCC3TJs.fibo));
parcelHelpers.export(exports, "filecoin", ()=>(0, _chunkD7TYCC3TJs.filecoin));
parcelHelpers.export(exports, "filecoinCalibration", ()=>(0, _chunkD7TYCC3TJs.filecoinCalibration));
parcelHelpers.export(exports, "filecoinHyperspace", ()=>(0, _chunkD7TYCC3TJs.filecoinHyperspace));
parcelHelpers.export(exports, "flare", ()=>(0, _chunkD7TYCC3TJs.flare));
parcelHelpers.export(exports, "flareTestnet", ()=>(0, _chunkD7TYCC3TJs.flareTestnet));
parcelHelpers.export(exports, "foundry", ()=>(0, _chunkD7TYCC3TJs.foundry));
parcelHelpers.export(exports, "gnosis", ()=>(0, _chunkD7TYCC3TJs.gnosis));
parcelHelpers.export(exports, "gnosisChiado", ()=>(0, _chunkD7TYCC3TJs.gnosisChiado));
parcelHelpers.export(exports, "goerli", ()=>(0, _chunkD7TYCC3TJs.goerli));
parcelHelpers.export(exports, "haqqMainnet", ()=>(0, _chunkD7TYCC3TJs.haqqMainnet));
parcelHelpers.export(exports, "haqqTestedge2", ()=>(0, _chunkD7TYCC3TJs.haqqTestedge2));
parcelHelpers.export(exports, "hardhat", ()=>(0, _chunkD7TYCC3TJs.hardhat));
parcelHelpers.export(exports, "harmonyOne", ()=>(0, _chunkD7TYCC3TJs.harmonyOne));
parcelHelpers.export(exports, "iotex", ()=>(0, _chunkD7TYCC3TJs.iotex));
parcelHelpers.export(exports, "iotexTestnet", ()=>(0, _chunkD7TYCC3TJs.iotexTestnet));
parcelHelpers.export(exports, "klaytn", ()=>(0, _chunkD7TYCC3TJs.klaytn));
parcelHelpers.export(exports, "lineaTestnet", ()=>(0, _chunkD7TYCC3TJs.lineaTestnet));
parcelHelpers.export(exports, "localhost", ()=>(0, _chunkD7TYCC3TJs.localhost));
parcelHelpers.export(exports, "mainnet", ()=>(0, _chunkD7TYCC3TJs.mainnet));
parcelHelpers.export(exports, "metis", ()=>(0, _chunkD7TYCC3TJs.metis));
parcelHelpers.export(exports, "metisGoerli", ()=>(0, _chunkD7TYCC3TJs.metisGoerli));
parcelHelpers.export(exports, "moonbaseAlpha", ()=>(0, _chunkD7TYCC3TJs.moonbaseAlpha));
parcelHelpers.export(exports, "moonbeam", ()=>(0, _chunkD7TYCC3TJs.moonbeam));
parcelHelpers.export(exports, "moonriver", ()=>(0, _chunkD7TYCC3TJs.moonriver));
parcelHelpers.export(exports, "nexi", ()=>(0, _chunkD7TYCC3TJs.nexi));
parcelHelpers.export(exports, "okc", ()=>(0, _chunkD7TYCC3TJs.okc));
parcelHelpers.export(exports, "optimism", ()=>(0, _chunkD7TYCC3TJs.optimism));
parcelHelpers.export(exports, "optimismGoerli", ()=>(0, _chunkD7TYCC3TJs.optimismGoerli));
parcelHelpers.export(exports, "polygon", ()=>(0, _chunkD7TYCC3TJs.polygon));
parcelHelpers.export(exports, "polygonMumbai", ()=>(0, _chunkD7TYCC3TJs.polygonMumbai));
parcelHelpers.export(exports, "polygonZkEvm", ()=>(0, _chunkD7TYCC3TJs.polygonZkEvm));
parcelHelpers.export(exports, "polygonZkEvmTestnet", ()=>(0, _chunkD7TYCC3TJs.polygonZkEvmTestnet));
parcelHelpers.export(exports, "pulsechain", ()=>(0, _chunkD7TYCC3TJs.pulsechain));
parcelHelpers.export(exports, "pulsechainV4", ()=>(0, _chunkD7TYCC3TJs.pulsechainV4));
parcelHelpers.export(exports, "scrollTestnet", ()=>(0, _chunkD7TYCC3TJs.scrollTestnet));
parcelHelpers.export(exports, "sepolia", ()=>(0, _chunkD7TYCC3TJs.sepolia));
parcelHelpers.export(exports, "shardeumSphinx", ()=>(0, _chunkD7TYCC3TJs.shardeumSphinx));
parcelHelpers.export(exports, "skaleBlockBrawlers", ()=>(0, _chunkD7TYCC3TJs.skaleBlockBrawlers));
parcelHelpers.export(exports, "skaleCalypso", ()=>(0, _chunkD7TYCC3TJs.skaleCalypso));
parcelHelpers.export(exports, "skaleCalypsoTestnet", ()=>(0, _chunkD7TYCC3TJs.skaleCalypsoTestnet));
parcelHelpers.export(exports, "skaleChaosTestnet", ()=>(0, _chunkD7TYCC3TJs.skaleChaosTestnet));
parcelHelpers.export(exports, "skaleCryptoBlades", ()=>(0, _chunkD7TYCC3TJs.skaleCryptoBlades));
parcelHelpers.export(exports, "skaleCryptoColosseum", ()=>(0, _chunkD7TYCC3TJs.skaleCryptoColosseum));
parcelHelpers.export(exports, "skaleEuropa", ()=>(0, _chunkD7TYCC3TJs.skaleEuropa));
parcelHelpers.export(exports, "skaleEuropaTestnet", ()=>(0, _chunkD7TYCC3TJs.skaleEuropaTestnet));
parcelHelpers.export(exports, "skaleExorde", ()=>(0, _chunkD7TYCC3TJs.skaleExorde));
parcelHelpers.export(exports, "skaleHumanProtocol", ()=>(0, _chunkD7TYCC3TJs.skaleHumanProtocol));
parcelHelpers.export(exports, "skaleNebula", ()=>(0, _chunkD7TYCC3TJs.skaleNebula));
parcelHelpers.export(exports, "skaleNebulaTestnet", ()=>(0, _chunkD7TYCC3TJs.skaleNebulaTestnet));
parcelHelpers.export(exports, "skaleRazor", ()=>(0, _chunkD7TYCC3TJs.skaleRazor));
parcelHelpers.export(exports, "skaleTitan", ()=>(0, _chunkD7TYCC3TJs.skaleTitan));
parcelHelpers.export(exports, "skaleTitanTestnet", ()=>(0, _chunkD7TYCC3TJs.skaleTitanTestnet));
parcelHelpers.export(exports, "songbird", ()=>(0, _chunkD7TYCC3TJs.songbird));
parcelHelpers.export(exports, "songbirdTestnet", ()=>(0, _chunkD7TYCC3TJs.songbirdTestnet));
parcelHelpers.export(exports, "syscoin", ()=>(0, _chunkD7TYCC3TJs.syscoin));
parcelHelpers.export(exports, "taraxa", ()=>(0, _chunkD7TYCC3TJs.taraxa));
parcelHelpers.export(exports, "taraxaTestnet", ()=>(0, _chunkD7TYCC3TJs.taraxaTestnet));
parcelHelpers.export(exports, "telos", ()=>(0, _chunkD7TYCC3TJs.telos));
parcelHelpers.export(exports, "telosTestnet", ()=>(0, _chunkD7TYCC3TJs.telosTestnet));
parcelHelpers.export(exports, "thunderTestnet", ()=>(0, _chunkD7TYCC3TJs.thunderTestnet));
parcelHelpers.export(exports, "wanchain", ()=>(0, _chunkD7TYCC3TJs.wanchain));
parcelHelpers.export(exports, "wanchainTestnet", ()=>(0, _chunkD7TYCC3TJs.wanchainTestnet));
parcelHelpers.export(exports, "xdc", ()=>(0, _chunkD7TYCC3TJs.xdc));
parcelHelpers.export(exports, "xdcTestnet", ()=>(0, _chunkD7TYCC3TJs.xdcTestnet));
parcelHelpers.export(exports, "zhejiang", ()=>(0, _chunkD7TYCC3TJs.zhejiang));
parcelHelpers.export(exports, "zkSync", ()=>(0, _chunkD7TYCC3TJs.zkSync));
parcelHelpers.export(exports, "zkSyncTestnet", ()=>(0, _chunkD7TYCC3TJs.zkSyncTestnet));
parcelHelpers.export(exports, "zora", ()=>(0, _chunkD7TYCC3TJs.zora));
parcelHelpers.export(exports, "zoraTestnet", ()=>(0, _chunkD7TYCC3TJs.zoraTestnet));
var _chunkD7TYCC3TJs = require("./chunk-D7TYCC3T.js");
var _chunkMQXBDTVKJs = require("./chunk-MQXBDTVK.js");

},{"./chunk-D7TYCC3T.js":"3eevR","./chunk-MQXBDTVK.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["2UeK4","bB7Pu"], "bB7Pu", "parcelRequired248")

//# sourceMappingURL=index.3d214d75.js.map
